import { useCallback } from 'react';
import type { VideoDetails } from '../../../core/utils/youtubeApi';
import type { SnapshotRequestParams } from '../types/versionManagement';
import { VersionService } from '../services/VersionService';
import { TrafficDataService } from '../../../core/services/traffic/TrafficDataService';

interface UseVersionManagementProps {
    versions: any; // usePackagingVersions return type
    isFormDirty: boolean;
    video: VideoDetails;
    user: any;
    currentChannel: any;
    updateVideo: any;
    showToast: (message: string, type: 'success' | 'error') => void;
    setSelectedSnapshot: (id: string | null) => void;
    activeTab: 'packaging' | 'traffic';
    selectedSnapshot: string | null;
    trafficState: any; // useTrafficData return type
    onOpenSwitchConfirm: (targetVersion: number | 'draft') => void;
    onOpenDeleteConfirm: (versionNumber: number, snapshotCount: number, totalViews: number, versionLabel?: string, isStacked?: boolean) => void;
    onOpenSnapshotRequest: (params: SnapshotRequestParams) => void;
}

/**
 * Хук для управления версиями (переключение, удаление, восстановление).
 * Извлекает бизнес-логику из DetailsLayout.
 */
export const useVersionManagement = ({
    versions,
    isFormDirty,
    video,
    user,
    currentChannel,
    updateVideo,
    showToast,
    setSelectedSnapshot,
    activeTab,
    selectedSnapshot,
    trafficState,
    onOpenSwitchConfirm,
    onOpenDeleteConfirm,
    onOpenSnapshotRequest
}: UseVersionManagementProps) => {

    /**
     * Обработчик клика на версию в sidebar
     */
    const handleVersionClick = useCallback((versionNumber: number | 'draft', periodIndex?: number) => {
        // Разрешаем кликать на текущую версию для очистки selected snapshot
        if (versionNumber === versions.viewingVersion && periodIndex === versions.viewingPeriodIndex) {
            if (activeTab === 'traffic' && selectedSnapshot) {
                setSelectedSnapshot(null);
            }
            return;
        }

        if (isFormDirty) {
            // Если есть несохраненные изменения → показываем confirmation
            onOpenSwitchConfirm(versionNumber);
        } else {
            // Очищаем selected snapshot
            setSelectedSnapshot(null);
            // Переключаем версию
            versions.switchToVersion(versionNumber, periodIndex);
        }
    }, [versions, isFormDirty, activeTab, selectedSnapshot, setSelectedSnapshot, onOpenSwitchConfirm]);

    /**
     * Подтверждение переключения версии (после discard changes)
     */
    const confirmSwitch = useCallback((targetVersion: number | 'draft') => {
        setSelectedSnapshot(null);
        versions.switchToVersion(targetVersion);
    }, [versions, setSelectedSnapshot]);

    /**
     * Обработчик удаления версии.
     * Проверяет наличие traffic snapshots для этой версии (только для опубликованных видео).
     */
    const handleDeleteVersion = useCallback((versionNumber: number, versionLabel?: string) => {
        // Проверяем, есть ли связанные снепшоты трафика
        const relatedSnapshots = trafficState.trafficData?.snapshots?.filter(
            (s: any) => s.version === versionNumber
        ) || [];

        // Legacy Stack Detection removed as we now do Group Deletion
        // Calculate "views generated by this version"
        // Logic: (Latest snapshot total views) - (Previous version's latest snapshot total views)
        let totalViews = 0;

        if (relatedSnapshots.length > 0) {
            // Get latest snapshot for current version
            const latestSnapshot = relatedSnapshots.sort((a: any, b: any) => b.timestamp - a.timestamp)[0];
            const currentTotalViews = latestSnapshot.summary?.totalViews || 0;

            // Get previous version's latest snapshot view count
            // Find snapshots for version < versionNumber
            const allSnapshots = trafficState.trafficData?.snapshots || [];
            const previousVersionSnapshots = allSnapshots.filter((s: any) => s.version < versionNumber);

            let previousTotalViews = 0;
            if (previousVersionSnapshots.length > 0) {
                const latestPrevSnapshot = previousVersionSnapshots.sort((a: any, b: any) => b.timestamp - a.timestamp)[0];
                previousTotalViews = latestPrevSnapshot.summary?.totalViews || 0;
            }

            // Delta
            totalViews = Math.max(0, currentTotalViews - previousTotalViews);
        }

        onOpenDeleteConfirm(versionNumber, relatedSnapshots.length, totalViews, versionLabel);
    }, [trafficState, onOpenDeleteConfirm]);

    /**
     * Подтверждение удаления версии.
     * Для опубликованных видео с traffic snapshots сохраняет packaging данные перед удалением.
     */
    const confirmDelete = useCallback(async (versionNumber: number) => {
        // GROUP DELETION LOGIC:
        // Find all versions that belong to the same "visual group" (same canonical ID)
        // and delete them all together.
        const targetVersionData = versions.packagingHistory.find((v: any) => v.versionNumber === versionNumber);
        let versionsToDelete = [versionNumber];

        if (targetVersionData) {
            const canonicalId = targetVersionData.cloneOf || targetVersionData.versionNumber;
            const siblings = versions.packagingHistory.filter((v: any) =>
                (v.cloneOf || v.versionNumber) === canonicalId
            );
            versionsToDelete = siblings.map((v: any) => v.versionNumber);
        }

        // PACKAGING SNAPSHOT PRESERVATION for ALL deleted versions
        if (user?.uid && currentChannel?.id && video.id) {
            // Find all snapshots related to ANY of the versions being deleted
            const snapshotsForVersions = trafficState.trafficData?.snapshots?.filter(
                (s: any) => versionsToDelete.includes(s.version)
            ) || [];

            if (snapshotsForVersions.length > 0) {
                // For each snapshot, find its corresponding version data to preserve
                const updatedSnapshots = trafficState.trafficData.snapshots.map((s: any) => {
                    if (versionsToDelete.includes(s.version)) {
                        const versionData = versions.packagingHistory.find(
                            (v: any) => v.versionNumber === s.version
                        );
                        const packagingSnapshot = versionData?.configurationSnapshot;

                        if (packagingSnapshot) {
                            return {
                                ...s,
                                packagingSnapshot: {
                                    title: packagingSnapshot.title,
                                    description: packagingSnapshot.description,
                                    tags: packagingSnapshot.tags,
                                    coverImage: packagingSnapshot.coverImage,
                                    abTestTitles: packagingSnapshot.abTestTitles,
                                    abTestThumbnails: packagingSnapshot.abTestThumbnails,
                                    abTestResults: packagingSnapshot.abTestResults,
                                    localizations: packagingSnapshot.localizations,
                                    cloneOf: versionData.cloneOf,
                                    restoredAt: versionData.restoredAt
                                },
                                isPackagingDeleted: true
                            };
                        }
                    }
                    return s;
                });

                // Update snapshots in Firestore
                await TrafficDataService.updateSnapshots(
                    user.uid,
                    currentChannel.id,
                    video.id,
                    updatedSnapshots
                );
                await trafficState.refetch();
            }
        }

        // Calculate delete data for the GROUP
        const deleteData = VersionService.calculateDeleteVersionData(
            versionsToDelete, // Pass array
            versions.packagingHistory,
            versions.activeVersion
        );

        // Update UI State
        // Remove strictly the single version requested
        versions.deleteVersion(versionNumber);

        // Update Active Version if we are deleting the active one
        // and switching to a new one
        if (deleteData.newCurrentVersion) {
            versions.setActiveVersion(deleteData.newCurrentVersion);
        }
        if (deleteData.newActiveVersion !== undefined) {
            versions.setActiveVersion(deleteData.newActiveVersion);
            // If viewing any of the deleted versions, switch to new active
            if (versionsToDelete.includes(versions.viewingVersion)) {
                versions.switchToVersion(deleteData.newActiveVersion);
            }
        }

        showToast(`Version group deleted`, 'success');

        // Save to Firestore
        if (user?.uid && currentChannel?.id && video.id) {
            updateVideo({
                videoId: video.id,
                updates: {
                    ...deleteData.rollbackUpdates,
                    packagingHistory: deleteData.updatedHistory,
                    currentPackagingVersion: deleteData.newCurrentVersion,
                    isDraft: deleteData.willHaveDraft
                }
            }).catch((error: Error) => {
                console.error('Failed to save deletion:', error);
                showToast('Failed to save deletion', 'error');
            });
        }
    }, [versions, video, user, currentChannel, updateVideo, showToast, trafficState]);

    /**
     * Обработчик восстановления версии
     */
    /**
     * Обработчик восстановления версии (Immutable Data Pattern).
     * Создает новую верси (клон) на основе старой.
     */
    const handleRestoreVersion = useCallback(async (versionToRestore: number) => {
        // IMMUTABLE RESTORE LOGIC (Clone/Alias Strategy)
        // We now always use cloning when restoring from history to maintain data integrity
        // and separate traffic snapshots for each activation period.

        // 1. Получаем данные исторической версии
        const targetVersionData = versions.packagingHistory.find(
            (v: any) => v.versionNumber === versionToRestore
        );

        if (!targetVersionData || !targetVersionData.configurationSnapshot) {
            showToast('Version data not found', 'error');
            return;
        }

        // STEP: Определяем активную версию для Snapshot Request
        let activeVersionToSnapshot: number | null = null;
        if (typeof versions.activeVersion === 'number') {
            activeVersionToSnapshot = versions.activeVersion;
        } else if (versions.activeVersion === 'draft') {
            // Fallback logic SAME AS usePackagingActions to be consistent
            if (versions.packagingHistory.length > 0) {
                const latestByDate = versions.packagingHistory.reduce((best: any, current: any) => {
                    const currentStart = current.activePeriods?.reduce((max: number, p: any) =>
                        (p.startDate || 0) > (max || 0) ? (p.startDate || 0) : (max || 0)
                        , 0) || 0;
                    const bestStart = best?.activePeriods?.reduce((max: number, p: any) =>
                        (p.startDate || 0) > (max || 0) ? (p.startDate || 0) : (max || 0)
                        , 0) || 0;
                    return currentStart > bestStart ? current : best;
                }, null);

                if (latestByDate && (latestByDate.activePeriods?.length || 0) > 0) {
                    activeVersionToSnapshot = latestByDate.versionNumber;
                } else {
                    activeVersionToSnapshot = Math.max(...versions.packagingHistory.map((v: any) => v.versionNumber));
                }
            }
        }

        // 2. Логика восстановления с запросом снепшота
        let closingSnapshotId: string | null | undefined = null;

        // Если есть активная версия (и это не та, которую мы восстанавливаем), предлагаем сохранить данные
        if (activeVersionToSnapshot && activeVersionToSnapshot !== versionToRestore && video.publishedVideoId) {
            const result = await new Promise<string | null | undefined>((resolve) => {
                onOpenSnapshotRequest({
                    versionToRestore, // Pass for context if needed, though mostly for legacy logic
                    isForCreateVersion: false, // It IS for restore, but we use 'false' to trigger restore callback flow? 
                    // ACTUALLY: The legacy hook logic is complex. 
                    // Let's keep it simple: We use a Promise here, same as createVersion.
                    resolveCallback: (id) => resolve(id),
                    versionNumber: activeVersionToSnapshot!,
                    context: 'restore'
                });
            });

            if (result === undefined) return; // Cancelled
            closingSnapshotId = result;
        }


        // 3. Update Local State (adds new active period to existing version)
        // Pass closingSnapshotId to close the PREVIOUS active period
        versions.restoreVersion(versionToRestore, closingSnapshotId);

        // ... (rest of the restore logic updates UI state)
        versions.setActiveVersion(versionToRestore);
        versions.setHasDraft(false);

        // 4. Update Firestore
        // We need to calculate the updated history with the new period added to the target version
        // and the previous active version closed.
        const updatedHistory = versions.packagingHistory.map((v: any) => {
            if (v.versionNumber === versionToRestore) {
                return VersionService.addNewActivePeriod(VersionService.closeAllPeriods(v, closingSnapshotId));
            }
            return VersionService.closeAllPeriods(v, closingSnapshotId);
        });

        // 5. Сохраняем в Firestore
        if (user?.uid && currentChannel?.id && video.id) {
            try {
                await updateVideo({
                    videoId: video.id,
                    updates: {
                        packagingHistory: updatedHistory,
                        activeVersion: versionToRestore,
                        isDraft: false,
                        // Восстанавливаем данные на уровне полей видео (для UI превью)
                        title: targetVersionData.configurationSnapshot.title,
                        description: targetVersionData.configurationSnapshot.description,
                        tags: targetVersionData.configurationSnapshot.tags,
                        thumbnailUrl: targetVersionData.configurationSnapshot.coverImage, // Changed from customImage
                        abTestTitles: targetVersionData.configurationSnapshot.abTestTitles,
                        abTestThumbnails: targetVersionData.configurationSnapshot.abTestThumbnails,
                        localizations: targetVersionData.configurationSnapshot.localizations
                    }
                });
                // 6. Toast
                showToast(`Restored v.${versionToRestore}`, 'success');
            } catch (error) {
                console.error("Failed to update video history on restore:", error);
                showToast("Failed to save restore to server", "error");
            }
        }
    }, [video, versions, user, currentChannel, updateVideo, showToast, onOpenSnapshotRequest]);

    return {
        handleVersionClick,
        confirmSwitch,
        handleDeleteVersion,
        confirmDelete,
        handleRestoreVersion
    };
};
