import { useCallback } from 'react';
import type { VideoDetails } from '../../../core/utils/youtubeApi';
import { VersionService } from '../services/VersionService';
import { TrafficDataService } from '../../../core/services/traffic/TrafficDataService';

interface UseVersionManagementProps {
    versions: any; // usePackagingVersions return type
    isFormDirty: boolean;
    video: VideoDetails;
    user: any;
    currentChannel: any;
    updateVideo: any;
    showToast: (message: string, type: 'success' | 'error') => void;
    setSelectedSnapshot: (id: string | null) => void;
    activeTab: 'packaging' | 'traffic';
    selectedSnapshot: string | null;
    trafficState: any; // useTrafficData return type
    onOpenSwitchConfirm: (targetVersion: number | 'draft') => void;
    onOpenDeleteConfirm: (versionNumber: number, snapshotCount?: number, totalViews?: number) => void;
    onOpenSnapshotRequest: (params: { versionToRestore: number; isForCreateVersion: boolean }) => void;
}

/**
 * Хук для управления версиями (переключение, удаление, восстановление).
 * Извлекает бизнес-логику из DetailsLayout.
 */
export const useVersionManagement = ({
    versions,
    isFormDirty,
    video,
    user,
    currentChannel,
    updateVideo,
    showToast,
    setSelectedSnapshot,
    activeTab,
    selectedSnapshot,
    trafficState,
    onOpenSwitchConfirm,
    onOpenDeleteConfirm,
    onOpenSnapshotRequest
}: UseVersionManagementProps) => {

    /**
     * Обработчик клика на версию в sidebar
     */
    const handleVersionClick = useCallback((versionNumber: number | 'draft') => {
        // Разрешаем кликать на текущую версию для очистки selected snapshot
        if (versionNumber === versions.viewingVersion) {
            if (activeTab === 'traffic' && selectedSnapshot) {
                setSelectedSnapshot(null);
            }
            return;
        }

        if (isFormDirty) {
            // Если есть несохраненные изменения → показываем confirmation
            onOpenSwitchConfirm(versionNumber);
        } else {
            // Очищаем selected snapshot
            setSelectedSnapshot(null);
            // Переключаем версию
            versions.switchToVersion(versionNumber);
        }
    }, [versions, isFormDirty, activeTab, selectedSnapshot, setSelectedSnapshot, onOpenSwitchConfirm]);

    /**
     * Подтверждение переключения версии (после discard changes)
     */
    const confirmSwitch = useCallback((targetVersion: number | 'draft') => {
        setSelectedSnapshot(null);
        versions.switchToVersion(targetVersion);
    }, [versions, setSelectedSnapshot]);

    /**
     * Обработчик удаления версии.
     * Проверяет наличие traffic snapshots для этой версии (только для опубликованных видео).
     */
    const handleDeleteVersion = useCallback((versionNumber: number) => {
        // Проверяем наличие snapshots для всех видео (включая неопубликованные/custom)
        const snapshotsForVersion = trafficState.trafficData?.snapshots?.filter(
            (s: any) => s.version === versionNumber
        ) || [];

        // Calculate "views generated by this version"
        // Logic: (Latest snapshot total views) - (Previous version's latest snapshot total views)
        let totalViews = 0;

        if (snapshotsForVersion.length > 0) {
            // Get latest snapshot for current version
            const latestSnapshot = snapshotsForVersion.sort((a: any, b: any) => b.timestamp - a.timestamp)[0];
            const currentTotalViews = latestSnapshot.summary?.totalViews || 0;

            // Get previous version's latest snapshot view count
            // Find snapshots for version < versionNumber
            const allSnapshots = trafficState.trafficData?.snapshots || [];
            const previousVersionSnapshots = allSnapshots.filter((s: any) => s.version < versionNumber);

            let previousTotalViews = 0;
            if (previousVersionSnapshots.length > 0) {
                const latestPrevSnapshot = previousVersionSnapshots.sort((a: any, b: any) => b.timestamp - a.timestamp)[0];
                previousTotalViews = latestPrevSnapshot.summary?.totalViews || 0;
            }

            // Delta
            totalViews = Math.max(0, currentTotalViews - previousTotalViews);
        }

        onOpenDeleteConfirm(versionNumber, snapshotsForVersion.length, totalViews);
    }, [trafficState, onOpenDeleteConfirm]);

    /**
     * Подтверждение удаления версии.
     * Для опубликованных видео с traffic snapshots сохраняет packaging данные перед удалением.
     */
    const confirmDelete = useCallback(async (versionNumber: number) => {
        // PACKAGING SNAPSHOT PRESERVATION: Сохраняем packaging данные в traffic snapshots
        // Работает для любых видео, если есть snapshots
        if (user?.uid && currentChannel?.id && video.id) {
            const snapshotsForVersion = trafficState.trafficData?.snapshots?.filter(
                (s: any) => s.version === versionNumber
            ) || [];

            if (snapshotsForVersion.length > 0) {
                // Получаем packaging snapshot для сохранения
                const versionData = versions.packagingHistory.find(
                    (v: any) => v.versionNumber === versionNumber
                );
                const packagingSnapshot = versionData?.configurationSnapshot;

                if (packagingSnapshot) {
                    // Обновляем все snapshots этой версии, добавляя packaging данные
                    const updatedSnapshots = trafficState.trafficData.snapshots.map((s: any) =>
                        s.version === versionNumber
                            ? {
                                ...s,
                                packagingSnapshot: {
                                    title: packagingSnapshot.title,
                                    description: packagingSnapshot.description,
                                    tags: packagingSnapshot.tags,
                                    coverImage: packagingSnapshot.coverImage,
                                    abTestTitles: packagingSnapshot.abTestTitles,
                                    abTestThumbnails: packagingSnapshot.abTestThumbnails,
                                    abTestResults: packagingSnapshot.abTestResults,
                                    localizations: packagingSnapshot.localizations
                                },
                                isPackagingDeleted: true
                            }
                            : s
                    );

                    // Сохраняем обновленные snapshots в Firestore
                    await TrafficDataService.updateSnapshots(
                        user.uid,
                        currentChannel.id,
                        video.id,
                        updatedSnapshots
                    );

                    // Обновляем локальное состояние
                    await trafficState.refetch();
                }
            }
        }

        // Используем VersionService для расчета данных
        const deleteData = VersionService.calculateDeleteVersionData(
            versionNumber,
            versions.packagingHistory,
            versions.activeVersion
        );

        // Мгновенное обновление UI
        versions.deleteVersion(versionNumber);
        versions.setCurrentVersionNumber(deleteData.newCurrentVersion);
        versions.setHasDraft(deleteData.willHaveDraft);

        showToast(`Version ${versionNumber} deleted`, 'success');

        // Сохранение в Firestore
        if (user?.uid && currentChannel?.id && video.id) {
            updateVideo({
                videoId: video.id,
                updates: {
                    ...deleteData.rollbackUpdates,
                    packagingHistory: deleteData.updatedHistory,
                    currentPackagingVersion: deleteData.newCurrentVersion,
                    isDraft: deleteData.willHaveDraft
                }
            }).catch((error: Error) => {
                console.error('Failed to save deletion to Firestore:', error);
                showToast('Failed to save deletion', 'error');
            });
        }
    }, [versions, video, user, currentChannel, updateVideo, showToast]);

    /**
     * Обработчик восстановления версии
     */
    const handleRestoreVersion = useCallback(async (versionToRestore: number) => {
        const isPublished = !!video.publishedVideoId;

        if (isPublished) {
            // Для опубликованных видео показываем snapshot modal
            onOpenSnapshotRequest({ versionToRestore, isForCreateVersion: false });
        } else {
            // Для неопубликованных восстанавливаем напрямую
            versions.restoreVersion(versionToRestore);

            if (user?.uid && currentChannel?.id && video.id) {
                try {
                    const versionData = versions.packagingHistory.find(
                        (v: any) => v.versionNumber === versionToRestore
                    );
                    const snapshot = versionData?.configurationSnapshot;

                    if (!snapshot) {
                        showToast('Version data not found', 'error');
                        return;
                    }

                    const updatedHistory = versions.packagingHistory.map((v: any) =>
                        v.versionNumber === versionToRestore
                            ? { ...v, endDate: Date.now() }
                            : v
                    );

                    const restoreData = VersionService.prepareRestoreVersionData(
                        versionToRestore,
                        snapshot
                    );

                    await updateVideo({
                        videoId: video.id,
                        updates: {
                            packagingHistory: updatedHistory,
                            isDraft: false,
                            ...restoreData
                        }
                    });

                    showToast(`Restored to v.${versionToRestore}`, 'success');
                } catch (error) {
                    console.error('Failed to save restoration to Firestore:', error);
                    showToast('Failed to save restoration', 'error');
                }
            }
        }
    }, [video, versions, user, currentChannel, updateVideo, showToast, onOpenSnapshotRequest]);

    return {
        handleVersionClick,
        confirmSwitch,
        handleDeleteVersion,
        confirmDelete,
        handleRestoreVersion
    };
};
