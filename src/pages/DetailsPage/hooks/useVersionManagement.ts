import { useCallback } from 'react';
import type { VideoDetails } from '../../../core/utils/youtubeApi';
import { VersionService } from '../services/VersionService';
import { TrafficDataService } from '../../../core/services/traffic/TrafficDataService';

interface UseVersionManagementProps {
    versions: any; // usePackagingVersions return type
    isFormDirty: boolean;
    video: VideoDetails;
    user: any;
    currentChannel: any;
    updateVideo: any;
    showToast: (message: string, type: 'success' | 'error') => void;
    setSelectedSnapshot: (id: string | null) => void;
    activeTab: 'packaging' | 'traffic';
    selectedSnapshot: string | null;
    trafficState: any; // useTrafficData return type
    onOpenSwitchConfirm: (targetVersion: number | 'draft') => void;
    onOpenDeleteConfirm: (versionNumber: number, snapshotCount?: number, totalViews?: number) => void;
    onOpenSnapshotRequest: (params: { versionToRestore: number; isForCreateVersion: boolean }) => void;
}

/**
 * Хук для управления версиями (переключение, удаление, восстановление).
 * Извлекает бизнес-логику из DetailsLayout.
 */
export const useVersionManagement = ({
    versions,
    isFormDirty,
    video,
    user,
    currentChannel,
    updateVideo,
    showToast,
    setSelectedSnapshot,
    activeTab,
    selectedSnapshot,
    trafficState,
    onOpenSwitchConfirm,
    onOpenDeleteConfirm
}: UseVersionManagementProps) => {

    /**
     * Обработчик клика на версию в sidebar
     */
    const handleVersionClick = useCallback((versionNumber: number | 'draft') => {
        // Разрешаем кликать на текущую версию для очистки selected snapshot
        if (versionNumber === versions.viewingVersion) {
            if (activeTab === 'traffic' && selectedSnapshot) {
                setSelectedSnapshot(null);
            }
            return;
        }

        if (isFormDirty) {
            // Если есть несохраненные изменения → показываем confirmation
            onOpenSwitchConfirm(versionNumber);
        } else {
            // Очищаем selected snapshot
            setSelectedSnapshot(null);
            // Переключаем версию
            versions.switchToVersion(versionNumber);
        }
    }, [versions, isFormDirty, activeTab, selectedSnapshot, setSelectedSnapshot, onOpenSwitchConfirm]);

    /**
     * Подтверждение переключения версии (после discard changes)
     */
    const confirmSwitch = useCallback((targetVersion: number | 'draft') => {
        setSelectedSnapshot(null);
        versions.switchToVersion(targetVersion);
    }, [versions, setSelectedSnapshot]);

    /**
     * Обработчик удаления версии.
     * Проверяет наличие traffic snapshots для этой версии (только для опубликованных видео).
     */
    const handleDeleteVersion = useCallback((versionNumber: number) => {
        // Проверяем наличие snapshots для всех видео (включая неопубликованные/custom)
        const snapshotsForVersion = trafficState.trafficData?.snapshots?.filter(
            (s: any) => s.version === versionNumber
        ) || [];

        // Calculate "views generated by this version"
        // Logic: (Latest snapshot total views) - (Previous version's latest snapshot total views)
        let totalViews = 0;

        if (snapshotsForVersion.length > 0) {
            // Get latest snapshot for current version
            const latestSnapshot = snapshotsForVersion.sort((a: any, b: any) => b.timestamp - a.timestamp)[0];
            const currentTotalViews = latestSnapshot.summary?.totalViews || 0;

            // Get previous version's latest snapshot view count
            // Find snapshots for version < versionNumber
            const allSnapshots = trafficState.trafficData?.snapshots || [];
            const previousVersionSnapshots = allSnapshots.filter((s: any) => s.version < versionNumber);

            let previousTotalViews = 0;
            if (previousVersionSnapshots.length > 0) {
                const latestPrevSnapshot = previousVersionSnapshots.sort((a: any, b: any) => b.timestamp - a.timestamp)[0];
                previousTotalViews = latestPrevSnapshot.summary?.totalViews || 0;
            }

            // Delta
            totalViews = Math.max(0, currentTotalViews - previousTotalViews);
        }

        onOpenDeleteConfirm(versionNumber, snapshotsForVersion.length, totalViews);
    }, [trafficState, onOpenDeleteConfirm]);

    /**
     * Подтверждение удаления версии.
     * Для опубликованных видео с traffic snapshots сохраняет packaging данные перед удалением.
     */
    const confirmDelete = useCallback(async (versionNumber: number) => {
        // PACKAGING SNAPSHOT PRESERVATION: Сохраняем packaging данные в traffic snapshots
        // Работает для любых видео, если есть snapshots
        if (user?.uid && currentChannel?.id && video.id) {
            const snapshotsForVersion = trafficState.trafficData?.snapshots?.filter(
                (s: any) => s.version === versionNumber
            ) || [];

            if (snapshotsForVersion.length > 0) {
                // Получаем packaging snapshot для сохранения
                const versionData = versions.packagingHistory.find(
                    (v: any) => v.versionNumber === versionNumber
                );
                const packagingSnapshot = versionData?.configurationSnapshot;

                if (packagingSnapshot) {
                    // Обновляем все snapshots этой версии, добавляя packaging данные
                    const updatedSnapshots = trafficState.trafficData.snapshots.map((s: any) =>
                        s.version === versionNumber
                            ? {
                                ...s,
                                packagingSnapshot: {
                                    title: packagingSnapshot.title,
                                    description: packagingSnapshot.description,
                                    tags: packagingSnapshot.tags,
                                    coverImage: packagingSnapshot.coverImage,
                                    abTestTitles: packagingSnapshot.abTestTitles,
                                    abTestThumbnails: packagingSnapshot.abTestThumbnails,
                                    abTestResults: packagingSnapshot.abTestResults,
                                    localizations: packagingSnapshot.localizations,
                                    cloneOf: versionData.cloneOf,
                                    restoredAt: versionData.restoredAt
                                },
                                isPackagingDeleted: true
                            }
                            : s
                    );

                    // Сохраняем обновленные snapshots в Firestore
                    await TrafficDataService.updateSnapshots(
                        user.uid,
                        currentChannel.id,
                        video.id,
                        updatedSnapshots
                    );

                    // Обновляем локальное состояние
                    await trafficState.refetch();
                }
            }
        }

        // Используем VersionService для расчета данных
        const deleteData = VersionService.calculateDeleteVersionData(
            versionNumber,
            versions.packagingHistory,
            versions.activeVersion
        );

        // Мгновенное обновление UI
        versions.deleteVersion(versionNumber);
        versions.setCurrentVersionNumber(deleteData.newCurrentVersion);
        versions.setHasDraft(deleteData.willHaveDraft);

        showToast(`Version ${versionNumber} deleted`, 'success');

        // Сохранение в Firestore
        if (user?.uid && currentChannel?.id && video.id) {
            updateVideo({
                videoId: video.id,
                updates: {
                    ...deleteData.rollbackUpdates,
                    packagingHistory: deleteData.updatedHistory,
                    currentPackagingVersion: deleteData.newCurrentVersion,
                    isDraft: deleteData.willHaveDraft
                }
            }).catch((error: Error) => {
                console.error('Failed to save deletion to Firestore:', error);
                showToast('Failed to save deletion', 'error');
            });
        }
    }, [versions, video, user, currentChannel, updateVideo, showToast]);

    /**
     * Обработчик восстановления версии
     */
    /**
     * Обработчик восстановления версии (Immutable Data Pattern).
     * Создает новую верси (клон) на основе старой.
     */
    const handleRestoreVersion = useCallback(async (versionToRestore: number) => {
        // IMMUTABLE RESTORE LOGIC (Clone/Alias Strategy)
        // We now always use cloning when restoring from history to maintain data integrity
        // and separate traffic snapshots for each activation period.

        // 1. Получаем данные исторической версии
        const targetVersionData = versions.packagingHistory.find(
            (v: any) => v.versionNumber === versionToRestore
        );

        if (!targetVersionData || !targetVersionData.configurationSnapshot) {
            showToast('Version data not found', 'error');
            return;
        }

        // 2. Вычисляем номер следующей версии (v.Next)
        // Ищем максимальный номер версии в истории
        const maxVersion = Math.max(
            ...versions.packagingHistory.map((v: any) => v.versionNumber),
            versions.activeVersion
        );
        const nextVersionNumber = maxVersion + 1;

        // 3. Создаем новую запись в истории (Clone)
        const newHistoryEntry = {
            versionNumber: nextVersionNumber,
            startDate: Date.now(),
            endDate: null,
            configurationSnapshot: targetVersionData.configurationSnapshot,
            // METADATA для UI:
            cloneOf: versionToRestore,
            restoredAt: Date.now()
        };

        // 4. Обновляем историю: Закрываем текущую версию -> Добавляем новую
        const updatedHistory = versions.packagingHistory.map((v: any) => {
            // Закрываем текущую активную версию (если она еще открыта)
            if (v.versionNumber === versions.activeVersion && !v.endDate) {
                return { ...v, endDate: Date.now() };
            }
            return v;
        });

        // Добавляем новую версию-клон
        const finalHistory = [...updatedHistory, newHistoryEntry];

        // 5. Обновляем локальное состояние
        versions.setPackagingHistory(finalHistory);
        versions.setCurrentVersionNumber(nextVersionNumber);
        versions.setActiveVersion(nextVersionNumber); // Устанавливаем новую версию как активную
        versions.switchToVersion(nextVersionNumber);  // <--- FIX: Auto-switch view to the new version
        versions.setHasDraft(false);

        // 6. Сохраняем в Firestore
        if (user?.uid && currentChannel?.id && video.id) {
            try {
                await updateVideo({
                    videoId: video.id,
                    updates: {
                        packagingHistory: finalHistory,
                        currentPackagingVersion: nextVersionNumber,
                        activeVersion: nextVersionNumber, // Обновляем активную версию в Firestore
                        isDraft: false,
                        // Восстанавливаем данные на уровне полей видео (для UI превью)
                        title: targetVersionData.configurationSnapshot.title,
                        description: targetVersionData.configurationSnapshot.description,
                        tags: targetVersionData.configurationSnapshot.tags, // Array check inside updateVideo usually
                        thumbnailUrl: targetVersionData.configurationSnapshot.coverImage,
                        abTestTitles: targetVersionData.configurationSnapshot.abTestTitles,
                        abTestThumbnails: targetVersionData.configurationSnapshot.abTestThumbnails,
                        localizations: targetVersionData.configurationSnapshot.localizations
                    }
                });
                showToast(`Restored v.${versionToRestore} as v.${nextVersionNumber}`, 'success');
            } catch (error) {
                console.error('Failed to save restoration:', error);
                showToast('Failed to save restoration', 'error');
            }
        }
    }, [video, versions, user, currentChannel, updateVideo, showToast]);

    return {
        handleVersionClick,
        confirmSwitch,
        handleDeleteVersion,
        confirmDelete,
        handleRestoreVersion
    };
};
