import { db } from '../../config/firebase';
import { doc, setDoc, deleteField, getDocFromServer } from 'firebase/firestore';
import type { TrafficData, TrafficSource, TrafficSnapshot } from '../types/traffic';
import { generateSnapshotId } from '../utils/snapshotUtils';
import { uploadCsvSnapshot } from './storageService';



export const TrafficService = {
    /**
     * Get traffic data for a video
     */
    async fetchTrafficData(userId: string, channelId: string, videoId: string): Promise<TrafficData | null> {
        const path = `users/${userId}/channels/${channelId}/videos/${videoId}/traffic/main`;
        try {
            const docRef = doc(db, path);
            // Use getDocFromServer to ensure we don't get stale cached data
            const snapshot = await getDocFromServer(docRef);
            if (snapshot.exists()) {
                const data = snapshot.data() as TrafficData;
                // Ensure array existence for older data
                return {
                    ...data,
                    snapshots: data.snapshots || []
                };
            }
            return null;
        } catch (error) {
            console.error('Error fetching traffic data:', error);
            throw error;
        }
    },

    /**
     * Save/Overwrite traffic data
     */
    async saveTrafficData(userId: string, channelId: string, videoId: string, data: TrafficData): Promise<void> {
        const path = `users/${userId}/channels/${channelId}/videos/${videoId}/traffic/main`;
        try {
            const docRef = doc(db, path);
            // Sanitize data to remove any undefined fields that Firestore rejects
            const sanitizedData = this.sanitizeData(data);
            await setDoc(docRef, sanitizedData, { merge: true });
        } catch (error) {
            console.error('Error saving traffic data:', error);
            throw error;
        }
    },

    /**
     * Merges new CSV data with existing data.
     * - source: "Lifetime" CSV logic implies new data IS the source of truth for totals.
     * - groups: MUST be preserved from existing data.
     * - snapshots: MUST be preserved.
     */
    mergeTrafficData(
        currentData: TrafficData | null,
        newSources: TrafficSource[],
        newTotalRow?: TrafficSource
    ): TrafficData {
        const now = Date.now();
        console.log('[TrafficService] mergeTrafficData:', {
            newSourcesLen: newSources.length,
            currentSnapshotsLen: currentData?.snapshots?.length
        });

        const merged: TrafficData = {
            ...currentData,
            lastUpdated: now,
            sources: newSources,
            totalRow: newTotalRow || currentData?.totalRow,
            snapshots: currentData?.snapshots || []
        } as TrafficData;

        return merged;
    },

    /**
     * Sanitizes data for Firestore by removing undefined values.
     */
    sanitizeData(data: any): any {
        const json = JSON.parse(JSON.stringify(data));
        // Remove undefined/null if they still exist for some reason
        const clean = (obj: any) => {
            Object.keys(obj).forEach(key => {
                if (obj[key] === undefined) {
                    delete obj[key];
                } else if (obj[key] !== null && typeof obj[key] === 'object') {
                    clean(obj[key]);
                }
            });
            return obj;
        };
        return clean(json);
    },

    /**
     * Create a version snapshot with HYBRID STORAGE.
     * 
     * HYBRID APPROACH:
     * 1. Upload CSV file to Cloud Storage
     * 2. Calculate summary statistics
     * 3. Save metadata + summary to Firestore (NOT full sources)
     * 
     * Benefits:
     * - No Firestore 1MB document limit
     * - Faster queries (metadata only)
     * - Cheaper storage costs
     * - Original CSV preserved
     * 
     * @param userId - User ID
     * @param channelId - Channel ID
     * @param videoId - Video ID
     * @param version - Packaging version number
     * @param sources - Traffic sources from CSV
     * @param totalRow - Total row from CSV
     * @param csvFile - Original CSV file to upload to Storage
     */
    async createVersionSnapshot(
        userId: string,
        channelId: string,
        videoId: string,
        version: number,
        sources: TrafficSource[],
        totalRow?: TrafficSource,
        csvFile?: File
    ): Promise<string> {
        const currentData = await this.fetchTrafficData(userId, channelId, videoId);
        const timestamp = Date.now();
        const snapshotId = generateSnapshotId(timestamp, version);

        // Calculate summary statistics
        const totalViews = sources.reduce((sum, s) => sum + (s.views || 0), 0);
        const totalWatchTime = sources.reduce((sum, s) => sum + (s.watchTimeHours || 0), 0);
        const topSource = sources.reduce((max, s) =>
            (s.views || 0) > (max.views || 0) ? s : max,
            sources[0]
        );

        let storagePath: string | undefined;

        // Upload CSV to Cloud Storage if file provided
        if (csvFile) {
            try {
                const uploadResult = await uploadCsvSnapshot(
                    userId,
                    channelId,
                    videoId,
                    snapshotId,
                    csvFile
                );
                storagePath = uploadResult.storagePath;
            } catch (error) {
                console.error('Failed to upload CSV to Storage:', error);
                // Continue without storage path (will save sources to Firestore as fallback)
            }
        }

        // Create snapshot metadata
        const snapshot: TrafficSnapshot = {
            id: snapshotId,
            version,
            timestamp,
            createdAt: new Date().toISOString(),

            // Hybrid storage fields
            storagePath,
            summary: {
                totalViews,
                totalWatchTime,
                sourcesCount: sources.length,
                topSource: topSource?.sourceTitle
            },

            // Legacy: Only include sources if CSV upload failed
            ...(storagePath ? {} : { sources, totalRow })
        };

        const updated: TrafficData = {
            lastUpdated: Date.now(),
            sources: sources, // Update sources to latest
            groups: currentData?.groups || [],
            totalRow: totalRow || currentData?.totalRow, // Update totalRow
            snapshots: [...(currentData?.snapshots || []), snapshot]
        };

        await this.saveTrafficData(userId, channelId, videoId, updated);
        return snapshotId;
    },

    /**
     * Calculate traffic delta for a specific version.
     * Subtracts previous snapshot from current data to show only new traffic.
     */
    calculateVersionDelta(
        currentSources: TrafficSource[],
        version: number,
        snapshots: TrafficSnapshot[]
    ): TrafficSource[] {
        // Find snapshot for previous version
        const prevSnapshot = snapshots.find(s => s.version === version - 1);
        if (!prevSnapshot || !prevSnapshot.sources) return currentSources; // No previous data or data in Storage

        // Create map of previous data
        const prevData = new Map<string, { views: number, impressions: number, watchTime: number }>();
        prevSnapshot.sources.forEach(s => {
            if (s.videoId) {
                prevData.set(s.videoId, {
                    views: s.views || 0,
                    impressions: s.impressions || 0,
                    watchTime: s.watchTimeHours || 0
                });
            }
        });

        // Calculate delta for each source
        return currentSources
            .map(source => {
                if (!source.videoId) return source;

                const prev = prevData.get(source.videoId) || { views: 0, impressions: 0, watchTime: 0 };
                const viewsDelta = Math.max(0, source.views - prev.views);
                const impressionsDelta = Math.max(0, (source.impressions || 0) - prev.impressions);
                const watchTimeDelta = Math.max(0, (source.watchTimeHours || 0) - prev.watchTime);

                // Calculate new CTR based on deltas
                const ctrDelta = impressionsDelta > 0 ? (viewsDelta / impressionsDelta) * 100 : 0;

                return {
                    ...source,
                    views: viewsDelta,
                    impressions: impressionsDelta,
                    watchTimeHours: watchTimeDelta,
                    ctr: parseFloat(ctrDelta.toFixed(2))
                };
            })
            .filter(source => !source.videoId || source.views > 0);
    },

    /**
     * Get sources for a specific historical version from snapshot.
     * 
     * HYBRID STORAGE:
     * - If snapshot has storagePath: download CSV from Storage and parse
     * - If snapshot has sources: return directly (legacy)
     * 
     * @param version - Version number to get sources for
     * @param snapshots - Array of snapshots
     * @returns Traffic sources for the version
     */
    async getVersionSources(
        version: number,
        snapshots: TrafficSnapshot[]
    ): Promise<TrafficSource[]> {
        // Find ALL snapshots for this version and take the LAST one (latest)
        // Assuming snapshots are ordered chronologically ASC or handled by caller sorting
        const versionSnapshots = snapshots.filter(s => s.version === version);
        const snapshot = versionSnapshots[versionSnapshots.length - 1];

        if (!snapshot) return [];

        // Legacy: sources stored in Firestore
        if (snapshot.sources) {
            return snapshot.sources;
        }

        // Hybrid: sources in Cloud Storage
        if (snapshot.storagePath) {
            try {
                const { downloadCsvSnapshot } = await import('./storageService');
                const { parseTrafficCsv } = await import('../../pages/Details/tabs/Traffic/utils/csvParser');

                const blob = await downloadCsvSnapshot(snapshot.storagePath);
                const file = new File([blob], 'snapshot.csv', { type: 'text/csv' });
                const { sources } = await parseTrafficCsv(file);

                return sources;
            } catch (error) {
                console.error('Failed to load snapshot from Storage:', error);
                return [];
            }
        }

        return [];
    },

    /**
     * Delete a traffic snapshot.
     * Removes snapshot from Firestore and deletes CSV file from Cloud Storage.
     * 
     * @param userId - User ID
     * @param channelId - Channel ID
     * @param videoId - Video ID
     * @param snapshotId - Snapshot ID to delete
     */
    /**
     * Delete a traffic snapshot.
     * Implements "Undo" strategy:
     * - If deleting the LATEST snapshot -> Revert main data to previous snapshot state.
     * - If deleting HISTORICAL snapshot -> Just remove record (Data stays merged/current).
     * 
     * @param userId - User ID
     * @param channelId - Channel ID
     * @param videoId - Video ID
     * @param snapshotId - Snapshot ID to delete
     */
    async deleteSnapshot(
        userId: string,
        channelId: string,
        videoId: string,
        snapshotId: string
    ): Promise<void> {
        // 1. Fetch current data
        const currentData = await this.fetchTrafficData(userId, channelId, videoId);
        if (!currentData) return;

        // 2. Find snapshot to delete
        const snapshotIndex = currentData.snapshots.findIndex(s => s.id === snapshotId);
        if (snapshotIndex === -1) return;

        const snapshot = currentData.snapshots[snapshotIndex];
        const isLatest = snapshotIndex === currentData.snapshots.length - 1;

        // 3. Delete CSV from Cloud Storage (if exists)
        if (snapshot.storagePath) {
            try {
                const { deleteCsvSnapshot } = await import('./storageService');
                await deleteCsvSnapshot(snapshot.storagePath);
            } catch (error) {
                console.error('Failed to delete CSV from Storage:', error);
                // Continue with Firestore deletion even if Storage deletion fails
            }
        }

        // 4. Prepare updated data
        let updated: TrafficData;

        if (isLatest) {
            // UNDO STRATEGY: Revert to previous snapshot state
            const previousSnapshot = currentData.snapshots[snapshotIndex - 1];

            if (previousSnapshot) {
                // Revert to previous snapshot's data
                // We need to fetch the sources for the previous snapshot
                const prevSources = await this.getVersionSources(previousSnapshot.version, currentData.snapshots);

                updated = {
                    ...currentData,
                    lastUpdated: previousSnapshot.timestamp,
                    sources: prevSources,
                    totalRow: previousSnapshot.totalRow, // Start with this, effectively
                    snapshots: currentData.snapshots.filter(s => s.id !== snapshotId)
                };
            } else {
                // No previous snapshot -> Reset to empty state
                updated = {
                    ...currentData,
                    lastUpdated: Date.now(),
                    sources: [],
                    totalRow: undefined,
                    snapshots: []
                };
            }
        } else {
            // PRUNING STRATEGY: Just remove the record, keep current data
            // (Note: UI should prevent this case based on "Undo Only" policy, but backend handles it safe)
            updated = {
                ...currentData,
                snapshots: currentData.snapshots.filter(s => s.id !== snapshotId)
            };
        }

        await this.saveTrafficData(userId, channelId, videoId, updated);
    },

    /**
     * Clears the current traffic data (sources and totalRow) for the video.
     * This is used when starting a new version to ensure a clean slate.
     * Preserves snapshots history.
     */
    async clearCurrentTrafficData(
        userId: string,
        channelId: string,
        videoId: string
    ): Promise<void> {
        console.log('[TrafficService] clearCurrentTrafficData called');
        const currentData = await this.fetchTrafficData(userId, channelId, videoId);

        const path = `users/${userId}/channels/${channelId}/videos/${videoId}/traffic/main`;
        const docRef = doc(db, path);
        try {
            await setDoc(docRef, {
                lastUpdated: Date.now(),
                sources: [],
                totalRow: deleteField(),
                snapshots: currentData?.snapshots || [],
                groups: currentData?.groups || []
            }, { merge: true });
            console.log('[TrafficService] Data cleared successfully');
        } catch (e) {
            console.error('[TrafficService] Failed to clear data:', e);
            throw e;
        }
    }
};
