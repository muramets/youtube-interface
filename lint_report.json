[{"filePath":"/Users/muramets/Documents/youtube-interface/check_exports.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/dev-dist/registerSW.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/dev-dist/sw.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/dev-dist/workbox-ca84f546.js","messages":[{"ruleId":"@typescript-eslint/ban-types","message":"Definition for rule '@typescript-eslint/ban-types' was not found.","line":52,"column":7,"endLine":52,"endColumn":63,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/ban-types","message":"Definition for rule '@typescript-eslint/ban-types' was not found.","line":419,"column":5,"endLine":419,"endColumn":61,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-member-access","message":"Definition for rule '@typescript-eslint/no-unsafe-member-access' was not found.","line":752,"column":11,"endLine":752,"endColumn":81,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-assignment","message":"Definition for rule '@typescript-eslint/no-unsafe-assignment' was not found.","line":754,"column":13,"endLine":754,"endColumn":80,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-assignment","message":"Definition for rule '@typescript-eslint/no-unsafe-assignment' was not found.","line":948,"column":11,"endLine":948,"endColumn":78,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-assignment","message":"Definition for rule '@typescript-eslint/no-unsafe-assignment' was not found.","line":964,"column":13,"endLine":964,"endColumn":80,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/ban-types","message":"Definition for rule '@typescript-eslint/ban-types' was not found.","line":1257,"column":5,"endLine":1257,"endColumn":61,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/ban-types","message":"Definition for rule '@typescript-eslint/ban-types' was not found.","line":1275,"column":5,"endLine":1275,"endColumn":61,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-return","message":"Definition for rule '@typescript-eslint/no-unsafe-return' was not found.","line":3951,"column":9,"endLine":3951,"endColumn":72,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-return","message":"Definition for rule '@typescript-eslint/no-unsafe-return' was not found.","line":3998,"column":9,"endLine":3998,"endColumn":72,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"define(['exports'], (function (exports) { 'use strict';\n\n    // @ts-ignore\n    try {\n      self['workbox:core:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const logger = (() => {\n      // Don't overwrite this value if it's already set.\n      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n      if (!('__WB_DISABLE_DEV_LOGS' in globalThis)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n      }\n      let inGroup = false;\n      const methodToColorMap = {\n        debug: `#7f8c8d`,\n        log: `#2ecc71`,\n        warn: `#f39c12`,\n        error: `#c0392b`,\n        groupCollapsed: `#3498db`,\n        groupEnd: null // No colored prefix on groupEnd\n      };\n      const print = function (method, args) {\n        if (self.__WB_DISABLE_DEV_LOGS) {\n          return;\n        }\n        if (method === 'groupCollapsed') {\n          // Safari doesn't print all console.groupCollapsed() arguments:\n          // https://bugs.webkit.org/show_bug.cgi?id=182754\n          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n            console[method](...args);\n            return;\n          }\n        }\n        const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`];\n        // When in a group, the workbox prefix is not displayed.\n        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n        console[method](...logPrefix, ...args);\n        if (method === 'groupCollapsed') {\n          inGroup = true;\n        }\n        if (method === 'groupEnd') {\n          inGroup = false;\n        }\n      };\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      const api = {};\n      const loggerMethods = Object.keys(methodToColorMap);\n      for (const key of loggerMethods) {\n        const method = key;\n        api[method] = (...args) => {\n          print(method, args);\n        };\n      }\n      return api;\n    })();\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const messages$1 = {\n      'invalid-value': ({\n        paramName,\n        validValueDescription,\n        value\n      }) => {\n        if (!paramName || !validValueDescription) {\n          throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n      },\n      'not-an-array': ({\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        if (!moduleName || !className || !funcName || !paramName) {\n          throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n      },\n      'incorrect-type': ({\n        expectedType,\n        paramName,\n        moduleName,\n        className,\n        funcName\n      }) => {\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n      },\n      'incorrect-class': ({\n        expectedClassName,\n        paramName,\n        moduleName,\n        className,\n        funcName,\n        isReturnValueProblem\n      }) => {\n        if (!expectedClassName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        if (isReturnValueProblem) {\n          return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n      },\n      'missing-a-method': ({\n        expectedMethod,\n        paramName,\n        moduleName,\n        className,\n        funcName\n      }) => {\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n          throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n      },\n      'add-to-cache-list-unexpected-type': ({\n        entry\n      }) => {\n        return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;\n      },\n      'add-to-cache-list-conflicting-entries': ({\n        firstEntry,\n        secondEntry\n      }) => {\n        if (!firstEntry || !secondEntry) {\n          throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;\n      },\n      'plugin-error-request-will-fetch': ({\n        thrownErrorMessage\n      }) => {\n        if (!thrownErrorMessage) {\n          throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n        }\n        return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;\n      },\n      'invalid-cache-name': ({\n        cacheNameId,\n        value\n      }) => {\n        if (!cacheNameId) {\n          throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;\n      },\n      'unregister-route-but-not-found-with-method': ({\n        method\n      }) => {\n        if (!method) {\n          throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;\n      },\n      'unregister-route-route-not-registered': () => {\n        return `The route you're trying to unregister was not previously ` + `registered.`;\n      },\n      'queue-replay-failed': ({\n        name\n      }) => {\n        return `Replaying the background sync queue '${name}' failed.`;\n      },\n      'duplicate-queue-name': ({\n        name\n      }) => {\n        return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;\n      },\n      'expired-test-without-max-age': ({\n        methodName,\n        paramName\n      }) => {\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n      },\n      'unsupported-route-type': ({\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;\n      },\n      'not-array-of-class': ({\n        value,\n        expectedClass,\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;\n      },\n      'max-entries-or-age-required': ({\n        moduleName,\n        className,\n        funcName\n      }) => {\n        return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;\n      },\n      'statuses-or-headers-required': ({\n        moduleName,\n        className,\n        funcName\n      }) => {\n        return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;\n      },\n      'invalid-string': ({\n        moduleName,\n        funcName,\n        paramName\n      }) => {\n        if (!paramName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;\n      },\n      'channel-name-required': () => {\n        return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;\n      },\n      'invalid-responses-are-same-args': () => {\n        return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;\n      },\n      'expire-custom-caches-only': () => {\n        return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;\n      },\n      'unit-must-be-bytes': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was \"${normalizedRangeHeader}\"`;\n      },\n      'single-range-only': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n      },\n      'invalid-range-values': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n      },\n      'no-range-header': () => {\n        return `No Range header was found in the Request provided.`;\n      },\n      'range-not-satisfiable': ({\n        size,\n        start,\n        end\n      }) => {\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n      },\n      'attempt-to-cache-non-get-request': ({\n        url,\n        method\n      }) => {\n        return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;\n      },\n      'cache-put-with-no-response': ({\n        url\n      }) => {\n        return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;\n      },\n      'no-response': ({\n        url,\n        error\n      }) => {\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n          message += ` The underlying error is ${error}.`;\n        }\n        return message;\n      },\n      'bad-precaching-response': ({\n        url,\n        status\n      }) => {\n        return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);\n      },\n      'non-precached-url': ({\n        url\n      }) => {\n        return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;\n      },\n      'add-to-cache-list-conflicting-integrities': ({\n        url\n      }) => {\n        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;\n      },\n      'missing-precache-entry': ({\n        cacheName,\n        url\n      }) => {\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n      },\n      'cross-origin-copy-response': ({\n        origin\n      }) => {\n        return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;\n      },\n      'opaque-streams-source': ({\n        type\n      }) => {\n        const message = `One of the workbox-streams sources resulted in an ` + `'${type}' response.`;\n        if (type === 'opaqueredirect') {\n          return `${message} Please do not use a navigation request that results ` + `in a redirect as a source.`;\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const generatorFunction = (code, details = {}) => {\n      const message = messages$1[code];\n      if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n      }\n      return message(details);\n    };\n    const messageGenerator = generatorFunction;\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Workbox errors should be thrown with this class.\n     * This allows use to ensure the type easily in tests,\n     * helps developers identify errors from workbox\n     * easily and allows use to optimise error\n     * messages correctly.\n     *\n     * @private\n     */\n    class WorkboxError extends Error {\n      /**\n       *\n       * @param {string} errorCode The error code that\n       * identifies this particular error.\n       * @param {Object=} details Any relevant arguments\n       * that will help developers identify issues should\n       * be added as a key on the context object.\n       */\n      constructor(errorCode, details) {\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /*\n     * This method throws if the supplied value is not an array.\n     * The destructed values are required to produce a meaningful error for users.\n     * The destructed and restructured object is so it's clear what is\n     * needed.\n     */\n    const isArray = (value, details) => {\n      if (!Array.isArray(value)) {\n        throw new WorkboxError('not-an-array', details);\n      }\n    };\n    const hasMethod = (object, expectedMethod, details) => {\n      const type = typeof object[expectedMethod];\n      if (type !== 'function') {\n        details['expectedMethod'] = expectedMethod;\n        throw new WorkboxError('missing-a-method', details);\n      }\n    };\n    const isType = (object, expectedType, details) => {\n      if (typeof object !== expectedType) {\n        details['expectedType'] = expectedType;\n        throw new WorkboxError('incorrect-type', details);\n      }\n    };\n    const isInstance = (object,\n    // Need the general type to do the check later.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    expectedClass, details) => {\n      if (!(object instanceof expectedClass)) {\n        details['expectedClassName'] = expectedClass.name;\n        throw new WorkboxError('incorrect-class', details);\n      }\n    };\n    const isOneOf = (value, validValues, details) => {\n      if (!validValues.includes(value)) {\n        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new WorkboxError('invalid-value', details);\n      }\n    };\n    const isArrayOfClass = (value,\n    // Need general type to do check later.\n    expectedClass,\n     \n    details) => {\n      const error = new WorkboxError('not-array-of-class', details);\n      if (!Array.isArray(value)) {\n        throw error;\n      }\n      for (const item of value) {\n        if (!(item instanceof expectedClass)) {\n          throw error;\n        }\n      }\n    };\n    const finalAssertExports = {\n      hasMethod,\n      isArray,\n      isInstance,\n      isOneOf,\n      isType,\n      isArrayOfClass\n    };\n\n    // @ts-ignore\n    try {\n      self['workbox:routing:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The default HTTP method, 'GET', used when there's no specific method\n     * configured for a route.\n     *\n     * @type {string}\n     *\n     * @private\n     */\n    const defaultMethod = 'GET';\n    /**\n     * The list of valid HTTP methods associated with requests that could be routed.\n     *\n     * @type {Array<string>}\n     *\n     * @private\n     */\n    const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {function()|Object} handler Either a function, or an object with a\n     * 'handle' method.\n     * @return {Object} An object with a handle method.\n     *\n     * @private\n     */\n    const normalizeHandler = handler => {\n      if (handler && typeof handler === 'object') {\n        {\n          finalAssertExports.hasMethod(handler, 'handle', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'handler'\n          });\n        }\n        return handler;\n      } else {\n        {\n          finalAssertExports.isType(handler, 'function', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'handler'\n          });\n        }\n        return {\n          handle: handler\n        };\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n     * The \"match\" callback determine if a route should be used to \"handle\" a\n     * request by returning a non-falsy value if it can. The \"handler\" callback\n     * is called when there is a match and should return a Promise that resolves\n     * to a `Response`.\n     *\n     * @memberof workbox-routing\n     */\n    class Route {\n      /**\n       * Constructor for Route class.\n       *\n       * @param {workbox-routing~matchCallback} match\n       * A callback function that determines whether the route matches a given\n       * `fetch` event by returning a non-falsy value.\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resolving to a Response.\n       * @param {string} [method='GET'] The HTTP method to match the Route\n       * against.\n       */\n      constructor(match, handler, method = defaultMethod) {\n        {\n          finalAssertExports.isType(match, 'function', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'match'\n          });\n          if (method) {\n            finalAssertExports.isOneOf(method, validMethods, {\n              paramName: 'method'\n            });\n          }\n        }\n        // These values are referenced directly by Router so cannot be\n        // altered by minificaton.\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n      }\n      /**\n       *\n       * @param {workbox-routing-handlerCallback} handler A callback\n       * function that returns a Promise resolving to a Response\n       */\n      setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * RegExpRoute makes it easy to create a regular expression based\n     * {@link workbox-routing.Route}.\n     *\n     * For same-origin requests the RegExp only needs to match part of the URL. For\n     * requests against third-party servers, you must define a RegExp that matches\n     * the start of the URL.\n     *\n     * @memberof workbox-routing\n     * @extends workbox-routing.Route\n     */\n    class RegExpRoute extends Route {\n      /**\n       * If the regular expression contains\n       * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n       * the captured values will be passed to the\n       * {@link workbox-routing~handlerCallback} `params`\n       * argument.\n       *\n       * @param {RegExp} regExp The regular expression to match against URLs.\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {string} [method='GET'] The HTTP method to match the Route\n       * against.\n       */\n      constructor(regExp, handler, method) {\n        {\n          finalAssertExports.isInstance(regExp, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'RegExpRoute',\n            funcName: 'constructor',\n            paramName: 'pattern'\n          });\n        }\n        const match = ({\n          url\n        }) => {\n          const result = regExp.exec(url.href);\n          // Return immediately if there's no match.\n          if (!result) {\n            return;\n          }\n          // Require that the match start at the first character in the URL string\n          // if it's a cross-origin request.\n          // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n          // behind this behavior.\n          if (url.origin !== location.origin && result.index !== 0) {\n            {\n              logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n            }\n            return;\n          }\n          // If the route matches, but there aren't any capture groups defined, then\n          // this will return [], which is truthy and therefore sufficient to\n          // indicate a match.\n          // If there are capture groups, then it will return their values.\n          return result.slice(1);\n        };\n        super(match, handler, method);\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const getFriendlyURL = url => {\n      const urlObj = new URL(String(url), location.href);\n      // See https://github.com/GoogleChrome/workbox/issues/2323\n      // We want to include everything, except for the origin if it's same-origin.\n      return urlObj.href.replace(new RegExp(`^${location.origin}`), '');\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Router can be used to process a `FetchEvent` using one or more\n     * {@link workbox-routing.Route}, responding with a `Response` if\n     * a matching route exists.\n     *\n     * If no route matches a given a request, the Router will use a \"default\"\n     * handler if one is defined.\n     *\n     * Should the matching Route throw an error, the Router will use a \"catch\"\n     * handler if one is defined to gracefully deal with issues and respond with a\n     * Request.\n     *\n     * If a request matches multiple routes, the **earliest** registered route will\n     * be used to respond to the request.\n     *\n     * @memberof workbox-routing\n     */\n    class Router {\n      /**\n       * Initializes a new Router.\n       */\n      constructor() {\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n      }\n      /**\n       * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n       * method name ('GET', etc.) to an array of all the corresponding `Route`\n       * instances that are registered.\n       */\n      get routes() {\n        return this._routes;\n      }\n      /**\n       * Adds a fetch event listener to respond to events when a route matches\n       * the event's request.\n       */\n      addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', event => {\n          const {\n            request\n          } = event;\n          const responsePromise = this.handleRequest({\n            request,\n            event\n          });\n          if (responsePromise) {\n            event.respondWith(responsePromise);\n          }\n        });\n      }\n      /**\n       * Adds a message event listener for URLs to cache from the window.\n       * This is useful to cache resources loaded on the page prior to when the\n       * service worker started controlling it.\n       *\n       * The format of the message data sent from the window should be as follows.\n       * Where the `urlsToCache` array may consist of URL strings or an array of\n       * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n       *\n       * ```\n       * {\n       *   type: 'CACHE_URLS',\n       *   payload: {\n       *     urlsToCache: [\n       *       './script1.js',\n       *       './script2.js',\n       *       ['./script3.js', {mode: 'no-cors'}],\n       *     ],\n       *   },\n       * }\n       * ```\n       */\n      addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', event => {\n          // event.data is type 'any'\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          if (event.data && event.data.type === 'CACHE_URLS') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const {\n              payload\n            } = event.data;\n            {\n              logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n            }\n            const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n              if (typeof entry === 'string') {\n                entry = [entry];\n              }\n              const request = new Request(...entry);\n              return this.handleRequest({\n                request,\n                event\n              });\n              // TODO(philipwalton): TypeScript errors without this typecast for\n              // some reason (probably a bug). The real type here should work but\n              // doesn't: `Array<Promise<Response> | undefined>`.\n            })); // TypeScript\n            event.waitUntil(requestPromises);\n            // If a MessageChannel was used, reply to the message on success.\n            if (event.ports && event.ports[0]) {\n              void requestPromises.then(() => event.ports[0].postMessage(true));\n            }\n          }\n        });\n      }\n      /**\n       * Apply the routing rules to a FetchEvent object to get a Response from an\n       * appropriate Route's handler.\n       *\n       * @param {Object} options\n       * @param {Request} options.request The request to handle.\n       * @param {ExtendableEvent} options.event The event that triggered the\n       *     request.\n       * @return {Promise<Response>|undefined} A promise is returned if a\n       *     registered route can handle the request. If there is no matching\n       *     route and there's no `defaultHandler`, `undefined` is returned.\n       */\n      handleRequest({\n        request,\n        event\n      }) {\n        {\n          finalAssertExports.isInstance(request, Request, {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'handleRequest',\n            paramName: 'options.request'\n          });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n          {\n            logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n          }\n          return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const {\n          params,\n          route\n        } = this.findMatchingRoute({\n          event,\n          request,\n          sameOrigin,\n          url\n        });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        {\n          if (handler) {\n            debugMessages.push([`Found a route to handle this request:`, route]);\n            if (params) {\n              debugMessages.push([`Passing the following params to the route's handler:`, params]);\n            }\n          }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n          {\n            debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);\n          }\n          handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n          {\n            // No handler so Workbox will do nothing. If logs is set of debug\n            // i.e. verbose, we should print out this information.\n            logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n          }\n          return;\n        }\n        {\n          // We have a handler, meaning Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n          debugMessages.forEach(msg => {\n            if (Array.isArray(msg)) {\n              logger.log(...msg);\n            } else {\n              logger.log(msg);\n            }\n          });\n          logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n          responsePromise = handler.handle({\n            url,\n            request,\n            event,\n            params\n          });\n        } catch (err) {\n          responsePromise = Promise.reject(err);\n        }\n        // Get route's catch handler, if it exists\n        const catchHandler = route && route.catchHandler;\n        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n          responsePromise = responsePromise.catch(async err => {\n            // If there's a route catch handler, process that first\n            if (catchHandler) {\n              {\n                // Still include URL here as it will be async from the console group\n                // and may not make sense without the URL\n                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n                logger.error(`Error thrown by:`, route);\n                logger.error(err);\n                logger.groupEnd();\n              }\n              try {\n                return await catchHandler.handle({\n                  url,\n                  request,\n                  event,\n                  params\n                });\n              } catch (catchErr) {\n                if (catchErr instanceof Error) {\n                  err = catchErr;\n                }\n              }\n            }\n            if (this._catchHandler) {\n              {\n                // Still include URL here as it will be async from the console group\n                // and may not make sense without the URL\n                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n                logger.error(`Error thrown by:`, route);\n                logger.error(err);\n                logger.groupEnd();\n              }\n              return this._catchHandler.handle({\n                url,\n                request,\n                event\n              });\n            }\n            throw err;\n          });\n        }\n        return responsePromise;\n      }\n      /**\n       * Checks a request and URL (and optionally an event) against the list of\n       * registered routes, and if there's a match, returns the corresponding\n       * route along with any params generated by the match.\n       *\n       * @param {Object} options\n       * @param {URL} options.url\n       * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n       *     against the current origin.\n       * @param {Request} options.request The request to match.\n       * @param {Event} options.event The corresponding event.\n       * @return {Object} An object with `route` and `params` properties.\n       *     They are populated if a matching route was found or `undefined`\n       *     otherwise.\n       */\n      findMatchingRoute({\n        url,\n        sameOrigin,\n        request,\n        event\n      }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n          let params;\n          // route.match returns type any, not possible to change right now.\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          const matchResult = route.match({\n            url,\n            sameOrigin,\n            request,\n            event\n          });\n          if (matchResult) {\n            {\n              // Warn developers that using an async matchCallback is almost always\n              // not the right thing to do.\n              if (matchResult instanceof Promise) {\n                logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);\n              }\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2079\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            params = matchResult;\n            if (Array.isArray(params) && params.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              params = undefined;\n            } else if (matchResult.constructor === Object &&\n             \n            Object.keys(matchResult).length === 0) {\n              // Instead of passing an empty object in as params, use undefined.\n              params = undefined;\n            } else if (typeof matchResult === 'boolean') {\n              // For the boolean value true (rather than just something truth-y),\n              // don't set params.\n              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n              params = undefined;\n            }\n            // Return early if have a match.\n            return {\n              route,\n              params\n            };\n          }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n      }\n      /**\n       * Define a default `handler` that's called when no routes explicitly\n       * match the incoming request.\n       *\n       * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n       *\n       * Without a default handler, unmatched requests will go against the\n       * network as if there were no service worker present.\n       *\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {string} [method='GET'] The HTTP method to associate with this\n       * default handler. Each method has its own default.\n       */\n      setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n      }\n      /**\n       * If a Route throws an error while handling a request, this `handler`\n       * will be called and given a chance to provide a response.\n       *\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       */\n      setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n      }\n      /**\n       * Registers a route with the router.\n       *\n       * @param {workbox-routing.Route} route The route to register.\n       */\n      registerRoute(route) {\n        {\n          finalAssertExports.isType(route, 'object', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.hasMethod(route, 'match', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.isType(route.handler, 'object', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.hasMethod(route.handler, 'handle', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route.handler'\n          });\n          finalAssertExports.isType(route.method, 'string', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route.method'\n          });\n        }\n        if (!this._routes.has(route.method)) {\n          this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n      }\n      /**\n       * Unregisters a route with the router.\n       *\n       * @param {workbox-routing.Route} route The route to unregister.\n       */\n      unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n          throw new WorkboxError('unregister-route-but-not-found-with-method', {\n            method: route.method\n          });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n          this._routes.get(route.method).splice(routeIndex, 1);\n        } else {\n          throw new WorkboxError('unregister-route-route-not-registered');\n        }\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let defaultRouter;\n    /**\n     * Creates a new, singleton Router instance if one does not exist. If one\n     * does already exist, that instance is returned.\n     *\n     * @private\n     * @return {Router}\n     */\n    const getOrCreateDefaultRouter = () => {\n      if (!defaultRouter) {\n        defaultRouter = new Router();\n        // The helpers that use the default Router assume these listeners exist.\n        defaultRouter.addFetchListener();\n        defaultRouter.addCacheListener();\n      }\n      return defaultRouter;\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Easily register a RegExp, string, or function with a caching\n     * strategy to a singleton Router instance.\n     *\n     * This method will generate a Route for you if needed and\n     * call {@link workbox-routing.Router#registerRoute}.\n     *\n     * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture\n     * If the capture param is a `Route`, all other arguments will be ignored.\n     * @param {workbox-routing~handlerCallback} [handler] A callback\n     * function that returns a Promise resulting in a Response. This parameter\n     * is required if `capture` is not a `Route` object.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     * @return {workbox-routing.Route} The generated `Route`.\n     *\n     * @memberof workbox-routing\n     */\n    function registerRoute(capture, handler, method) {\n      let route;\n      if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location.href);\n        {\n          if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n            throw new WorkboxError('invalid-string', {\n              moduleName: 'workbox-routing',\n              funcName: 'registerRoute',\n              paramName: 'capture'\n            });\n          }\n          // We want to check if Express-style wildcards are in the pathname only.\n          // TODO: Remove this log message in v4.\n          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture;\n          // See https://github.com/pillarjs/path-to-regexp#parameters\n          const wildcards = '[*:?+]';\n          if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n            logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n          }\n        }\n        const matchCallback = ({\n          url\n        }) => {\n          {\n            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n              logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n            }\n          }\n          return url.href === captureUrl.href;\n        };\n        // If `capture` is a string then `handler` and `method` must be present.\n        route = new Route(matchCallback, handler, method);\n      } else if (capture instanceof RegExp) {\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\n        route = new RegExpRoute(capture, handler, method);\n      } else if (typeof capture === 'function') {\n        // If `capture` is a function then `handler` and `method` must be present.\n        route = new Route(capture, handler, method);\n      } else if (capture instanceof Route) {\n        route = capture;\n      } else {\n        throw new WorkboxError('unsupported-route-type', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      }\n      const defaultRouter = getOrCreateDefaultRouter();\n      defaultRouter.registerRoute(route);\n      return route;\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const _cacheNameDetails = {\n      googleAnalytics: 'googleAnalytics',\n      precache: 'precache-v2',\n      prefix: 'workbox',\n      runtime: 'runtime',\n      suffix: typeof registration !== 'undefined' ? registration.scope : ''\n    };\n    const _createCacheName = cacheName => {\n      return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');\n    };\n    const eachCacheNameDetail = fn => {\n      for (const key of Object.keys(_cacheNameDetails)) {\n        fn(key);\n      }\n    };\n    const cacheNames = {\n      updateDetails: details => {\n        eachCacheNameDetail(key => {\n          if (typeof details[key] === 'string') {\n            _cacheNameDetails[key] = details[key];\n          }\n        });\n      },\n      getGoogleAnalyticsName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n      },\n      getPrecacheName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n      },\n      getPrefix: () => {\n        return _cacheNameDetails.prefix;\n      },\n      getRuntimeName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n      },\n      getSuffix: () => {\n        return _cacheNameDetails.suffix;\n      }\n    };\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A helper function that prevents a promise from being flagged as unused.\n     *\n     * @private\n     **/\n    function dontWaitFor(promise) {\n      // Effective no-op.\n      void promise.then(() => {});\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    // Callbacks to be executed whenever there's a quota error.\n    // Can't change Function type right now.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const quotaErrorCallbacks = new Set();\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds a function to the set of quotaErrorCallbacks that will be executed if\n     * there's a quota error.\n     *\n     * @param {Function} callback\n     * @memberof workbox-core\n     */\n    // Can't change Function type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    function registerQuotaErrorCallback(callback) {\n      {\n        finalAssertExports.isType(callback, 'function', {\n          moduleName: 'workbox-core',\n          funcName: 'register',\n          paramName: 'callback'\n        });\n      }\n      quotaErrorCallbacks.add(callback);\n      {\n        logger.log('Registered a callback to respond to quota errors.', callback);\n      }\n    }\n\n    function _extends() {\n      return _extends = Object.assign ? Object.assign.bind() : function (n) {\n        for (var e = 1; e < arguments.length; e++) {\n          var t = arguments[e];\n          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n      }, _extends.apply(null, arguments);\n    }\n\n    const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n    let idbProxyableTypes;\n    let cursorAdvanceMethods;\n    // This is a function to prevent it throwing up in node environments.\n    function getIdbProxyableTypes() {\n      return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n    }\n    // This is a function to prevent it throwing up in node environments.\n    function getCursorAdvanceMethods() {\n      return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n    }\n    const cursorRequestMap = new WeakMap();\n    const transactionDoneMap = new WeakMap();\n    const transactionStoreNamesMap = new WeakMap();\n    const transformCache = new WeakMap();\n    const reverseTransformCache = new WeakMap();\n    function promisifyRequest(request) {\n      const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n          request.removeEventListener('success', success);\n          request.removeEventListener('error', error);\n        };\n        const success = () => {\n          resolve(wrap(request.result));\n          unlisten();\n        };\n        const error = () => {\n          reject(request.error);\n          unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n      });\n      promise.then(value => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n          cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n      }).catch(() => {});\n      // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n      // is because we create many promises from a single IDBRequest.\n      reverseTransformCache.set(promise, request);\n      return promise;\n    }\n    function cacheDonePromiseForTransaction(tx) {\n      // Early bail if we've already created a done promise for this transaction.\n      if (transactionDoneMap.has(tx)) return;\n      const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n          tx.removeEventListener('complete', complete);\n          tx.removeEventListener('error', error);\n          tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n          resolve();\n          unlisten();\n        };\n        const error = () => {\n          reject(tx.error || new DOMException('AbortError', 'AbortError'));\n          unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n      });\n      // Cache it for later retrieval.\n      transactionDoneMap.set(tx, done);\n    }\n    let idbProxyTraps = {\n      get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n          // Special handling for transaction.done.\n          if (prop === 'done') return transactionDoneMap.get(target);\n          // Polyfill for objectStoreNames because of Edge.\n          if (prop === 'objectStoreNames') {\n            return target.objectStoreNames || transactionStoreNamesMap.get(target);\n          }\n          // Make tx.store return the only store in the transaction, or undefined if there are many.\n          if (prop === 'store') {\n            return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n          }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n      },\n      set(target, prop, value) {\n        target[prop] = value;\n        return true;\n      },\n      has(target, prop) {\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n          return true;\n        }\n        return prop in target;\n      }\n    };\n    function replaceTraps(callback) {\n      idbProxyTraps = callback(idbProxyTraps);\n    }\n    function wrapFunction(func) {\n      // Due to expected object equality (which is enforced by the caching in `wrap`), we\n      // only create one new func per func.\n      // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n      if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n          const tx = func.call(unwrap(this), storeNames, ...args);\n          transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n          return wrap(tx);\n        };\n      }\n      // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n      // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n      // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n      // with real promises, so each advance methods returns a new promise for the cursor object, or\n      // undefined if the end of the cursor has been reached.\n      if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n          // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n          // the original object.\n          func.apply(unwrap(this), args);\n          return wrap(cursorRequestMap.get(this));\n        };\n      }\n      return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n      };\n    }\n    function transformCachableValue(value) {\n      if (typeof value === 'function') return wrapFunction(value);\n      // This doesn't return, it just creates a 'done' promise for the transaction,\n      // which is later returned for transaction.done (see idbObjectHandler).\n      if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n      if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n      // Return the same value back if we're not going to transform it.\n      return value;\n    }\n    function wrap(value) {\n      // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n      // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n      if (value instanceof IDBRequest) return promisifyRequest(value);\n      // If we've already transformed this value before, reuse the transformed value.\n      // This is faster, but it also provides object equality.\n      if (transformCache.has(value)) return transformCache.get(value);\n      const newValue = transformCachableValue(value);\n      // Not all types are transformed.\n      // These may be primitive types, so they can't be WeakMap keys.\n      if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n      }\n      return newValue;\n    }\n    const unwrap = value => reverseTransformCache.get(value);\n\n    /**\n     * Open a database.\n     *\n     * @param name Name of the database.\n     * @param version Schema version.\n     * @param callbacks Additional callbacks.\n     */\n    function openDB(name, version, {\n      blocked,\n      upgrade,\n      blocking,\n      terminated\n    } = {}) {\n      const request = indexedDB.open(name, version);\n      const openPromise = wrap(request);\n      if (upgrade) {\n        request.addEventListener('upgradeneeded', event => {\n          upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n      }\n      if (blocked) {\n        request.addEventListener('blocked', event => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n      }\n      openPromise.then(db => {\n        if (terminated) db.addEventListener('close', () => terminated());\n        if (blocking) {\n          db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));\n        }\n      }).catch(() => {});\n      return openPromise;\n    }\n    /**\n     * Delete a database.\n     *\n     * @param name Name of the database.\n     */\n    function deleteDB(name, {\n      blocked\n    } = {}) {\n      const request = indexedDB.deleteDatabase(name);\n      if (blocked) {\n        request.addEventListener('blocked', event => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n      }\n      return wrap(request).then(() => undefined);\n    }\n    const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\n    const writeMethods = ['put', 'add', 'delete', 'clear'];\n    const cachedMethods = new Map();\n    function getMethod(target, prop) {\n      if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n        return;\n      }\n      if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n      const targetFuncName = prop.replace(/FromIndex$/, '');\n      const useIndex = prop !== targetFuncName;\n      const isWrite = writeMethods.includes(targetFuncName);\n      if (\n      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n      }\n      const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex) target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n      };\n      cachedMethods.set(prop, method);\n      return method;\n    }\n    replaceTraps(oldTraps => _extends({}, oldTraps, {\n      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n    }));\n\n    // @ts-ignore\n    try {\n      self['workbox:expiration:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const DB_NAME = 'workbox-expiration';\n    const CACHE_OBJECT_STORE = 'cache-entries';\n    const normalizeURL = unNormalizedUrl => {\n      const url = new URL(unNormalizedUrl, location.href);\n      url.hash = '';\n      return url.href;\n    };\n    /**\n     * Returns the timestamp model.\n     *\n     * @private\n     */\n    class CacheTimestampsModel {\n      /**\n       *\n       * @param {string} cacheName\n       *\n       * @private\n       */\n      constructor(cacheName) {\n        this._db = null;\n        this._cacheName = cacheName;\n      }\n      /**\n       * Performs an upgrade of indexedDB.\n       *\n       * @param {IDBPDatabase<CacheDbSchema>} db\n       *\n       * @private\n       */\n      _upgradeDb(db) {\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n          keyPath: 'id'\n        });\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n        objStore.createIndex('cacheName', 'cacheName', {\n          unique: false\n        });\n        objStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n      }\n      /**\n       * Performs an upgrade of indexedDB and deletes deprecated DBs.\n       *\n       * @param {IDBPDatabase<CacheDbSchema>} db\n       *\n       * @private\n       */\n      _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n          void deleteDB(this._cacheName);\n        }\n      }\n      /**\n       * @param {string} url\n       * @param {number} timestamp\n       *\n       * @private\n       */\n      async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n          url,\n          timestamp,\n          cacheName: this._cacheName,\n          // Creating an ID from the URL and cache name won't be necessary once\n          // Edge switches to Chromium and all browsers we support work with\n          // array keyPaths.\n          id: this._getId(url)\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n          durability: 'relaxed'\n        });\n        await tx.store.put(entry);\n        await tx.done;\n      }\n      /**\n       * Returns the timestamp stored for a given URL.\n       *\n       * @param {string} url\n       * @return {number | undefined}\n       *\n       * @private\n       */\n      async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n      }\n      /**\n       * Iterates through all the entries in the object store (from newest to\n       * oldest) and removes entries once either `maxCount` is reached or the\n       * entry's timestamp is less than `minTimestamp`.\n       *\n       * @param {number} minTimestamp\n       * @param {number} maxCount\n       * @return {Array<string>}\n       *\n       * @private\n       */\n      async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db.transaction(CACHE_OBJECT_STORE).store.index('timestamp').openCursor(null, 'prev');\n        const entriesToDelete = [];\n        let entriesNotDeletedCount = 0;\n        while (cursor) {\n          const result = cursor.value;\n          // TODO(philipwalton): once we can use a multi-key index, we\n          // won't have to check `cacheName` here.\n          if (result.cacheName === this._cacheName) {\n            // Delete an entry if it's older than the max age or\n            // if we already have the max number allowed.\n            if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n              // TODO(philipwalton): we should be able to delete the\n              // entry right here, but doing so causes an iteration\n              // bug in Safari stable (fixed in TP). Instead we can\n              // store the keys of the entries to delete, and then\n              // delete the separate transactions.\n              // https://github.com/GoogleChrome/workbox/issues/1978\n              // cursor.delete();\n              // We only need to return the URL, not the whole entry.\n              entriesToDelete.push(cursor.value);\n            } else {\n              entriesNotDeletedCount++;\n            }\n          }\n          cursor = await cursor.continue();\n        }\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n        const urlsDeleted = [];\n        for (const entry of entriesToDelete) {\n          await db.delete(CACHE_OBJECT_STORE, entry.id);\n          urlsDeleted.push(entry.url);\n        }\n        return urlsDeleted;\n      }\n      /**\n       * Takes a URL and returns an ID that will be unique in the object store.\n       *\n       * @param {string} url\n       * @return {string}\n       *\n       * @private\n       */\n      _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n      }\n      /**\n       * Returns an open connection to the database.\n       *\n       * @private\n       */\n      async getDb() {\n        if (!this._db) {\n          this._db = await openDB(DB_NAME, 1, {\n            upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n          });\n        }\n        return this._db;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The `CacheExpiration` class allows you define an expiration and / or\n     * limit on the number of responses stored in a\n     * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n     *\n     * @memberof workbox-expiration\n     */\n    class CacheExpiration {\n      /**\n       * To construct a new CacheExpiration instance you must provide at least\n       * one of the `config` properties.\n       *\n       * @param {string} cacheName Name of the cache to apply restrictions to.\n       * @param {Object} config\n       * @param {number} [config.maxEntries] The maximum number of entries to cache.\n       * Entries used the least will be removed as the maximum is reached.\n       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n       * it's treated as stale and removed.\n       * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n       * that will be used when calling `delete()` on the cache.\n       */\n      constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        {\n          finalAssertExports.isType(cacheName, 'string', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor',\n            paramName: 'cacheName'\n          });\n          if (!(config.maxEntries || config.maxAgeSeconds)) {\n            throw new WorkboxError('max-entries-or-age-required', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor'\n            });\n          }\n          if (config.maxEntries) {\n            finalAssertExports.isType(config.maxEntries, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor',\n              paramName: 'config.maxEntries'\n            });\n          }\n          if (config.maxAgeSeconds) {\n            finalAssertExports.isType(config.maxAgeSeconds, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor',\n              paramName: 'config.maxAgeSeconds'\n            });\n          }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n      }\n      /**\n       * Expires entries for the given cache and given criteria.\n       */\n      async expireEntries() {\n        if (this._isRunning) {\n          this._rerunRequested = true;\n          return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n          await cache.delete(url, this._matchOptions);\n        }\n        {\n          if (urlsExpired.length > 0) {\n            logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n            logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n            urlsExpired.forEach(url => logger.log(`    ${url}`));\n            logger.groupEnd();\n          } else {\n            logger.debug(`Cache expiration ran and found no entries to remove.`);\n          }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n          this._rerunRequested = false;\n          dontWaitFor(this.expireEntries());\n        }\n      }\n      /**\n       * Update the timestamp for the given URL. This ensures the when\n       * removing entries based on maximum entries, most recently used\n       * is accurate or when expiring, the timestamp is up-to-date.\n       *\n       * @param {string} url\n       */\n      async updateTimestamp(url) {\n        {\n          finalAssertExports.isType(url, 'string', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'updateTimestamp',\n            paramName: 'url'\n          });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n      }\n      /**\n       * Can be used to check if a URL has expired or not before it's used.\n       *\n       * This requires a look up from IndexedDB, so can be slow.\n       *\n       * Note: This method will not remove the cached entry, call\n       * `expireEntries()` to remove indexedDB and Cache entries.\n       *\n       * @param {string} url\n       * @return {boolean}\n       */\n      async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n          {\n            throw new WorkboxError(`expired-test-without-max-age`, {\n              methodName: 'isURLExpired',\n              paramName: 'maxAgeSeconds'\n            });\n          }\n        } else {\n          const timestamp = await this._timestampModel.getTimestamp(url);\n          const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n          return timestamp !== undefined ? timestamp < expireOlderThan : true;\n        }\n      }\n      /**\n       * Removes the IndexedDB object store used to keep track of cache expiration\n       * metadata.\n       */\n      async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This plugin can be used in a `workbox-strategy` to regularly enforce a\n     * limit on the age and / or the number of cached requests.\n     *\n     * It can only be used with `workbox-strategy` instances that have a\n     * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n     * In other words, it can't be used to expire entries in strategy that uses the\n     * default runtime cache name.\n     *\n     * Whenever a cached response is used or updated, this plugin will look\n     * at the associated cache and remove any old or extra responses.\n     *\n     * When using `maxAgeSeconds`, responses may be used *once* after expiring\n     * because the expiration clean up will not have occurred until *after* the\n     * cached response has been used. If the response has a \"Date\" header, then\n     * a light weight expiration check is performed and the response will not be\n     * used immediately.\n     *\n     * When using `maxEntries`, the entry least-recently requested will be removed\n     * from the cache first.\n     *\n     * @memberof workbox-expiration\n     */\n    class ExpirationPlugin {\n      /**\n       * @param {ExpirationPluginOptions} config\n       * @param {number} [config.maxEntries] The maximum number of entries to cache.\n       * Entries used the least will be removed as the maximum is reached.\n       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n       * it's treated as stale and removed.\n       * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n       * that will be used when calling `delete()` on the cache.\n       * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n       * automatic deletion if the available storage quota has been exceeded.\n       */\n      constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({\n          event,\n          request,\n          cacheName,\n          cachedResponse\n        }) => {\n          if (!cachedResponse) {\n            return null;\n          }\n          const isFresh = this._isResponseDateFresh(cachedResponse);\n          // Expire entries to ensure that even if the expiration date has\n          // expired, it'll only be used once.\n          const cacheExpiration = this._getCacheExpiration(cacheName);\n          dontWaitFor(cacheExpiration.expireEntries());\n          // Update the metadata for the request URL to the current timestamp,\n          // but don't `await` it as we don't want to block the response.\n          const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n          if (event) {\n            try {\n              event.waitUntil(updateTimestampDone);\n            } catch (error) {\n              {\n                // The event may not be a fetch event; only log the URL if it is.\n                if ('request' in event) {\n                  logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for ` + `'${getFriendlyURL(event.request.url)}'.`);\n                }\n              }\n            }\n          }\n          return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({\n          cacheName,\n          request\n        }) => {\n          {\n            finalAssertExports.isType(cacheName, 'string', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'cacheDidUpdate',\n              paramName: 'cacheName'\n            });\n            finalAssertExports.isInstance(request, Request, {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'cacheDidUpdate',\n              paramName: 'request'\n            });\n          }\n          const cacheExpiration = this._getCacheExpiration(cacheName);\n          await cacheExpiration.updateTimestamp(request.url);\n          await cacheExpiration.expireEntries();\n        };\n        {\n          if (!(config.maxEntries || config.maxAgeSeconds)) {\n            throw new WorkboxError('max-entries-or-age-required', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor'\n            });\n          }\n          if (config.maxEntries) {\n            finalAssertExports.isType(config.maxEntries, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor',\n              paramName: 'config.maxEntries'\n            });\n          }\n          if (config.maxAgeSeconds) {\n            finalAssertExports.isType(config.maxAgeSeconds, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor',\n              paramName: 'config.maxAgeSeconds'\n            });\n          }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n          registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n      }\n      /**\n       * A simple helper method to return a CacheExpiration instance for a given\n       * cache name.\n       *\n       * @param {string} cacheName\n       * @return {CacheExpiration}\n       *\n       * @private\n       */\n      _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n          throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n          cacheExpiration = new CacheExpiration(cacheName, this._config);\n          this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n      }\n      /**\n       * @param {Response} cachedResponse\n       * @return {boolean}\n       *\n       * @private\n       */\n      _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n          // We aren't expiring by age, so return true, it's fresh\n          return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n          // Unable to parse date, so assume it's fresh.\n          return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n      }\n      /**\n       * This method will extract the data header and parse it into a useful\n       * value.\n       *\n       * @param {Response} cachedResponse\n       * @return {number|null}\n       *\n       * @private\n       */\n      _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n          return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n          return null;\n        }\n        return headerTime;\n      }\n      /**\n       * This is a helper method that performs two operations:\n       *\n       * - Deletes *all* the underlying Cache instances associated with this plugin\n       * instance, by calling caches.delete() on your behalf.\n       * - Deletes the metadata from IndexedDB used to keep track of expiration\n       * details for each Cache instance.\n       *\n       * When using cache expiration, calling this method is preferable to calling\n       * `caches.delete()` directly, since this will ensure that the IndexedDB\n       * metadata is also cleanly removed and open IndexedDB instances are deleted.\n       *\n       * Note that if you're *not* using cache expiration for a given cache, calling\n       * `caches.delete()` and passing in the cache's name should be sufficient.\n       * There is no Workbox-specific method needed for cleanup in that case.\n       */\n      async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n          await self.caches.delete(cacheName);\n          await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n      }\n    }\n\n    // @ts-ignore\n    try {\n      self['workbox:cacheable-response:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This class allows you to set up rules determining what\n     * status codes and/or headers need to be present in order for a\n     * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n     * to be considered cacheable.\n     *\n     * @memberof workbox-cacheable-response\n     */\n    class CacheableResponse {\n      /**\n       * To construct a new CacheableResponse instance you must provide at least\n       * one of the `config` properties.\n       *\n       * If both `statuses` and `headers` are specified, then both conditions must\n       * be met for the `Response` to be considered cacheable.\n       *\n       * @param {Object} config\n       * @param {Array<number>} [config.statuses] One or more status codes that a\n       * `Response` can have and be considered cacheable.\n       * @param {Object<string,string>} [config.headers] A mapping of header names\n       * and expected values that a `Response` can have and be considered cacheable.\n       * If multiple headers are provided, only one needs to be present.\n       */\n      constructor(config = {}) {\n        {\n          if (!(config.statuses || config.headers)) {\n            throw new WorkboxError('statuses-or-headers-required', {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor'\n            });\n          }\n          if (config.statuses) {\n            finalAssertExports.isArray(config.statuses, {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor',\n              paramName: 'config.statuses'\n            });\n          }\n          if (config.headers) {\n            finalAssertExports.isType(config.headers, 'object', {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor',\n              paramName: 'config.headers'\n            });\n          }\n        }\n        this._statuses = config.statuses;\n        this._headers = config.headers;\n      }\n      /**\n       * Checks a response to see whether it's cacheable or not, based on this\n       * object's configuration.\n       *\n       * @param {Response} response The response whose cacheability is being\n       * checked.\n       * @return {boolean} `true` if the `Response` is cacheable, and `false`\n       * otherwise.\n       */\n      isResponseCacheable(response) {\n        {\n          finalAssertExports.isInstance(response, Response, {\n            moduleName: 'workbox-cacheable-response',\n            className: 'CacheableResponse',\n            funcName: 'isResponseCacheable',\n            paramName: 'response'\n          });\n        }\n        let cacheable = true;\n        if (this._statuses) {\n          cacheable = this._statuses.includes(response.status);\n        }\n        if (this._headers && cacheable) {\n          cacheable = Object.keys(this._headers).some(headerName => {\n            return response.headers.get(headerName) === this._headers[headerName];\n          });\n        }\n        {\n          if (!cacheable) {\n            logger.groupCollapsed(`The request for ` + `'${getFriendlyURL(response.url)}' returned a response that does ` + `not meet the criteria for being cached.`);\n            logger.groupCollapsed(`View cacheability criteria here.`);\n            logger.log(`Cacheable statuses: ` + JSON.stringify(this._statuses));\n            logger.log(`Cacheable headers: ` + JSON.stringify(this._headers, null, 2));\n            logger.groupEnd();\n            const logFriendlyHeaders = {};\n            response.headers.forEach((value, key) => {\n              logFriendlyHeaders[key] = value;\n            });\n            logger.groupCollapsed(`View response status and headers here.`);\n            logger.log(`Response status: ${response.status}`);\n            logger.log(`Response headers: ` + JSON.stringify(logFriendlyHeaders, null, 2));\n            logger.groupEnd();\n            logger.groupCollapsed(`View full response details here.`);\n            logger.log(response.headers);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n          }\n        }\n        return cacheable;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A class implementing the `cacheWillUpdate` lifecycle callback. This makes it\n     * easier to add in cacheability checks to requests made via Workbox's built-in\n     * strategies.\n     *\n     * @memberof workbox-cacheable-response\n     */\n    class CacheableResponsePlugin {\n      /**\n       * To construct a new CacheableResponsePlugin instance you must provide at\n       * least one of the `config` properties.\n       *\n       * If both `statuses` and `headers` are specified, then both conditions must\n       * be met for the `Response` to be considered cacheable.\n       *\n       * @param {Object} config\n       * @param {Array<number>} [config.statuses] One or more status codes that a\n       * `Response` can have and be considered cacheable.\n       * @param {Object<string,string>} [config.headers] A mapping of header names\n       * and expected values that a `Response` can have and be considered cacheable.\n       * If multiple headers are provided, only one needs to be present.\n       */\n      constructor(config) {\n        /**\n         * @param {Object} options\n         * @param {Response} options.response\n         * @return {Response|null}\n         * @private\n         */\n        this.cacheWillUpdate = async ({\n          response\n        }) => {\n          if (this._cacheableResponse.isResponseCacheable(response)) {\n            return response;\n          }\n          return null;\n        };\n        this._cacheableResponse = new CacheableResponse(config);\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    function stripParams(fullURL, ignoreParams) {\n      const strippedURL = new URL(fullURL);\n      for (const param of ignoreParams) {\n        strippedURL.searchParams.delete(param);\n      }\n      return strippedURL.href;\n    }\n    /**\n     * Matches an item in the cache, ignoring specific URL params. This is similar\n     * to the `ignoreSearch` option, but it allows you to ignore just specific\n     * params (while continuing to match on the others).\n     *\n     * @private\n     * @param {Cache} cache\n     * @param {Request} request\n     * @param {Object} matchOptions\n     * @param {Array<string>} ignoreParams\n     * @return {Promise<Response|undefined>}\n     */\n    async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n      const strippedRequestURL = stripParams(request.url, ignoreParams);\n      // If the request doesn't include any ignored params, match as normal.\n      if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n      }\n      // Otherwise, match by comparing keys\n      const keysOptions = Object.assign(Object.assign({}, matchOptions), {\n        ignoreSearch: true\n      });\n      const cacheKeys = await cache.keys(request, keysOptions);\n      for (const cacheKey of cacheKeys) {\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n          return cache.match(cacheKey, matchOptions);\n        }\n      }\n      return;\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Deferred class composes Promises in a way that allows for them to be\n     * resolved or rejected from outside the constructor. In most cases promises\n     * should be used directly, but Deferreds can be necessary when the logic to\n     * resolve a promise must be separate.\n     *\n     * @private\n     */\n    class Deferred {\n      /**\n       * Creates a promise and exposes its resolve and reject functions as methods.\n       */\n      constructor() {\n        this.promise = new Promise((resolve, reject) => {\n          this.resolve = resolve;\n          this.reject = reject;\n        });\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Runs all of the callback functions, one at a time sequentially, in the order\n     * in which they were registered.\n     *\n     * @memberof workbox-core\n     * @private\n     */\n    async function executeQuotaErrorCallbacks() {\n      {\n        logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);\n      }\n      for (const callback of quotaErrorCallbacks) {\n        await callback();\n        {\n          logger.log(callback, 'is complete.');\n        }\n      }\n      {\n        logger.log('Finished running callbacks.');\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Returns a promise that resolves and the passed number of milliseconds.\n     * This utility is an async/await-friendly version of `setTimeout`.\n     *\n     * @param {number} ms\n     * @return {Promise}\n     * @private\n     */\n    function timeout(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    // @ts-ignore\n    try {\n      self['workbox:strategies:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    function toRequest(input) {\n      return typeof input === 'string' ? new Request(input) : input;\n    }\n    /**\n     * A class created every time a Strategy instance calls\n     * {@link workbox-strategies.Strategy~handle} or\n     * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n     * cache actions around plugin callbacks and keeps track of when the strategy\n     * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n     *\n     * @memberof workbox-strategies\n     */\n    class StrategyHandler {\n      /**\n       * Creates a new instance associated with the passed strategy and event\n       * that's handling the request.\n       *\n       * The constructor also initializes the state that will be passed to each of\n       * the plugins handling this request.\n       *\n       * @param {workbox-strategies.Strategy} strategy\n       * @param {Object} options\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params] The return value from the\n       *     {@link workbox-routing~matchCallback} (if applicable).\n       */\n      constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        {\n          finalAssertExports.isInstance(options.event, ExtendableEvent, {\n            moduleName: 'workbox-strategies',\n            className: 'StrategyHandler',\n            funcName: 'constructor',\n            paramName: 'options.event'\n          });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n          this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n      }\n      /**\n       * Fetches a given request (and invokes any applicable plugin callback\n       * methods) using the `fetchOptions` (for non-navigation requests) and\n       * `plugins` defined on the `Strategy` object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - `requestWillFetch()`\n       * - `fetchDidSucceed()`\n       * - `fetchDidFail()`\n       *\n       * @param {Request|string} input The URL or request to fetch.\n       * @return {Promise<Response>}\n       */\n      async fetch(input) {\n        const {\n          event\n        } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {\n          const possiblePreloadResponse = await event.preloadResponse;\n          if (possiblePreloadResponse) {\n            {\n              logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n            }\n            return possiblePreloadResponse;\n          }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;\n        try {\n          for (const cb of this.iterateCallbacks('requestWillFetch')) {\n            request = await cb({\n              request: request.clone(),\n              event\n            });\n          }\n        } catch (err) {\n          if (err instanceof Error) {\n            throw new WorkboxError('plugin-error-request-will-fetch', {\n              thrownErrorMessage: err.message\n            });\n          }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n          let fetchResponse;\n          // See https://github.com/GoogleChrome/workbox/issues/1796\n          fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n          if (\"development\" !== 'production') {\n            logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n          }\n          for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n            fetchResponse = await callback({\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse\n            });\n          }\n          return fetchResponse;\n        } catch (error) {\n          {\n            logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n          }\n          // `originalRequest` will only exist if a `fetchDidFail` callback\n          // is being used (see above).\n          if (originalRequest) {\n            await this.runCallbacks('fetchDidFail', {\n              error: error,\n              event,\n              originalRequest: originalRequest.clone(),\n              request: pluginFilteredRequest.clone()\n            });\n          }\n          throw error;\n        }\n      }\n      /**\n       * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n       * the response generated by `this.fetch()`.\n       *\n       * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n       * so you do not have to manually call `waitUntil()` on the event.\n       *\n       * @param {Request|string} input The request or URL to fetch and cache.\n       * @return {Promise<Response>}\n       */\n      async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n      }\n      /**\n       * Matches a request from the cache (and invokes any applicable plugin\n       * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n       * defined on the strategy object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - cacheKeyWillBeUsed()\n       * - cachedResponseWillBeUsed()\n       *\n       * @param {Request|string} key The Request or URL to use as the cache key.\n       * @return {Promise<Response|undefined>} A matching response, if found.\n       */\n      async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const {\n          cacheName,\n          matchOptions\n        } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {\n          cacheName\n        });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        {\n          if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n          } else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n          }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n          cachedResponse = (await callback({\n            cacheName,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n            event: this.event\n          })) || undefined;\n        }\n        return cachedResponse;\n      }\n      /**\n       * Puts a request/response pair in the cache (and invokes any applicable\n       * plugin callback methods) using the `cacheName` and `plugins` defined on\n       * the strategy object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - cacheKeyWillBeUsed()\n       * - cacheWillUpdate()\n       * - cacheDidUpdate()\n       *\n       * @param {Request|string} key The request or URL to use as the cache key.\n       * @param {Response} response The response to cache.\n       * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n       * not be cached, and `true` otherwise.\n       */\n      async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        {\n          if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n              url: getFriendlyURL(effectiveRequest.url),\n              method: effectiveRequest.method\n            });\n          }\n          // See https://github.com/GoogleChrome/workbox/issues/2818\n          const vary = response.headers.get('Vary');\n          if (vary) {\n            logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);\n          }\n        }\n        if (!response) {\n          {\n            logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n          }\n          throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url)\n          });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n          {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);\n          }\n          return false;\n        }\n        const {\n          cacheName,\n          matchOptions\n        } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\n        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n        // feature. Consider into ways to only add this behavior if using\n        // precaching.\n        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;\n        {\n          logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n          await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        } catch (error) {\n          if (error instanceof Error) {\n            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n            if (error.name === 'QuotaExceededError') {\n              await executeQuotaErrorCallbacks();\n            }\n            throw error;\n          }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n          await callback({\n            cacheName,\n            oldResponse,\n            newResponse: responseToCache.clone(),\n            request: effectiveRequest,\n            event: this.event\n          });\n        }\n        return true;\n      }\n      /**\n       * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n       * executes any of those callbacks found in sequence. The final `Request`\n       * object returned by the last plugin is treated as the cache key for cache\n       * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n       * been registered, the passed request is returned unmodified\n       *\n       * @param {Request} request\n       * @param {string} mode\n       * @return {Promise<Request>}\n       */\n      async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n          let effectiveRequest = request;\n          for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n            effectiveRequest = toRequest(await callback({\n              mode,\n              request: effectiveRequest,\n              event: this.event,\n              // params has a type any can't change right now.\n              params: this.params  \n            }));\n          }\n          this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n      }\n      /**\n       * Returns true if the strategy has at least one plugin with the given\n       * callback.\n       *\n       * @param {string} name The name of the callback to check for.\n       * @return {boolean}\n       */\n      hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n          if (name in plugin) {\n            return true;\n          }\n        }\n        return false;\n      }\n      /**\n       * Runs all plugin callbacks matching the given name, in order, passing the\n       * given param object (merged ith the current plugin state) as the only\n       * argument.\n       *\n       * Note: since this method runs all plugins, it's not suitable for cases\n       * where the return value of a callback needs to be applied prior to calling\n       * the next callback. See\n       * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n       * below for how to handle that case.\n       *\n       * @param {string} name The name of the callback to run within each plugin.\n       * @param {Object} param The object to pass as the first (and only) param\n       *     when executing each callback. This object will be merged with the\n       *     current plugin state prior to callback execution.\n       */\n      async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n          // TODO(philipwalton): not sure why `any` is needed. It seems like\n          // this should work with `as WorkboxPluginCallbackParam[C]`.\n          await callback(param);\n        }\n      }\n      /**\n       * Accepts a callback and returns an iterable of matching plugin callbacks,\n       * where each callback is wrapped with the current handler state (i.e. when\n       * you call each callback, whatever object parameter you pass it will\n       * be merged with the plugin's current state).\n       *\n       * @param {string} name The name fo the callback to run\n       * @return {Array<Function>}\n       */\n      *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n          if (typeof plugin[name] === 'function') {\n            const state = this._pluginStateMap.get(plugin);\n            const statefulCallback = param => {\n              const statefulParam = Object.assign(Object.assign({}, param), {\n                state\n              });\n              // TODO(philipwalton): not sure why `any` is needed. It seems like\n              // this should work with `as WorkboxPluginCallbackParam[C]`.\n              return plugin[name](statefulParam);\n            };\n            yield statefulCallback;\n          }\n        }\n      }\n      /**\n       * Adds a promise to the\n       * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n       * of the event associated with the request being handled (usually a\n       * `FetchEvent`).\n       *\n       * Note: you can await\n       * {@link workbox-strategies.StrategyHandler~doneWaiting}\n       * to know when all added promises have settled.\n       *\n       * @param {Promise} promise A promise to add to the extend lifetime promises\n       *     of the event that triggered the request.\n       */\n      waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n      }\n      /**\n       * Returns a promise that resolves once all promises passed to\n       * {@link workbox-strategies.StrategyHandler~waitUntil}\n       * have settled.\n       *\n       * Note: any work done after `doneWaiting()` settles should be manually\n       * passed to an event's `waitUntil()` method (not this handler's\n       * `waitUntil()` method), otherwise the service worker thread may be killed\n       * prior to your work completing.\n       */\n      async doneWaiting() {\n        while (this._extendLifetimePromises.length) {\n          const promises = this._extendLifetimePromises.splice(0);\n          const result = await Promise.allSettled(promises);\n          const firstRejection = result.find(i => i.status === 'rejected');\n          if (firstRejection) {\n            throw firstRejection.reason;\n          }\n        }\n      }\n      /**\n       * Stops running the strategy and immediately resolves any pending\n       * `waitUntil()` promises.\n       */\n      destroy() {\n        this._handlerDeferred.resolve(null);\n      }\n      /**\n       * This method will call cacheWillUpdate on the available plugins (or use\n       * status === 200) to determine if the Response is safe and valid to cache.\n       *\n       * @param {Request} options.request\n       * @param {Response} options.response\n       * @return {Promise<Response|undefined>}\n       *\n       * @private\n       */\n      async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n          responseToCache = (await callback({\n            request: this.request,\n            response: responseToCache,\n            event: this.event\n          })) || undefined;\n          pluginsUsed = true;\n          if (!responseToCache) {\n            break;\n          }\n        }\n        if (!pluginsUsed) {\n          if (responseToCache && responseToCache.status !== 200) {\n            responseToCache = undefined;\n          }\n          {\n            if (responseToCache) {\n              if (responseToCache.status !== 200) {\n                if (responseToCache.status === 0) {\n                  logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);\n                } else {\n                  logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);\n                }\n              }\n            }\n          }\n        }\n        return responseToCache;\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An abstract base class that all other strategy classes must extend from:\n     *\n     * @memberof workbox-strategies\n     */\n    class Strategy {\n      /**\n       * Creates a new instance of the strategy and sets all documented option\n       * properties as public instance properties.\n       *\n       * Note: if a custom strategy class extends the base Strategy class and does\n       * not need more than these properties, it does not need to define its own\n       * constructor.\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] Cache name to store and retrieve\n       * requests. Defaults to the cache names provided by\n       * {@link workbox-core.cacheNames}.\n       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} [options.fetchOptions] Values passed along to the\n       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n       * `fetch()` requests made by this strategy.\n       * @param {Object} [options.matchOptions] The\n       * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n       * for any `cache.match()` or `cache.put()` calls made by this strategy.\n       */\n      constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n      }\n      /**\n       * Perform a request strategy and returns a `Promise` that will resolve with\n       * a `Response`, invoking all relevant plugin callbacks.\n       *\n       * When a strategy instance is registered with a Workbox\n       * {@link workbox-routing.Route}, this method is automatically\n       * called when the route matches.\n       *\n       * Alternatively, this method can be used in a standalone `FetchEvent`\n       * listener by passing it to `event.respondWith()`.\n       *\n       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n       *     properties listed below.\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params]\n       */\n      handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n      }\n      /**\n       * Similar to {@link workbox-strategies.Strategy~handle}, but\n       * instead of just returning a `Promise` that resolves to a `Response` it\n       * it will return an tuple of `[response, done]` promises, where the former\n       * (`response`) is equivalent to what `handle()` returns, and the latter is a\n       * Promise that will resolve once any promises that were added to\n       * `event.waitUntil()` as part of performing the strategy have completed.\n       *\n       * You can await the `done` promise to ensure any extra work performed by\n       * the strategy (usually caching responses) completes successfully.\n       *\n       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n       *     properties listed below.\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params]\n       * @return {Array<Promise>} A tuple of [response, done]\n       *     promises that can be used to determine when the response resolves as\n       *     well as when the handler has completed all its work.\n       */\n      handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n          options = {\n            event: options,\n            request: options.request\n          };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, {\n          event,\n          request,\n          params\n        });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n      }\n      async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', {\n          event,\n          request\n        });\n        let response = undefined;\n        try {\n          response = await this._handle(request, handler);\n          // The \"official\" Strategy subclasses all throw this error automatically,\n          // but in case a third-party Strategy doesn't, ensure that we have a\n          // consistent failure when there's no response or an error response.\n          if (!response || response.type === 'error') {\n            throw new WorkboxError('no-response', {\n              url: request.url\n            });\n          }\n        } catch (error) {\n          if (error instanceof Error) {\n            for (const callback of handler.iterateCallbacks('handlerDidError')) {\n              response = await callback({\n                error,\n                event,\n                request\n              });\n              if (response) {\n                break;\n              }\n            }\n          }\n          if (!response) {\n            throw error;\n          } else {\n            logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);\n          }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n          response = await callback({\n            event,\n            request,\n            response\n          });\n        }\n        return response;\n      }\n      async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n          response = await responseDone;\n        } catch (error) {\n          // Ignore errors, as response errors should be caught via the `response`\n          // promise above. The `done` promise will only throw for errors in\n          // promises passed to `handler.waitUntil()`.\n        }\n        try {\n          await handler.runCallbacks('handlerDidRespond', {\n            event,\n            request,\n            response\n          });\n          await handler.doneWaiting();\n        } catch (waitUntilError) {\n          if (waitUntilError instanceof Error) {\n            error = waitUntilError;\n          }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n          event,\n          request,\n          response,\n          error: error\n        });\n        handler.destroy();\n        if (error) {\n          throw error;\n        }\n      }\n    }\n    /**\n     * Classes extending the `Strategy` based class should implement this method,\n     * and leverage the {@link workbox-strategies.StrategyHandler}\n     * arg to perform all fetching and cache logic, which will ensure all relevant\n     * cache, cache options, fetch options and plugins are used (per the current\n     * strategy instance).\n     *\n     * @name _handle\n     * @instance\n     * @abstract\n     * @function\n     * @param {Request} request\n     * @param {workbox-strategies.StrategyHandler} handler\n     * @return {Promise<Response>}\n     *\n     * @memberof workbox-strategies.Strategy\n     */\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const messages = {\n      strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,\n      printFinalResponse: response => {\n        if (response) {\n          logger.groupCollapsed(`View the final response here.`);\n          logger.log(response || '[No response returned]');\n          logger.groupEnd();\n        }\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)\n     * request strategy.\n     *\n     * A cache first strategy is useful for assets that have been revisioned,\n     * such as URLs like `/styles/example.a8f5f1.css`, since they\n     * can be cached for long periods of time.\n     *\n     * If the network request fails, and there is no cache match, this will throw\n     * a `WorkboxError` exception.\n     *\n     * @extends workbox-strategies.Strategy\n     * @memberof workbox-strategies\n     */\n    class CacheFirst extends Strategy {\n      /**\n       * @private\n       * @param {Request|string} request A request to run this strategy for.\n       * @param {workbox-strategies.StrategyHandler} handler The event that\n       *     triggered the request.\n       * @return {Promise<Response>}\n       */\n      async _handle(request, handler) {\n        const logs = [];\n        {\n          finalAssertExports.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: this.constructor.name,\n            funcName: 'makeRequest',\n            paramName: 'request'\n          });\n        }\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (!response) {\n          {\n            logs.push(`No response found in the '${this.cacheName}' cache. ` + `Will respond with a network request.`);\n          }\n          try {\n            response = await handler.fetchAndCachePut(request);\n          } catch (err) {\n            if (err instanceof Error) {\n              error = err;\n            }\n          }\n          {\n            if (response) {\n              logs.push(`Got response from network.`);\n            } else {\n              logs.push(`Unable to get a response from the network.`);\n            }\n          }\n        } else {\n          {\n            logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n          }\n        }\n        {\n          logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n          for (const log of logs) {\n            logger.log(log);\n          }\n          messages.printFinalResponse(response);\n          logger.groupEnd();\n        }\n        if (!response) {\n          throw new WorkboxError('no-response', {\n            url: request.url,\n            error\n          });\n        }\n        return response;\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Claim any currently available clients once the service worker\n     * becomes active. This is normally used in conjunction with `skipWaiting()`.\n     *\n     * @memberof workbox-core\n     */\n    function clientsClaim() {\n      self.addEventListener('activate', () => self.clients.claim());\n    }\n\n    /*\n      Copyright 2020 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A utility method that makes it easier to use `event.waitUntil` with\n     * async functions and return the result.\n     *\n     * @param {ExtendableEvent} event\n     * @param {Function} asyncFn\n     * @return {Function}\n     * @private\n     */\n    function waitUntil(event, asyncFn) {\n      const returnPromise = asyncFn();\n      event.waitUntil(returnPromise);\n      return returnPromise;\n    }\n\n    // @ts-ignore\n    try {\n      self['workbox:precaching:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    // Name of the search parameter used to store revision info.\n    const REVISION_SEARCH_PARAM = '__WB_REVISION__';\n    /**\n     * Converts a manifest entry into a versioned URL suitable for precaching.\n     *\n     * @param {Object|string} entry\n     * @return {string} A URL with versioning info.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function createCacheKey(entry) {\n      if (!entry) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', {\n          entry\n        });\n      }\n      // If a precache manifest entry is a string, it's assumed to be a versioned\n      // URL, like '/app.abcd1234.js'. Return as-is.\n      if (typeof entry === 'string') {\n        const urlObject = new URL(entry, location.href);\n        return {\n          cacheKey: urlObject.href,\n          url: urlObject.href\n        };\n      }\n      const {\n        revision,\n        url\n      } = entry;\n      if (!url) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', {\n          entry\n        });\n      }\n      // If there's just a URL and no revision, then it's also assumed to be a\n      // versioned URL.\n      if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n          cacheKey: urlObject.href,\n          url: urlObject.href\n        };\n      }\n      // Otherwise, construct a properly versioned URL using the custom Workbox\n      // search parameter along with the revision info.\n      const cacheKeyURL = new URL(url, location.href);\n      const originalURL = new URL(url, location.href);\n      cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n      return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href\n      };\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A plugin, designed to be used with PrecacheController, to determine the\n     * of assets that were updated (or not updated) during the install event.\n     *\n     * @private\n     */\n    class PrecacheInstallReportPlugin {\n      constructor() {\n        this.updatedURLs = [];\n        this.notUpdatedURLs = [];\n        this.handlerWillStart = async ({\n          request,\n          state\n        }) => {\n          // TODO: `state` should never be undefined...\n          if (state) {\n            state.originalRequest = request;\n          }\n        };\n        this.cachedResponseWillBeUsed = async ({\n          event,\n          state,\n          cachedResponse\n        }) => {\n          if (event.type === 'install') {\n            if (state && state.originalRequest && state.originalRequest instanceof Request) {\n              // TODO: `state` should never be undefined...\n              const url = state.originalRequest.url;\n              if (cachedResponse) {\n                this.notUpdatedURLs.push(url);\n              } else {\n                this.updatedURLs.push(url);\n              }\n            }\n          }\n          return cachedResponse;\n        };\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A plugin, designed to be used with PrecacheController, to translate URLs into\n     * the corresponding cache key, based on the current revision info.\n     *\n     * @private\n     */\n    class PrecacheCacheKeyPlugin {\n      constructor({\n        precacheController\n      }) {\n        this.cacheKeyWillBeUsed = async ({\n          request,\n          params\n        }) => {\n          // Params is type any, can't change right now.\n           \n          const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);\n           \n          return cacheKey ? new Request(cacheKey, {\n            headers: request.headers\n          }) : request;\n        };\n        this._precacheController = precacheController;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} groupTitle\n     * @param {Array<string>} deletedURLs\n     *\n     * @private\n     */\n    const logGroup = (groupTitle, deletedURLs) => {\n      logger.groupCollapsed(groupTitle);\n      for (const url of deletedURLs) {\n        logger.log(url);\n      }\n      logger.groupEnd();\n    };\n    /**\n     * @param {Array<string>} deletedURLs\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function printCleanupDetails(deletedURLs) {\n      const deletionCount = deletedURLs.length;\n      if (deletionCount > 0) {\n        logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n        logGroup('Deleted Cache Requests', deletedURLs);\n        logger.groupEnd();\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} groupTitle\n     * @param {Array<string>} urls\n     *\n     * @private\n     */\n    function _nestedGroup(groupTitle, urls) {\n      if (urls.length === 0) {\n        return;\n      }\n      logger.groupCollapsed(groupTitle);\n      for (const url of urls) {\n        logger.log(url);\n      }\n      logger.groupEnd();\n    }\n    /**\n     * @param {Array<string>} urlsToPrecache\n     * @param {Array<string>} urlsAlreadyPrecached\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n      const precachedCount = urlsToPrecache.length;\n      const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n      if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n        if (alreadyPrecachedCount > 0) {\n          message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n        }\n        logger.groupCollapsed(message);\n        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n        logger.groupEnd();\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let supportStatus;\n    /**\n     * A utility function that determines whether the current browser supports\n     * constructing a new `Response` from a `response.body` stream.\n     *\n     * @return {boolean} `true`, if the current browser can successfully\n     *     construct a `Response` from a `response.body` stream, `false` otherwise.\n     *\n     * @private\n     */\n    function canConstructResponseFromBodyStream() {\n      if (supportStatus === undefined) {\n        const testResponse = new Response('');\n        if ('body' in testResponse) {\n          try {\n            new Response(testResponse.body);\n            supportStatus = true;\n          } catch (error) {\n            supportStatus = false;\n          }\n        }\n        supportStatus = false;\n      }\n      return supportStatus;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Allows developers to copy a response and modify its `headers`, `status`,\n     * or `statusText` values (the values settable via a\n     * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n     * object in the constructor).\n     * To modify these values, pass a function as the second argument. That\n     * function will be invoked with a single object with the response properties\n     * `{headers, status, statusText}`. The return value of this function will\n     * be used as the `ResponseInit` for the new `Response`. To change the values\n     * either modify the passed parameter(s) and return it, or return a totally\n     * new object.\n     *\n     * This method is intentionally limited to same-origin responses, regardless of\n     * whether CORS was used or not.\n     *\n     * @param {Response} response\n     * @param {Function} modifier\n     * @memberof workbox-core\n     */\n    async function copyResponse(response, modifier) {\n      let origin = null;\n      // If response.url isn't set, assume it's cross-origin and keep origin null.\n      if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n      }\n      if (origin !== self.location.origin) {\n        throw new WorkboxError('cross-origin-copy-response', {\n          origin\n        });\n      }\n      const clonedResponse = response.clone();\n      // Create a fresh `ResponseInit` object by cloning the headers.\n      const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText\n      };\n      // Apply any user modifications.\n      const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n      // Create the new response from the body stream and `ResponseInit`\n      // modifications. Note: not all browsers support the Response.body stream,\n      // so fall back to reading the entire body into memory as a blob.\n      const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();\n      return new Response(body, modifiedResponseInit);\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A {@link workbox-strategies.Strategy} implementation\n     * specifically designed to work with\n     * {@link workbox-precaching.PrecacheController}\n     * to both cache and fetch precached assets.\n     *\n     * Note: an instance of this class is created automatically when creating a\n     * `PrecacheController`; it's generally not necessary to create this yourself.\n     *\n     * @extends workbox-strategies.Strategy\n     * @memberof workbox-precaching\n     */\n    class PrecacheStrategy extends Strategy {\n      /**\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] Cache name to store and retrieve\n       * requests. Defaults to the cache names provided by\n       * {@link workbox-core.cacheNames}.\n       * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} [options.fetchOptions] Values passed along to the\n       * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n       * of all fetch() requests made by this strategy.\n       * @param {Object} [options.matchOptions] The\n       * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n       * for any `cache.match()` or `cache.put()` calls made by this strategy.\n       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n       * get the response from the network if there's a precache miss.\n       */\n      constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n      }\n      /**\n       * @private\n       * @param {Request|string} request A request to run this strategy for.\n       * @param {workbox-strategies.StrategyHandler} handler The event that\n       *     triggered the request.\n       * @return {Promise<Response>}\n       */\n      async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n          return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n          return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n      }\n      async _handleFetch(request, handler) {\n        let response;\n        const params = handler.params || {};\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n          {\n            logger.warn(`The precached response for ` + `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` + `found. Falling back to the network.`);\n          }\n          const integrityInManifest = params.integrity;\n          const integrityInRequest = request.integrity;\n          const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n          // Do not add integrity if the original request is no-cors\n          // See https://github.com/GoogleChrome/workbox/issues/3096\n          response = await handler.fetch(new Request(request, {\n            integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined\n          }));\n          // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n          // that the response matches the precache manifest's expectations,\n          // and there's either a) no integrity property in the incoming request\n          // or b) there is an integrity, and it matches the precache manifest.\n          // See https://github.com/GoogleChrome/workbox/issues/2858\n          // Also if the original request users no-cors we don't use integrity.\n          // See https://github.com/GoogleChrome/workbox/issues/3096\n          if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {\n            this._useDefaultCacheabilityPluginIfNeeded();\n            const wasCached = await handler.cachePut(request, response.clone());\n            {\n              if (wasCached) {\n                logger.log(`A response for ${getFriendlyURL(request.url)} ` + `was used to \"repair\" the precache.`);\n              }\n            }\n          }\n        } else {\n          // This shouldn't normally happen, but there are edge cases:\n          // https://github.com/GoogleChrome/workbox/issues/1441\n          throw new WorkboxError('missing-precache-entry', {\n            cacheName: this.cacheName,\n            url: request.url\n          });\n        }\n        {\n          const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n          // Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n          logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n          logger.groupCollapsed(`View request details here.`);\n          logger.log(request);\n          logger.groupEnd();\n          logger.groupCollapsed(`View response details here.`);\n          logger.log(response);\n          logger.groupEnd();\n          logger.groupEnd();\n        }\n        return response;\n      }\n      async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n          // Throwing here will lead to the `install` handler failing, which\n          // we want to do if *any* of the responses aren't safe to cache.\n          throw new WorkboxError('bad-precaching-response', {\n            url: request.url,\n            status: response.status\n          });\n        }\n        return response;\n      }\n      /**\n       * This method is complex, as there a number of things to account for:\n       *\n       * The `plugins` array can be set at construction, and/or it might be added to\n       * to at any time before the strategy is used.\n       *\n       * At the time the strategy is used (i.e. during an `install` event), there\n       * needs to be at least one plugin that implements `cacheWillUpdate` in the\n       * array, other than `copyRedirectedCacheableResponsesPlugin`.\n       *\n       * - If this method is called and there are no suitable `cacheWillUpdate`\n       * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n       *\n       * - If this method is called and there is exactly one `cacheWillUpdate`, then\n       * we don't have to do anything (this might be a previously added\n       * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n       *\n       * - If this method is called and there is more than one `cacheWillUpdate`,\n       * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n       * we need to remove it. (This situation is unlikely, but it could happen if\n       * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n       * and then later on after manually adding a custom `cacheWillUpdate`.)\n       *\n       * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n       *\n       * @private\n       */\n      _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n          // Ignore the copy redirected plugin when determining what to do.\n          if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n            continue;\n          }\n          // Save the default plugin's index, in case it needs to be removed.\n          if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n            defaultPluginIndex = index;\n          }\n          if (plugin.cacheWillUpdate) {\n            cacheWillUpdatePluginCount++;\n          }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n          this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n          // Only remove the default plugin; multiple custom plugins are allowed.\n          this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n      }\n    }\n    PrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n      async cacheWillUpdate({\n        response\n      }) {\n        if (!response || response.status >= 400) {\n          return null;\n        }\n        return response;\n      }\n    };\n    PrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n      async cacheWillUpdate({\n        response\n      }) {\n        return response.redirected ? await copyResponse(response) : response;\n      }\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Performs efficient precaching of assets.\n     *\n     * @memberof workbox-precaching\n     */\n    class PrecacheController {\n      /**\n       * Create a new PrecacheController.\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] The cache to use for precaching.\n       * @param {string} [options.plugins] Plugins to use when precaching as well\n       * as responding to fetch events for precached assets.\n       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n       * get the response from the network if there's a precache miss.\n       */\n      constructor({\n        cacheName,\n        plugins = [],\n        fallbackToNetwork = true\n      } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n          cacheName: cacheNames.getPrecacheName(cacheName),\n          plugins: [...plugins, new PrecacheCacheKeyPlugin({\n            precacheController: this\n          })],\n          fallbackToNetwork\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n      }\n      /**\n       * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n       * used to cache assets and respond to fetch events.\n       */\n      get strategy() {\n        return this._strategy;\n      }\n      /**\n       * Adds items to the precache list, removing any duplicates and\n       * stores the files in the\n       * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n       * worker installs.\n       *\n       * This method can be called multiple times.\n       *\n       * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n       */\n      precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n          self.addEventListener('install', this.install);\n          self.addEventListener('activate', this.activate);\n          this._installAndActiveListenersAdded = true;\n        }\n      }\n      /**\n       * This method will add items to the precache list, removing duplicates\n       * and ensuring the information is valid.\n       *\n       * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n       *     Array of entries to precache.\n       */\n      addToCacheList(entries) {\n        {\n          finalAssertExports.isArray(entries, {\n            moduleName: 'workbox-precaching',\n            className: 'PrecacheController',\n            funcName: 'addToCacheList',\n            paramName: 'entries'\n          });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n          // See https://github.com/GoogleChrome/workbox/issues/2259\n          if (typeof entry === 'string') {\n            urlsToWarnAbout.push(entry);\n          } else if (entry && entry.revision === undefined) {\n            urlsToWarnAbout.push(entry.url);\n          }\n          const {\n            cacheKey,\n            url\n          } = createCacheKey(entry);\n          const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n            throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n              firstEntry: this._urlsToCacheKeys.get(url),\n              secondEntry: cacheKey\n            });\n          }\n          if (typeof entry !== 'string' && entry.integrity) {\n            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                url\n              });\n            }\n            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n          }\n          this._urlsToCacheKeys.set(url, cacheKey);\n          this._urlsToCacheModes.set(url, cacheMode);\n          if (urlsToWarnAbout.length > 0) {\n            const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n            {\n              logger.warn(warningMessage);\n            }\n          }\n        }\n      }\n      /**\n       * Precaches new and updated assets. Call this method from the service worker\n       * install event.\n       *\n       * Note: this method calls `event.waitUntil()` for you, so you do not need\n       * to call it yourself in your event handlers.\n       *\n       * @param {ExtendableEvent} event\n       * @return {Promise<workbox-precaching.InstallResult>}\n       */\n      install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n          const installReportPlugin = new PrecacheInstallReportPlugin();\n          this.strategy.plugins.push(installReportPlugin);\n          // Cache entries one at a time.\n          // See https://github.com/GoogleChrome/workbox/issues/2528\n          for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            const cacheMode = this._urlsToCacheModes.get(url);\n            const request = new Request(url, {\n              integrity,\n              cache: cacheMode,\n              credentials: 'same-origin'\n            });\n            await Promise.all(this.strategy.handleAll({\n              params: {\n                cacheKey\n              },\n              request,\n              event\n            }));\n          }\n          const {\n            updatedURLs,\n            notUpdatedURLs\n          } = installReportPlugin;\n          {\n            printInstallDetails(updatedURLs, notUpdatedURLs);\n          }\n          return {\n            updatedURLs,\n            notUpdatedURLs\n          };\n        });\n      }\n      /**\n       * Deletes assets that are no longer present in the current precache manifest.\n       * Call this method from the service worker activate event.\n       *\n       * Note: this method calls `event.waitUntil()` for you, so you do not need\n       * to call it yourself in your event handlers.\n       *\n       * @param {ExtendableEvent} event\n       * @return {Promise<workbox-precaching.CleanupResult>}\n       */\n      activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n          const cache = await self.caches.open(this.strategy.cacheName);\n          const currentlyCachedRequests = await cache.keys();\n          const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n          const deletedURLs = [];\n          for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n              await cache.delete(request);\n              deletedURLs.push(request.url);\n            }\n          }\n          {\n            printCleanupDetails(deletedURLs);\n          }\n          return {\n            deletedURLs\n          };\n        });\n      }\n      /**\n       * Returns a mapping of a precached URL to the corresponding cache key, taking\n       * into account the revision information for the URL.\n       *\n       * @return {Map<string, string>} A URL to cache key mapping.\n       */\n      getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n      }\n      /**\n       * Returns a list of all the URLs that have been precached by the current\n       * service worker.\n       *\n       * @return {Array<string>} The precached URLs.\n       */\n      getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n      }\n      /**\n       * Returns the cache key used for storing a given URL. If that URL is\n       * unversioned, like `/index.html', then the cache key will be the original\n       * URL with a search parameter appended to it.\n       *\n       * @param {string} url A URL whose cache key you want to look up.\n       * @return {string} The versioned URL that corresponds to a cache key\n       * for the original URL, or undefined if that URL isn't precached.\n       */\n      getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n      }\n      /**\n       * @param {string} url A cache key whose SRI you want to look up.\n       * @return {string} The subresource integrity associated with the cache key,\n       * or undefined if it's not set.\n       */\n      getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n      }\n      /**\n       * This acts as a drop-in replacement for\n       * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n       * with the following differences:\n       *\n       * - It knows what the name of the precache is, and only checks in that cache.\n       * - It allows you to pass in an \"original\" URL without versioning parameters,\n       * and it will automatically look up the correct cache key for the currently\n       * active revision of that URL.\n       *\n       * E.g., `matchPrecache('index.html')` will find the correct precached\n       * response for the currently active service worker, even if the actual cache\n       * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n       *\n       * @param {string|Request} request The key (without revisioning parameters)\n       * to look up in the precache.\n       * @return {Promise<Response|undefined>}\n       */\n      async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n          const cache = await self.caches.open(this.strategy.cacheName);\n          return cache.match(cacheKey);\n        }\n        return undefined;\n      }\n      /**\n       * Returns a function that looks up `url` in the precache (taking into\n       * account revision information), and returns the corresponding `Response`.\n       *\n       * @param {string} url The precached URL which will be used to lookup the\n       * `Response`.\n       * @return {workbox-routing~handlerCallback}\n       */\n      createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n          throw new WorkboxError('non-precached-url', {\n            url\n          });\n        }\n        return options => {\n          options.request = new Request(url);\n          options.params = Object.assign({\n            cacheKey\n          }, options.params);\n          return this.strategy.handle(options);\n        };\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let precacheController;\n    /**\n     * @return {PrecacheController}\n     * @private\n     */\n    const getOrCreatePrecacheController = () => {\n      if (!precacheController) {\n        precacheController = new PrecacheController();\n      }\n      return precacheController;\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Removes any URL search parameters that should be ignored.\n     *\n     * @param {URL} urlObject The original URL.\n     * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n     * each search parameter name. Matches mean that the search parameter should be\n     * ignored.\n     * @return {URL} The URL with any ignored search parameters removed.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {\n      // Convert the iterable into an array at the start of the loop to make sure\n      // deletion doesn't mess up iteration.\n      for (const paramName of [...urlObject.searchParams.keys()]) {\n        if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n          urlObject.searchParams.delete(paramName);\n        }\n      }\n      return urlObject;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Generator function that yields possible variations on the original URL to\n     * check, one at a time.\n     *\n     * @param {string} url\n     * @param {Object} options\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function* generateURLVariations(url, {\n      ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],\n      directoryIndex = 'index.html',\n      cleanURLs = true,\n      urlManipulation\n    } = {}) {\n      const urlObject = new URL(url, location.href);\n      urlObject.hash = '';\n      yield urlObject.href;\n      const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n      yield urlWithoutIgnoredParams.href;\n      if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n      }\n      if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += '.html';\n        yield cleanURL.href;\n      }\n      if (urlManipulation) {\n        const additionalURLs = urlManipulation({\n          url: urlObject\n        });\n        for (const urlToAttempt of additionalURLs) {\n          yield urlToAttempt.href;\n        }\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A subclass of {@link workbox-routing.Route} that takes a\n     * {@link workbox-precaching.PrecacheController}\n     * instance and uses it to match incoming requests and handle fetching\n     * responses from the precache.\n     *\n     * @memberof workbox-precaching\n     * @extends workbox-routing.Route\n     */\n    class PrecacheRoute extends Route {\n      /**\n       * @param {PrecacheController} precacheController A `PrecacheController`\n       * instance used to both match requests and respond to fetch events.\n       * @param {Object} [options] Options to control how requests are matched\n       * against the list of precached URLs.\n       * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n       * check cache entries for a URLs ending with '/' to see if there is a hit when\n       * appending the `directoryIndex` value.\n       * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n       * array of regex's to remove search params when looking for a cache match.\n       * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n       * check the cache for the URL with a `.html` added to the end of the end.\n       * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n       * This is a function that should take a URL and return an array of\n       * alternative URLs that should be checked for precache matches.\n       */\n      constructor(precacheController, options) {\n        const match = ({\n          request\n        }) => {\n          const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n          for (const possibleURL of generateURLVariations(request.url, options)) {\n            const cacheKey = urlsToCacheKeys.get(possibleURL);\n            if (cacheKey) {\n              const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n              return {\n                cacheKey,\n                integrity\n              };\n            }\n          }\n          {\n            logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));\n          }\n          return;\n        };\n        super(match, precacheController.strategy);\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Add a `fetch` listener to the service worker that will\n     * respond to\n     * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n     * with precached assets.\n     *\n     * Requests for assets that aren't precached, the `FetchEvent` will not be\n     * responded to, allowing the event to fall through to other `fetch` event\n     * listeners.\n     *\n     * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}\n     * options.\n     *\n     * @memberof workbox-precaching\n     */\n    function addRoute(options) {\n      const precacheController = getOrCreatePrecacheController();\n      const precacheRoute = new PrecacheRoute(precacheController, options);\n      registerRoute(precacheRoute);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * Please note: This method **will not** serve any of the cached files for you.\n     * It only precaches files. To respond to a network request you call\n     * {@link workbox-precaching.addRoute}.\n     *\n     * If you have a single array of files to precache, you can just call\n     * {@link workbox-precaching.precacheAndRoute}.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     *\n     * @memberof workbox-precaching\n     */\n    function precache(entries) {\n      const precacheController = getOrCreatePrecacheController();\n      precacheController.precache(entries);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This method will add entries to the precache list and add a route to\n     * respond to fetch events.\n     *\n     * This is a convenience method that will call\n     * {@link workbox-precaching.precache} and\n     * {@link workbox-precaching.addRoute} in a single call.\n     *\n     * @param {Array<Object|string>} entries Array of entries to precache.\n     * @param {Object} [options] See the\n     * {@link workbox-precaching.PrecacheRoute} options.\n     *\n     * @memberof workbox-precaching\n     */\n    function precacheAndRoute(entries, options) {\n      precache(entries);\n      addRoute(options);\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const SUBSTRING_TO_FIND = '-precache-';\n    /**\n     * Cleans up incompatible precaches that were created by older versions of\n     * Workbox, by a service worker registered under the current scope.\n     *\n     * This is meant to be called as part of the `activate` event.\n     *\n     * This should be safe to use as long as you don't include `substringToFind`\n     * (defaulting to `-precache-`) in your non-precache cache names.\n     *\n     * @param {string} currentPrecacheName The cache name currently in use for\n     * precaching. This cache won't be deleted.\n     * @param {string} [substringToFind='-precache-'] Cache names which include this\n     * substring will be deleted (excluding `currentPrecacheName`).\n     * @return {Array<string>} A list of all the cache names that were deleted.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {\n      const cacheNames = await self.caches.keys();\n      const cacheNamesToDelete = cacheNames.filter(cacheName => {\n        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n      });\n      await Promise.all(cacheNamesToDelete.map(cacheName => self.caches.delete(cacheName)));\n      return cacheNamesToDelete;\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds an `activate` event listener which will clean up incompatible\n     * precaches that were created by older versions of Workbox.\n     *\n     * @memberof workbox-precaching\n     */\n    function cleanupOutdatedCaches() {\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('activate', event => {\n        const cacheName = cacheNames.getPrecacheName();\n        event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {\n          {\n            if (cachesDeleted.length > 0) {\n              logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);\n            }\n          }\n        }));\n      });\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * NavigationRoute makes it easy to create a\n     * {@link workbox-routing.Route} that matches for browser\n     * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\n     *\n     * It will only match incoming Requests whose\n     * {@link https://fetch.spec.whatwg.org/#concept-request-mode|mode}\n     * is set to `navigate`.\n     *\n     * You can optionally only apply this route to a subset of navigation requests\n     * by using one or both of the `denylist` and `allowlist` parameters.\n     *\n     * @memberof workbox-routing\n     * @extends workbox-routing.Route\n     */\n    class NavigationRoute extends Route {\n      /**\n       * If both `denylist` and `allowlist` are provided, the `denylist` will\n       * take precedence and the request will not match this route.\n       *\n       * The regular expressions in `allowlist` and `denylist`\n       * are matched against the concatenated\n       * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\n       * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\n       * portions of the requested URL.\n       *\n       * *Note*: These RegExps may be evaluated against every destination URL during\n       * a navigation. Avoid using\n       * [complex RegExps](https://github.com/GoogleChrome/workbox/issues/3077),\n       * or else your users may see delays when navigating your site.\n       *\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {Object} options\n       * @param {Array<RegExp>} [options.denylist] If any of these patterns match,\n       * the route will not handle the request (even if a allowlist RegExp matches).\n       * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns\n       * match the URL's pathname and search parameter, the route will handle the\n       * request (assuming the denylist doesn't match).\n       */\n      constructor(handler, {\n        allowlist = [/./],\n        denylist = []\n      } = {}) {\n        {\n          finalAssertExports.isArrayOfClass(allowlist, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'NavigationRoute',\n            funcName: 'constructor',\n            paramName: 'options.allowlist'\n          });\n          finalAssertExports.isArrayOfClass(denylist, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'NavigationRoute',\n            funcName: 'constructor',\n            paramName: 'options.denylist'\n          });\n        }\n        super(options => this._match(options), handler);\n        this._allowlist = allowlist;\n        this._denylist = denylist;\n      }\n      /**\n       * Routes match handler.\n       *\n       * @param {Object} options\n       * @param {URL} options.url\n       * @param {Request} options.request\n       * @return {boolean}\n       *\n       * @private\n       */\n      _match({\n        url,\n        request\n      }) {\n        if (request && request.mode !== 'navigate') {\n          return false;\n        }\n        const pathnameAndSearch = url.pathname + url.search;\n        for (const regExp of this._denylist) {\n          if (regExp.test(pathnameAndSearch)) {\n            {\n              logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL matches this denylist pattern: ` + `${regExp.toString()}`);\n            }\n            return false;\n          }\n        }\n        if (this._allowlist.some(regExp => regExp.test(pathnameAndSearch))) {\n          {\n            logger.debug(`The navigation route ${pathnameAndSearch} ` + `is being used.`);\n          }\n          return true;\n        }\n        {\n          logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL being navigated to doesn't ` + `match the allowlist.`);\n        }\n        return false;\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Helper function that calls\n     * {@link PrecacheController#createHandlerBoundToURL} on the default\n     * {@link PrecacheController} instance.\n     *\n     * If you are creating your own {@link PrecacheController}, then call the\n     * {@link PrecacheController#createHandlerBoundToURL} on that instance,\n     * instead of using this function.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {workbox-routing~handlerCallback}\n     *\n     * @memberof workbox-precaching\n     */\n    function createHandlerBoundToURL(url) {\n      const precacheController = getOrCreatePrecacheController();\n      return precacheController.createHandlerBoundToURL(url);\n    }\n\n    exports.CacheFirst = CacheFirst;\n    exports.CacheableResponsePlugin = CacheableResponsePlugin;\n    exports.ExpirationPlugin = ExpirationPlugin;\n    exports.NavigationRoute = NavigationRoute;\n    exports.cleanupOutdatedCaches = cleanupOutdatedCaches;\n    exports.clientsClaim = clientsClaim;\n    exports.createHandlerBoundToURL = createHandlerBoundToURL;\n    exports.precacheAndRoute = precacheAndRoute;\n    exports.registerRoute = registerRoute;\n\n}));\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Layout/Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Layout/Sidebar.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2534,2537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2534,2537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Home, List, Settings, TrendingUp } from 'lucide-react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport { SettingsModal } from '../../features/Settings/SettingsModal';\nimport { useUIStore } from '../../core/stores/uiStore';\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\nimport { useChannels } from '../../core/hooks/useChannels';\nimport { TrendsSidebarSection } from '../../pages/Trends/Sidebar/TrendsSidebarSection';\nimport { AddChannelModal } from '../../pages/Trends/Sidebar/AddChannelModal';\nimport { useTrendStore } from '../../core/stores/trendStore';\n\n// Collapsed sidebar item - icon on top, text below\nconst CollapsedSidebarItem: React.FC<{\n  icon: React.ReactNode;\n  activeIcon: React.ReactNode;\n  label: string;\n  active?: boolean;\n  noBackground?: boolean;\n  onClick?: () => void;\n}> = ({ icon, activeIcon, label, active, noBackground, onClick }) => (\n  <div\n    onClick={onClick}\n    className={`flex flex-col items-center justify-center py-4 px-1 cursor-pointer rounded-lg transition-colors\n      ${active && !noBackground ? 'bg-sidebar-active' : 'hover:bg-sidebar-hover'}\n      ${active ? 'text-text-primary' : 'text-text-secondary hover:text-text-primary'}`}\n  >\n    {active ? activeIcon : icon}\n    <span className=\"text-[10px] mt-1.5 overflow-hidden text-ellipsis whitespace-nowrap w-full text-center font-medium\">\n      {label}\n    </span>\n  </div>\n);\n\n// Expanded sidebar item - icon on left, text on right\nconst ExpandedSidebarItem: React.FC<{\n  icon: React.ReactNode;\n  activeIcon: React.ReactNode;\n  label: string;\n  active?: boolean;\n  onClick?: () => void;\n}> = ({ icon, activeIcon, label, active, onClick }) => (\n  <div\n    onClick={onClick}\n    className={`flex items-center gap-6 py-2.5 px-3 cursor-pointer rounded-lg transition-colors\n      ${active ? 'bg-sidebar-active' : 'hover:bg-sidebar-hover'}\n      ${active ? 'text-text-primary' : 'text-text-secondary hover:text-text-primary'}`}\n  >\n    {active ? activeIcon : icon}\n    <span className={`text-sm whitespace-nowrap ${active ? 'font-medium' : 'font-normal'}`}>\n      {label}\n    </span>\n  </div>\n);\n\n// Divider component\nexport const SidebarDivider: React.FC = () => (\n  <div className=\"my-3 mx-3 border-t border-border\" />\n);\n\nimport { AnimatePresence, motion } from 'framer-motion';\n\n// Expanded sidebar item - icon on left, text on right\nexport const TrendsCollapsedGroup: React.FC<{\n  isActive: boolean;\n  channels: any[]; // Avoid circular dep or import type\n  selectedChannelId: string | null;\n  navigate: (path: string) => void;\n  setSelectedChannelId: (id: string | null) => void;\n  icons: {\n    normal: React.ReactNode;\n    active: React.ReactNode;\n  };\n}> = ({ isActive, channels, selectedChannelId, navigate, setSelectedChannelId, icons }) => {\n  const [isHovered, setHovered] = React.useState(false);\n\n  // Robust single-list approach\n  const showDropdown = isHovered;\n\n  // Determine which channels to show\n  // If hovering: Show ALL channels\n  // If not hovering: Show ONLY selected channel (if any)\n  const visibleChannels = showDropdown\n    ? channels\n    : (selectedChannelId ? channels.filter(c => c.id === selectedChannelId) : []);\n\n  return (\n    <div\n      className=\"flex flex-col items-center w-full\"\n      onMouseEnter={() => setHovered(true)}\n      onMouseLeave={() => setHovered(false)}\n    >\n      {/* Main Trigger */}\n      <div className=\"w-full relative z-20\">\n        <CollapsedSidebarItem\n          icon={icons.normal}\n          activeIcon={icons.active}\n          label=\"Trends\"\n          active={isActive && !selectedChannelId}\n          noBackground={true}\n          onClick={() => {\n            setSelectedChannelId(null);\n            navigate('/trends');\n          }}\n        />\n      </div>\n\n      {/* Single Unified Channel List */}\n      <motion.div\n        layout\n        className=\"relative z-10 w-full flex flex-col items-center overflow-hidden\"\n        initial={false}\n      >\n        <AnimatePresence mode=\"popLayout\">\n          {visibleChannels.length > 0 && (\n            <motion.div\n              layout\n              initial={{ opacity: 0 }}\n              animate={{ opacity: 1 }}\n              exit={{ opacity: 0, transition: { duration: 0.3 } }}\n              className=\"flex flex-col items-center gap-3 pt-4 pb-4 w-full\"\n            >\n              <AnimatePresence mode=\"popLayout\">\n                {visibleChannels.map(channel => {\n                  const isSelected = selectedChannelId === channel.id;\n\n                  const imageClasses = `w-8 h-8 rounded-full object-cover transition-all duration-300\n                                        hover:shadow-[0_0_15px_rgba(255,255,255,0.4)] hover:scale-110\n                                    `;\n\n                  return (\n                    <motion.div\n                      key={channel.id}\n                      layout=\"position\"\n                      initial={{ opacity: 0, scale: 0.8 }}\n                      animate={{ opacity: 1, scale: 1 }}\n                      exit={{ opacity: 0, scale: 0.8 }}\n                      transition={{\n                        opacity: { duration: 0.2 }\n                      }}\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        setSelectedChannelId(channel.id);\n                        navigate('/trends');\n                      }}\n                      className=\"flex flex-col items-center justify-center w-full px-1 relative hover:z-30\"\n                      title={channel.title}\n                    >\n                      <div className={`relative transition-all duration-200 ${isSelected ? 'ring-2 ring-text-primary rounded-full p-[2px]' : ''}`}>\n                        <img\n                          src={channel.avatarUrl}\n                          alt={channel.title}\n                          className={imageClasses}\n                        />\n                      </div>\n                    </motion.div>\n                  );\n                })}\n              </AnimatePresence>\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </motion.div>\n    </div>\n  );\n};\n\nexport const Sidebar: React.FC = () => {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { isSettingsOpen, setSettingsOpen, isSidebarExpanded, sidebarWidth, setSidebarWidth } = useUIStore();\n  const { user } = useAuth();\n  const { currentChannel, setCurrentChannel } = useChannelStore();\n  const { channels: trendChannels, selectedChannelId, setSelectedChannelId } = useTrendStore();\n  const { data: channels, isLoading } = useChannels(user?.uid || '');\n\n  const [isResizing, setIsResizing] = React.useState(false);\n  const [hasScrollbar, setHasScrollbar] = React.useState(false);\n  const scrollRef = React.useRef<HTMLDivElement>(null);\n\n  // Check for scrollbar presence\n  React.useEffect(() => {\n    const checkScrollbar = () => {\n      if (scrollRef.current) {\n        const hasScroll = scrollRef.current.scrollHeight > scrollRef.current.clientHeight;\n        setHasScrollbar(hasScroll);\n      }\n    };\n\n    checkScrollbar();\n    window.addEventListener('resize', checkScrollbar);\n\n    // Create an observer to watch for content changes that might trigger scrollbars\n    const observer = new MutationObserver(checkScrollbar);\n    if (scrollRef.current) {\n      observer.observe(scrollRef.current, { childList: true, subtree: true });\n    }\n\n    return () => {\n      window.removeEventListener('resize', checkScrollbar);\n      observer.disconnect();\n    };\n  }, [isSidebarExpanded, isLoading]);\n\n  // Resize Logic\n  React.useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!isResizing) return;\n\n      // Prevent text selection during drag\n      e.preventDefault();\n\n      // Clamp width between 200px (min) and 600px (max)\n      // Or 40% of screen width? Let's stick to pixel limits first for simplicity.\n      const newWidth = Math.max(200, Math.min(600, e.clientX));\n      setSidebarWidth(newWidth);\n    };\n\n    const handleMouseUp = () => {\n      setIsResizing(false);\n      document.body.style.cursor = 'default';\n      document.body.style.userSelect = '';\n    };\n\n    if (isResizing) {\n      window.addEventListener('mousemove', handleMouseMove);\n      window.addEventListener('mouseup', handleMouseUp);\n      document.body.style.cursor = 'col-resize';\n      document.body.style.userSelect = 'none';\n    }\n\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove);\n      window.removeEventListener('mouseup', handleMouseUp);\n      // Cleanup in case component unmounts while resizing\n      if (isResizing) {\n        document.body.style.cursor = 'default';\n        document.body.style.userSelect = '';\n      }\n    };\n  }, [isResizing, setSidebarWidth]);\n\n  // Select channel logic with persistence\n  React.useEffect(() => {\n    if (isLoading || !channels || channels.length === 0) return;\n\n    if (!currentChannel) {\n      // Try to restore from localStorage\n      const savedChannelId = localStorage.getItem(`lastSelectedChannelId_${user?.uid}`);\n      const savedChannel = savedChannelId ? channels.find(c => c.id === savedChannelId) : null;\n\n      if (savedChannel) {\n        setCurrentChannel(savedChannel);\n      } else {\n        // Fallback to first channel\n        setCurrentChannel(channels[0]);\n      }\n    }\n  }, [channels, isLoading, currentChannel, setCurrentChannel, user?.uid]);\n\n  // Save selection to localStorage\n  React.useEffect(() => {\n    if (user?.uid && currentChannel) {\n      localStorage.setItem(`lastSelectedChannelId_${user.uid}`, currentChannel.id);\n    }\n  }, [currentChannel, user?.uid]);\n\n  // Clear Trends channel selection when navigating away\n  React.useEffect(() => {\n    if (!location.pathname.startsWith('/trends')) {\n      setSelectedChannelId(null);\n    }\n  }, [location.pathname, setSelectedChannelId]);\n\n  const isHome = location.pathname === '/';\n  const isPlaylists = location.pathname.startsWith('/playlists');\n  const isTrends = location.pathname.startsWith('/trends');\n\n  // Icons - normal (outline) and active (filled/bold)\n  const homeIcon = <Home size={24} strokeWidth={1.5} />;\n  const homeActiveIcon = <Home size={24} strokeWidth={2.5} fill=\"currentColor\" />;\n  const playlistsIcon = <List size={24} strokeWidth={1.5} />;\n  const playlistsActiveIcon = <List size={24} strokeWidth={2.5} />;\n  const settingsIcon = <Settings size={24} strokeWidth={1.5} />;\n  const settingsActiveIcon = <Settings size={24} strokeWidth={2.5} />;\n  const trendsIcon = <TrendingUp size={24} strokeWidth={1.5} />;\n  const trendsActiveIcon = <TrendingUp size={24} strokeWidth={2.5} />;\n\n  return (\n    <>\n      <aside\n        style={{ width: isSidebarExpanded ? `${sidebarWidth}px` : undefined }}\n        className={`h-[calc(100vh-56px)] sticky top-14 flex hidden sm:flex flex-shrink-0 relative\n          ${isSidebarExpanded ? 'px-0' : 'w-[72px] px-1 py-1 flex-col'}`}\n      >\n        <div\n          ref={scrollRef}\n          className={`flex-1 w-full flex flex-col overflow-y-auto overflow-x-hidden ${isSidebarExpanded ? 'px-3 py-1' : ''}`}\n        >\n          {isSidebarExpanded ? (\n            // Expanded view - icon left, text right\n            <>\n              <div className=\"flex-1\">\n                <ExpandedSidebarItem\n                  icon={homeIcon}\n                  activeIcon={homeActiveIcon}\n                  label=\"Home\"\n                  active={isHome}\n                  onClick={() => navigate('/')}\n                />\n                <ExpandedSidebarItem\n                  icon={playlistsIcon}\n                  activeIcon={playlistsActiveIcon}\n                  label=\"Playlists\"\n                  active={isPlaylists}\n                  onClick={() => navigate('/playlists')}\n                />\n\n                <TrendsSidebarSection expanded={true} />\n\n                <SidebarDivider />\n              </div>\n\n              <div className=\"border-t border-border pt-2\">\n                <ExpandedSidebarItem\n                  icon={settingsIcon}\n                  activeIcon={settingsActiveIcon}\n                  label=\"Settings\"\n                  active={isSettingsOpen}\n                  onClick={() => setSettingsOpen(true)}\n                />\n              </div>\n            </>\n          ) : (\n            // Collapsed view - icon on top, text below\n            <>\n              <CollapsedSidebarItem\n                icon={homeIcon}\n                activeIcon={homeActiveIcon}\n                label=\"Home\"\n                active={isHome}\n                noBackground={true}\n                onClick={() => navigate('/')}\n              />\n              <CollapsedSidebarItem\n                icon={playlistsIcon}\n                activeIcon={playlistsActiveIcon}\n                label=\"Playlists\"\n                active={isPlaylists}\n                noBackground={true}\n                onClick={() => navigate('/playlists')}\n              />\n              {/* Trends Section with Hover Dropdown */}\n              <div\n                className=\"flex flex-col w-full\"\n                onMouseEnter={() => {\n                  // Preload or ensure logic is ready if needed\n                }}\n              >\n                {/* Main Trends Icon - acts as hover trigger for the group if we wrap it? \n                      Actually, we want the list to stay open when hovering the list too.\n                      So we need a wrapper around both.\n                  */}\n                <TrendsCollapsedGroup\n                  isActive={isTrends && !selectedChannelId}\n                  channels={trendChannels}\n                  selectedChannelId={selectedChannelId}\n                  navigate={navigate}\n                  setSelectedChannelId={setSelectedChannelId}\n                  icons={{\n                    normal: trendsIcon,\n                    active: trendsActiveIcon\n                  }}\n                />\n              </div>\n\n              <div className=\"mt-auto\">\n                <CollapsedSidebarItem\n                  icon={settingsIcon}\n                  activeIcon={settingsActiveIcon}\n                  label=\"Settings\"\n                  active={isSettingsOpen}\n                  onClick={() => setSettingsOpen(true)}\n                />\n              </div>\n            </>\n          )}\n        </div>\n\n        {/* Resize Handle - 1px line at right edge of sidebar. Hit area extends inward only (into sidebar). */}\n        {isSidebarExpanded && (\n          <div\n            className={`absolute top-0 h-full cursor-col-resize z-50 flex items-center justify-center transition-all\n              ${hasScrollbar ? 'w-1 right-0' : 'w-4 right-0'}`}\n            onMouseDown={() => setIsResizing(true)}\n          >\n            <div\n              className={`w-[1px] h-full transition-colors flex-none\n                ${isResizing ? 'bg-blue-500' : 'bg-border'}`}\n            />\n          </div>\n        )}\n      </aside>\n\n      <SettingsModal isOpen={isSettingsOpen} onClose={() => setSettingsOpen(false)} />\n      <AddChannelModal\n        isOpen={useTrendStore((state) => state.isAddChannelModalOpen)}\n        onClose={() => useTrendStore.getState().setAddChannelModalOpen(false)}\n      />\n    </>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/ABTestingModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/components/ShareResultCell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/components/SmartPercentageInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/components/ThumbnailSlot.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/components/TitleInputCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/hooks/useABTesting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/hooks/useABTestingModalState.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'thumbnails'. Either include it or remove the dependency array.","line":125,"column":8,"nodeType":"ArrayExpression","endLine":125,"endColumn":10,"suggestions":[{"desc":"Update the dependencies array to be: [thumbnails]","fix":{"range":[4250,4252],"text":"[thumbnails]"}}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'initialResults.thumbnails', 'initialResults.titles', 'thumbnailVariants', and 'titleVariants'. Either include them or remove the dependency array.","line":91,"column":8,"nodeType":"ArrayExpression","endLine":91,"endColumn":158,"suggestions":[{"desc":"Update the dependencies array to be: [isOpen, initialTab, currentTitle, currentThumbnail, titleVariants, thumbnailVariants, initialResults.titles, initialResults.thumbnails]","fix":{"range":[3076,3226],"text":"[isOpen, initialTab, currentTitle, currentThumbnail, titleVariants, thumbnailVariants, initialResults.titles, initialResults.thumbnails]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":91,"column":61,"nodeType":"CallExpression","endLine":91,"endColumn":90,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":91,"column":92,"nodeType":"CallExpression","endLine":91,"endColumn":125,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":91,"column":127,"nodeType":"CallExpression","endLine":91,"endColumn":157,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useEffect } from 'react';\nimport { getABTestRank, getRankBorderClass } from '../../../../pages/DetailsPage/tabs/Packaging/utils/abTestRank';\n\nexport type ABTestMode = 'title' | 'thumbnail' | 'both';\n\nexport interface ABTestingModalStateProps {\n    isOpen: boolean;\n    initialTab: ABTestMode;\n    currentTitle: string;\n    currentThumbnail: string;\n    titleVariants: string[];\n    thumbnailVariants: string[];\n    initialResults?: {\n        titles: number[];\n        thumbnails: number[];\n    };\n}\n\nexport interface ABTestingSaveData {\n    mode: ABTestMode;\n    titles: string[];\n    thumbnails: string[];\n    results: {\n        titles: number[];\n        thumbnails: number[];\n    };\n    packagingChanged: boolean;\n}\n\n/**\n * Manages all state and logic for ABTestingModal:\n * - Title/thumbnail variants state\n * - Results (watch time share) state\n * - Validation\n * - Change detection\n * - Border color calculation for ranking\n */\nexport function useABTestingModalState({\n    isOpen,\n    initialTab,\n    currentTitle,\n    currentThumbnail,\n    titleVariants,\n    thumbnailVariants,\n    initialResults = { titles: [], thumbnails: [] }\n}: ABTestingModalStateProps) {\n    const [activeTab, setActiveTab] = useState<ABTestMode>(initialTab);\n    const [titles, setTitles] = useState<string[]>(['', '', '']);\n    const [thumbnails, setThumbnails] = useState<string[]>(['', '', '']);\n    const [results, setResults] = useState<{ titles: number[], thumbnails: number[] }>({\n        titles: [0, 0, 0],\n        thumbnails: [0, 0, 0]\n    });\n    const [showResults, setShowResults] = useState(false);\n\n    const fileInputRefs = useRef<(HTMLInputElement | null)[]>([null, null, null]);\n\n    // Initialize with existing data when modal opens\n    useEffect(() => {\n        if (isOpen) {\n            setActiveTab(initialTab);\n\n            // Initialize titles\n            const initTitles = [...titleVariants];\n            if (initTitles.length === 0 && currentTitle) {\n                initTitles[0] = currentTitle;\n            }\n            while (initTitles.length < 3) initTitles.push('');\n            setTitles(initTitles);\n\n            // Initialize thumbnails\n            const initThumbnails = [...thumbnailVariants];\n            if (initThumbnails.length === 0 && currentThumbnail) {\n                initThumbnails[0] = currentThumbnail;\n            }\n            while (initThumbnails.length < 3) initThumbnails.push('');\n            setThumbnails(initThumbnails);\n\n            // Initialize results\n            const newResults = {\n                titles: [...(initialResults.titles || []), 0, 0, 0].slice(0, 3),\n                thumbnails: [...(initialResults.thumbnails || []), 0, 0, 0].slice(0, 3)\n            };\n            setResults(newResults);\n\n            // Show results panel if any are non-zero\n            const hasResults = (initialResults.titles?.some(v => v > 0)) || (initialResults.thumbnails?.some(v => v > 0));\n            setShowResults(!!hasResults);\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [isOpen, initialTab, currentTitle, currentThumbnail, JSON.stringify(titleVariants), JSON.stringify(thumbnailVariants), JSON.stringify(initialResults)]);\n\n    // Handlers\n    const handleTitleChange = (index: number, value: string) => {\n        const newTitles = [...titles];\n        newTitles[index] = value;\n        setTitles(newTitles);\n    };\n\n    const handleThumbnailUpload = (index: number, e: React.ChangeEvent<HTMLInputElement>) => {\n        const file = e.target.files?.[0];\n        if (!file || !file.type.startsWith('image/')) return;\n\n        const objectUrl = URL.createObjectURL(file);\n        const newThumbnails = [...thumbnails];\n\n        // Revoke old URL if it was a blob\n        if (newThumbnails[index].startsWith('blob:')) {\n            URL.revokeObjectURL(newThumbnails[index]);\n        }\n\n        newThumbnails[index] = objectUrl;\n        setThumbnails(newThumbnails);\n    };\n\n    // Cleanup blob URLs on unmount\n    useEffect(() => {\n        return () => {\n            thumbnails.forEach(url => {\n                if (url && url.startsWith('blob:')) {\n                    URL.revokeObjectURL(url);\n                }\n            });\n        };\n    }, []);\n\n    const handleRemoveThumbnail = (index: number) => {\n        const newThumbnails = [...thumbnails];\n        newThumbnails[index] = '';\n        setThumbnails(newThumbnails);\n    };\n\n    const handleResultChange = (type: 'titles' | 'thumbnails', index: number, value: number) => {\n        setResults(prev => {\n            const newArr = [...prev[type]];\n            newArr[index] = value;\n            return { ...prev, [type]: newArr };\n        });\n    };\n\n    // Sync both title and thumbnail results (for \"both\" mode)\n    const handleBothResultChange = (index: number, value: number) => {\n        setResults(prev => {\n            const newTitles = [...prev.titles];\n            const newThumbnails = [...prev.thumbnails];\n            newTitles[index] = value;\n            newThumbnails[index] = value;\n            return { titles: newTitles, thumbnails: newThumbnails };\n        });\n    };\n\n    // Validation\n    const getValidationError = (): string | null => {\n        if (activeTab === 'title' || activeTab === 'both') {\n            const filledTitles = titles.filter(t => t.trim()).length;\n            if (filledTitles < 1) return 'At least 1 title is required';\n        }\n        if (activeTab === 'thumbnail' || activeTab === 'both') {\n            const filledThumbnails = thumbnails.filter(t => t).length;\n            if (filledThumbnails < 1) return 'At least 1 thumbnail is required';\n        }\n        return null;\n    };\n\n    const validationError = getValidationError();\n    const isValid = !validationError;\n\n    // Check if anything has changed from initial state\n    const hasChanges = (() => {\n        const currentValidTitles = titles.filter(t => t.trim());\n        const currentValidThumbnails = thumbnails.filter(t => t);\n\n        // Determine effective initial state (handling pre-filled current values)\n        // If titleVariants is empty but currentTitle exists, the modal pre-fills with currentTitle\n        const effectiveInitialTitles = titleVariants.length > 0\n            ? titleVariants\n            : (currentTitle ? [currentTitle] : []);\n\n        const effectiveInitialThumbnails = thumbnailVariants.length > 0\n            ? thumbnailVariants\n            : (currentThumbnail ? [currentThumbnail] : []);\n\n        // Check titles changed\n        const titlesChanged = JSON.stringify(currentValidTitles) !== JSON.stringify(effectiveInitialTitles);\n\n        // Check thumbnails changed\n        const thumbnailsChanged = JSON.stringify(currentValidThumbnails) !== JSON.stringify(effectiveInitialThumbnails);\n\n        // Check results changed (only count filled slots)\n        // If results are hidden, we treat current results as all zeros\n        const currentResults = showResults ? {\n            titles: results.titles.slice(0, currentValidTitles.length),\n            thumbnails: results.thumbnails.slice(0, currentValidThumbnails.length)\n        } : {\n            titles: currentValidTitles.map(() => 0),\n            thumbnails: currentValidThumbnails.map(() => 0)\n        };\n\n        // Normalize initial results to match effective initial length\n        const effectiveInitialResults = {\n            titles: (initialResults.titles || []).slice(0, effectiveInitialTitles.length),\n            thumbnails: (initialResults.thumbnails || []).slice(0, effectiveInitialThumbnails.length)\n        };\n\n        // Pad with zeros if needed\n        while (effectiveInitialResults.titles.length < effectiveInitialTitles.length) {\n            effectiveInitialResults.titles.push(0);\n        }\n        while (effectiveInitialResults.thumbnails.length < effectiveInitialThumbnails.length) {\n            effectiveInitialResults.thumbnails.push(0);\n        }\n\n        const resultsChanged = JSON.stringify(currentResults) !== JSON.stringify(effectiveInitialResults);\n\n        return titlesChanged || thumbnailsChanged || resultsChanged;\n    })();\n\n    // Can save only if valid AND something changed\n    const canSave = isValid && hasChanges;\n\n    // Calculate max percentage available for a slot\n    const calcMax = (arr: number[], currentIndex: number) => {\n        const othersSum = arr.reduce((sum, val, idx) => {\n            return idx === currentIndex ? sum : sum + (val || 0);\n        }, 0);\n        // Fix floating point precision: 100 - 49.4 should be 50.6, not 50.59999..\n        return Math.max(0, Number((100 - othersSum).toFixed(1)));\n    };\n\n    // Get border color based on ranking\n    const getBorderColor = (value: number, allValues: number[], hasContent: boolean) => {\n        if (!showResults || !isValid || !hasContent) return 'border-[#5F5F5F]';\n\n        const rank = getABTestRank(value, allValues);\n        return getRankBorderClass(rank);\n    };\n\n    // Prepare save data\n    const prepareSaveData = (): ABTestingSaveData => {\n        const currentValidTitles = titles.filter(t => t.trim());\n        const currentValidThumbnails = thumbnails.filter(t => t);\n\n        // Determine if packaging content changed (not just results)\n        let packagingChanged = false;\n        if (activeTab === 'title') {\n            packagingChanged = JSON.stringify(currentValidTitles) !== JSON.stringify(titleVariants);\n        } else if (activeTab === 'thumbnail') {\n            packagingChanged = JSON.stringify(currentValidThumbnails) !== JSON.stringify(thumbnailVariants);\n        } else { // both\n            const titlesChange = JSON.stringify(currentValidTitles) !== JSON.stringify(titleVariants);\n            const thumbnailsChange = JSON.stringify(currentValidThumbnails) !== JSON.stringify(thumbnailVariants);\n            packagingChanged = titlesChange || thumbnailsChange;\n        }\n\n        /**\n         * BUSINESS LOGIC: Mode-Based Data Isolation\n         * ------------------------------------------\n         * When saving, we only include data relevant to the selected test mode:\n         * \n         * - 'title' mode:     titles populated, thumbnails = []\n         * - 'thumbnail' mode: thumbnails populated, titles = []\n         * - 'both' mode:      both populated\n         * \n         * This prevents cross-contamination where selecting \"title only\" test\n         * would inadvertently save the current thumbnail as a test variant.\n         * Without this isolation, ThumbnailSection would incorrectly show\n         * A/B test UI (split view, \"Test\" badge) for title-only tests.\n         * \n         * The >= 2 threshold in ThumbnailSection relies on this behavior:\n         * - Empty array (length 0) = no thumbnail test\n         * - Single item (length 1) = would be ambiguous, but we prevent this\n         * - Two+ items (length >= 2) = real thumbnail A/B test\n         */\n        const saveTitles = activeTab === 'thumbnail' ? [] : currentValidTitles;\n        const saveThumbnails = activeTab === 'title' ? [] : currentValidThumbnails;\n\n        return {\n            mode: activeTab,\n            titles: saveTitles,\n            thumbnails: saveThumbnails,\n            results: {\n                titles: showResults ? results.titles.slice(0, saveTitles.length) : saveTitles.map(() => 0),\n                thumbnails: showResults ? results.thumbnails.slice(0, saveThumbnails.length) : saveThumbnails.map(() => 0)\n            },\n            packagingChanged\n        };\n    };\n\n    // Get save button text based on state\n    const getSaveButtonText = () => {\n        if (!isValid) return 'Set test';\n        if (!hasChanges) return 'Set test';\n\n        const hasExistingTitleTest = titleVariants.length >= 2;\n        const hasExistingThumbnailTest = thumbnailVariants.length >= 2;\n\n        const currentValidTitles = titles.filter(t => t.trim());\n        const currentValidThumbnails = thumbnails.filter(t => t);\n\n        let isNewTest = false;\n\n        if (activeTab === 'title') {\n            // It's a \"Set Test\" action ONLY if we are creating a test (2+ variants) \n            // where one didn't exist before.\n            isNewTest = !hasExistingTitleTest && currentValidTitles.length >= 2;\n        } else if (activeTab === 'thumbnail') {\n            isNewTest = !hasExistingThumbnailTest && currentValidThumbnails.length >= 2;\n        } else { // both\n            // If we are upgrading EITHER part to a test (2+ vars) where it wasn't before\n            const creatingTitleTest = !hasExistingTitleTest && currentValidTitles.length >= 2;\n            const creatingThumbnailTest = !hasExistingThumbnailTest && currentValidThumbnails.length >= 2;\n            isNewTest = creatingTitleTest || creatingThumbnailTest;\n        }\n\n        // If results changed (even if hidden/cleared), and a test already exists, it should be \"Save\"\n        const hasExistingResults = (initialResults.titles?.some(v => v > 0)) || (initialResults.thumbnails?.some(v => v > 0));\n        if (hasExistingResults && !isNewTest) return 'Save';\n\n        return isNewTest ? 'Set test' : 'Save';\n    };\n\n    return {\n        // State\n        activeTab,\n        setActiveTab,\n        titles,\n        thumbnails,\n        results,\n        showResults,\n        setShowResults,\n        fileInputRefs,\n\n        // Validation\n        validationError,\n        isValid,\n        hasChanges,\n        canSave,\n\n        // Handlers\n        handleTitleChange,\n        handleThumbnailUpload,\n        handleRemoveThumbnail,\n        handleResultChange,\n        handleBothResultChange,\n\n        // Utilities\n        calcMax,\n        getBorderColor,\n        prepareSaveData,\n        getSaveButtonText\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ABTesting/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/AddContentMenu.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2407,2410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2407,2410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_shouldClose' is defined but never used.","line":200,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_expectedRevision' is defined but never used.","line":200,"column":61,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":78}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useLayoutEffect } from 'react';\nimport { Plus, Youtube, Upload, ListPlus } from 'lucide-react';\nimport { createPortal } from 'react-dom';\nimport { AddYouTubeVideoModal } from '../../features/Video/Modals/AddYouTubeVideoModal';\nimport { AddCustomVideoModal } from '../../features/Video/Modals/AddCustomVideo/AddCustomVideoModal';\nimport { CreatePlaylistModal } from '../../features/Playlist/CreatePlaylistModal';\nimport { useVideos } from '../../core/hooks/useVideos';\nimport { useSettings } from '../../core/hooks/useSettings';\nimport type { VideoDetails } from '../../core/utils/youtubeApi';\n\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\n\ninterface AddContentMenuProps {\n    showVideo?: boolean;\n    showPlaylist?: boolean;\n    directPlaylist?: boolean;\n    icon?: React.ReactNode;\n    isOpen?: boolean;\n    onOpenChange?: (isOpen: boolean) => void;\n}\n\nexport const AddContentMenu: React.FC<AddContentMenuProps> = ({\n    showVideo = true,\n    showPlaylist = true,\n    directPlaylist = false,\n    icon,\n    isOpen: controlledIsOpen,\n    onOpenChange\n}) => {\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { addCustomVideo, cloneVideo } = useVideos(user?.uid || '', currentChannel?.id || '');\n    const { uploadDefaults, cloneSettings } = useSettings();\n\n    // State\n    const [internalIsOpen, setInternalIsOpen] = useState(false);\n    const [activeModal, setActiveModal] = useState<'youtube' | 'custom' | 'playlist' | null>(null);\n    const [customVideoInitialData, setCustomVideoInitialData] = useState<VideoDetails | undefined>(undefined);\n    const [position, setPosition] = useState<{ top: number; right: number } | null>(null);\n\n    // Refs\n    const buttonRef = useRef<HTMLButtonElement>(null);\n    const dropdownRef = useRef<HTMLDivElement>(null);\n\n    // Derived State\n    const isControlled = controlledIsOpen !== undefined;\n    const isOpen = isControlled ? controlledIsOpen : internalIsOpen;\n\n    // Handlers\n    const setIsOpen = React.useCallback((value: boolean) => {\n        if (onOpenChange) {\n            onOpenChange(value);\n        }\n        if (!isControlled) {\n            setInternalIsOpen(value);\n        }\n    }, [onOpenChange, isControlled]);\n\n    const handleCloneVideo = async (originalVideo: VideoDetails, version: any) => {\n        const duration = cloneSettings?.cloneDurationSeconds;\n        console.warn('DEBUG: Cloning video with duration (s):', duration);\n        await cloneVideo({\n            originalVideo,\n            coverVersion: version,\n            cloneDurationSeconds: duration || 3600\n        });\n    };\n\n    const handleOptionClick = (modal: 'youtube' | 'custom' | 'playlist') => {\n        if (modal === 'custom') {\n            const defaults: Partial<VideoDetails> = {\n                title: uploadDefaults.title || '',\n                description: uploadDefaults.description || '',\n                tags: uploadDefaults.tags || []\n            };\n            setCustomVideoInitialData(defaults as VideoDetails);\n        } else {\n            setCustomVideoInitialData(undefined);\n        }\n        setActiveModal(modal);\n        setIsOpen(false);\n    };\n\n    const handleButtonClick = () => {\n        if (directPlaylist) {\n            setActiveModal('playlist');\n        } else {\n            setIsOpen(!isOpen);\n        }\n    };\n\n    // Effects\n    useLayoutEffect(() => {\n        if (isOpen && buttonRef.current) {\n            const rect = buttonRef.current.getBoundingClientRect();\n            setPosition({\n                top: rect.bottom + 8,\n                right: window.innerWidth - rect.right\n            });\n        } else {\n            setPosition(null);\n        }\n    }, [isOpen]);\n\n    useEffect(() => {\n        const handleClickOutside = (event: MouseEvent) => {\n            if (\n                dropdownRef.current &&\n                !dropdownRef.current.contains(event.target as Node) &&\n                buttonRef.current &&\n                !buttonRef.current.contains(event.target as Node)\n            ) {\n                setIsOpen(false);\n            }\n        };\n\n        if (isOpen) {\n            document.addEventListener('mousedown', handleClickOutside);\n            window.addEventListener('scroll', () => setIsOpen(false), true);\n            window.addEventListener('resize', () => setIsOpen(false));\n        }\n\n        return () => {\n            document.removeEventListener('mousedown', handleClickOutside);\n            window.removeEventListener('scroll', () => setIsOpen(false), true);\n            window.removeEventListener('resize', () => setIsOpen(false));\n        };\n    }, [isOpen, setIsOpen]);\n\n    return (\n        <>\n            <button\n                ref={buttonRef}\n                className=\"w-10 h-10 rounded-full flex items-center justify-center transition-colors border-none cursor-pointer relative flex-shrink-0 bg-transparent text-text-primary hover:bg-hover-bg\"\n                onClick={handleButtonClick}\n                title={directPlaylist ? \"Create Playlist\" : \"Add Content\"}\n            >\n                {icon ? icon : (directPlaylist ? <ListPlus size={24} /> : <Plus size={24} />)}\n            </button>\n\n            {isOpen && position && !directPlaylist && createPortal(\n                <div\n                    ref={dropdownRef}\n                    className=\"animate-scale-in bg-bg-secondary border border-border rounded-xl shadow-2xl z-[1000] min-w-[220px] overflow-hidden flex flex-col\"\n                    style={{\n                        position: 'fixed',\n                        top: position.top,\n                        right: position.right,\n                    }}\n                >\n                    <div className=\"px-4 py-3 border-b border-border flex items-center justify-between bg-bg-secondary/95 backdrop-blur sticky top-0 z-10 flex-shrink-0\">\n                        <h3 className=\"font-medium text-text-primary m-0 text-base\">Create</h3>\n                    </div>\n                    <div className=\"p-2\">\n\n                        {showVideo && (\n                            <>\n                                <button\n                                    onClick={() => handleOptionClick('youtube')}\n                                    className=\"w-full text-left px-3 py-2.5 rounded-lg text-sm font-medium flex items-center gap-3 transition-colors border-none cursor-pointer text-text-primary hover:bg-hover-bg bg-transparent\"\n                                >\n                                    <Youtube size={18} />\n                                    Add YouTube Video\n                                </button>\n\n                                <button\n                                    onClick={() => handleOptionClick('custom')}\n                                    className=\"w-full text-left px-3 py-2.5 rounded-lg text-sm font-medium flex items-center gap-3 transition-colors border-none cursor-pointer text-text-primary hover:bg-hover-bg bg-transparent\"\n                                >\n                                    <Upload size={18} />\n                                    Create Custom Video\n                                </button>\n                            </>\n                        )}\n\n                        {showPlaylist && (\n                            <button\n                                onClick={() => handleOptionClick('playlist')}\n                                className=\"w-full text-left px-3 py-2.5 rounded-lg text-sm font-medium flex items-center gap-3 transition-colors border-none cursor-pointer text-text-primary hover:bg-hover-bg bg-transparent\"\n                            >\n                                <ListPlus size={18} />\n                                Create Playlist\n                            </button>\n                        )}\n                    </div>\n                </div>,\n                document.body\n            )}\n\n            <AddYouTubeVideoModal\n                isOpen={activeModal === 'youtube'}\n                onClose={() => setActiveModal(null)}\n            />\n\n            {activeModal === 'custom' && (\n                <AddCustomVideoModal\n                    isOpen={true}\n                    onClose={() => setActiveModal(null)}\n                    onSave={async (videoData, _shouldClose, _expectedRevision) => {\n                        if (user && currentChannel) {\n                            return await addCustomVideo(videoData);\n                        }\n                    }}\n                    onClone={handleCloneVideo}\n                    initialData={customVideoInitialData}\n                />\n            )}\n\n            <CreatePlaylistModal\n                isOpen={activeModal === 'playlist'}\n                onClose={() => setActiveModal(null)}\n            />\n        </>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/ConfirmationModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/CustomSelect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Dropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/DropdownMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterButton.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3507,3510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3507,3510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3692,3695],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3692,3695],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\nimport { Filter, ChevronRight, X, Calendar, Clock, Eye, Type, List, MonitorPlay, ChevronLeft } from 'lucide-react';\nimport { createPortal } from 'react-dom';\nimport { useFilterStore, type FilterType, type FilterOperator } from '../../core/stores/filterStore';\nimport { FilterInputTitle } from './FilterInputs/FilterInputTitle';\nimport { FilterInputNumeric } from './FilterInputs/FilterInputNumeric';\nimport { FilterInputDate } from './FilterInputs/FilterInputDate';\nimport { FilterInputList } from './FilterInputs/FilterInputList';\nimport { useVideos } from '../../core/hooks/useVideos';\nimport { usePlaylists } from '../../core/hooks/usePlaylists';\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\n\nexport const FilterButton: React.FC = () => {\n    const [isOpen, setIsOpen] = useState(false);\n    const buttonRef = useRef<HTMLButtonElement>(null);\n    const dropdownRef = useRef<HTMLDivElement>(null);\n    const [position, setPosition] = useState<{ top: number; right: number } | null>(null);\n\n    // State for Navigation (Main vs Submenu)\n    const [activeView, setActiveView] = useState<FilterType | 'main'>('main');\n\n    const { addFilter, activeFilters } = useFilterStore();\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n\n    // Data hooks for lists\n    const { videos } = useVideos(user?.uid || '', currentChannel?.id || '');\n    const { playlists } = usePlaylists(user?.uid || '', currentChannel?.id || '');\n\n    // Prepare list options\n    const channelOptions = Array.from(new Set(videos.map(v => v.channelTitle))).map(name => ({\n        id: name,\n        label: name\n    })).sort((a, b) => (a.label || '').localeCompare(b.label || ''));\n\n    const playlistOptions = playlists.map(p => ({\n        id: p.id,\n        label: p.name,\n        description: `${p.videoIds.length} videos`\n    }));\n\n\n    useEffect(() => {\n        if (isOpen && buttonRef.current) {\n            const rect = buttonRef.current.getBoundingClientRect();\n            setPosition({\n                top: rect.bottom + 8,\n                right: window.innerWidth - rect.right\n            });\n        } else {\n            // Reset view when closed\n            const timeout = setTimeout(() => setActiveView('main'), 200);\n            return () => clearTimeout(timeout);\n        }\n    }, [isOpen]);\n\n    useEffect(() => {\n        const handleClickOutside = (event: MouseEvent) => {\n            // IGNORE clicks inside the CustomSelect dropdown portal\n            const target = event.target as Element;\n            if (target.closest('#custom-select-dropdown')) {\n                return;\n            }\n\n            if (\n                dropdownRef.current &&\n                !dropdownRef.current.contains(event.target as Node) &&\n                buttonRef.current &&\n                !buttonRef.current.contains(event.target as Node)\n            ) {\n                setIsOpen(false);\n            }\n        };\n\n        if (isOpen) {\n            document.addEventListener('mousedown', handleClickOutside);\n            window.addEventListener('resize', () => setIsOpen(false));\n        }\n\n        return () => {\n            document.removeEventListener('mousedown', handleClickOutside);\n            window.removeEventListener('resize', () => setIsOpen(false));\n        };\n    }, [isOpen]);\n\n    const handleAddFilter = (type: FilterType, operator: FilterOperator, value: any, label: string) => {\n        addFilter({ type, operator, value, label });\n        setIsOpen(false);\n    };\n\n    const filterTypes: { type: FilterType; label: string; icon: React.FC<any> }[] = [\n        { type: 'channel', label: 'Channel', icon: MonitorPlay },\n        { type: 'playlist', label: 'Playlist', icon: List },\n        { type: 'title', label: 'Title', icon: Type },\n        { type: 'duration', label: 'Duration', icon: Clock },\n        { type: 'date', label: 'Publish Date', icon: Calendar },\n        { type: 'views', label: 'Views', icon: Eye },\n        { type: 'videoType', label: 'Video Type', icon: MonitorPlay }, // Reusing icon for now\n    ];\n\n    const getTitleForView = (view: FilterType) => {\n        const match = filterTypes.find(t => t.type === view);\n        return match ? match.label : 'Filter';\n    };\n\n    return (\n        <>\n            <button\n                ref={buttonRef}\n                className={`w-[34px] h-[34px] rounded-full flex items-center justify-center transition-colors border-none cursor-pointer relative flex-shrink-0 ${isOpen ? 'bg-text-primary text-bg-primary' : 'bg-transparent text-text-primary hover:bg-hover-bg'}`}\n                onClick={() => setIsOpen(!isOpen)}\n                title=\"Filter\"\n            >\n                <Filter size={20} />\n                {activeFilters.length > 0 && (\n                    <span className=\"absolute top-0 right-0 w-3 h-3 bg-red-500 rounded-full border-2 border-bg-primary\" />\n                )}\n            </button>\n\n            {isOpen && position && createPortal(\n                <div\n                    ref={dropdownRef}\n                    className=\"fixed z-[1000] bg-[#1F1F1F] rounded-xl shadow-2xl overflow-hidden animate-scale-in flex flex-col\"\n                    style={{\n                        top: position.top,\n\n                        right: position.right,\n                        width: activeView === 'date' ? '288px' : 'auto'\n                    }}\n                >\n                    {/* Header for Submenus */}\n                    {/* Header for Submenus */}\n                    {activeView !== 'main' && (\n                        <div className=\"flex items-center justify-between px-2 py-2 border-b border-[#333333]\">\n                            <button\n                                onClick={() => setActiveView('main')}\n                                className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                                <ChevronLeft size={20} />\n                            </button>\n                            <span className=\"text-sm font-bold text-text-primary\">{getTitleForView(activeView)}</span>\n                            <button\n                                onClick={() => setIsOpen(false)}\n                                className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                                <X size={20} />\n                            </button>\n                        </div>\n                    )}\n\n                    {/* Content Area */}\n                    <div className=\"flex flex-col\">\n                        {activeView === 'main' ? (\n                            <div className=\"py-2\">\n                                {filterTypes.map(({ type, label, icon: Icon }) => (\n                                    <button\n                                        key={type}\n                                        onClick={() => setActiveView(type)}\n                                        className=\"w-full text-left px-4 py-3 text-sm font-medium flex items-center justify-between gap-8 transition-colors border-none cursor-pointer text-text-primary hover:bg-[#161616] bg-transparent\"\n                                    >\n                                        <div className=\"flex items-center gap-3\">\n                                            <Icon size={18} className=\"text-text-secondary\" />\n                                            {label}\n                                        </div>\n                                        <ChevronRight size={16} className=\"text-text-secondary\" />\n                                    </button>\n                                ))}\n                            </div>\n                        ) : (\n                            <div className=\"animate-fade-in\">\n                                {activeView === 'title' && (\n                                    <FilterInputTitle\n                                        value=\"\"\n                                        onApply={(val) => handleAddFilter('title', 'contains', val, `Title: ${val}`)}\n                                    />\n                                )}\n                                {activeView === 'views' && (\n                                    <FilterInputNumeric\n                                        onApply={(op, val, max) => {\n                                            const opLabel = op === 'between' ? `${val}-${max}` : `${op === 'gte' ? '>=' : op === 'lte' ? '<=' : op === 'gt' ? '>' : op === 'lt' ? '<' : '='} ${val}`;\n                                            handleAddFilter('views', op, op === 'between' ? [val, max] : val, `Views ${opLabel}`);\n                                        }}\n                                    />\n                                )}\n                                {activeView === 'duration' && (\n                                    <FilterInputNumeric\n                                        isDuration\n                                        onApply={(op, val, max) => {\n                                            const opLabel = op === 'between' ? `${val}-${max}m` : `${op} ${val}m`;\n                                            handleAddFilter('duration', op, op === 'between' ? [val, max] : val, `Duration ${opLabel}`);\n                                        }}\n                                    />\n                                )}\n                                {activeView === 'date' && (\n                                    <FilterInputDate\n                                        onApply={(start, end) => {\n                                            const startStr = new Date(start).toLocaleDateString();\n                                            const endStr = new Date(end).toLocaleDateString();\n                                            const label = start === end ? `Date: ${startStr}` : `Date: ${startStr} - ${endStr}`;\n                                            handleAddFilter('date', 'between', [start, end], label);\n                                        }}\n                                        onClose={() => setIsOpen(false)}\n                                    />\n                                )}\n                                {activeView === 'channel' && (\n                                    <FilterInputList\n                                        options={channelOptions}\n                                        placeholder=\"Search channels\"\n                                        onApply={(ids) => handleAddFilter('channel', 'equals', ids, `Channel: ${ids.length > 1 ? `${ids.length} Selected` : ids[0]}`)}\n                                    />\n                                )}\n                                {activeView === 'playlist' && (\n                                    <FilterInputList\n                                        options={playlistOptions}\n                                        placeholder=\"Search playlists\"\n                                        onApply={(ids) => {\n                                            const names = ids.map(id => playlists.find(p => p.id === id)?.name || id);\n                                            handleAddFilter('playlist', 'equals', ids, `Playlist: ${ids.length > 1 ? `${ids.length} Selected` : names[0]}`);\n                                        }}\n                                    />\n                                )}\n                                {activeView === 'videoType' && (\n                                    <FilterInputList\n                                        options={[\n                                            { id: 'custom_video', label: 'Custom Video' },\n                                            { id: 'published_custom_video', label: 'Published Custom Video' },\n                                            { id: 'other_youtube', label: 'Other YouTube Video' }\n                                        ]}\n                                        placeholder=\"Search types\"\n                                        onApply={(ids) => {\n                                            const labelMap: Record<string, string> = {\n                                                'custom_video': 'Custom Video',\n                                                'published_custom_video': 'Published Custom',\n                                                'other_youtube': 'Other YouTube'\n                                            };\n                                            const labels = ids.map(id => labelMap[id] || id);\n                                            handleAddFilter('videoType', 'equals', ids, `Type: ${ids.length > 1 ? `${ids.length} Selected` : labels[0]}`);\n                                        }}\n                                    />\n                                )}\n                            </div>\n                        )}\n                    </div>\n                </div>,\n                document.body\n            )}\n        </>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/FilterInputDate.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/FilterInputList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/FilterInputNumeric.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/FilterInputPercentile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/FilterInputTitle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/SmartDurationInput.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'str' is assigned a value but never used.","line":44,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":20},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/SmartDurationInput.tsx:78:13\n  76 |         const currentSecondsFromDigits = parseDigitsToSeconds(digits);\n  77 |         if (value !== undefined && value !== currentSecondsFromDigits) {\n> 78 |             setDigits(secondsToDigits(value));\n     |             ^^^^^^^^^ Avoid calling setState() directly within an effect\n  79 |         }\n  80 |         if (value === undefined || value === 0) {\n  81 |             // Check if we should clear","line":78,"column":13,"nodeType":null,"endLine":78,"endColumn":22},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'digits'. Either include it or remove the dependency array.","line":83,"column":8,"nodeType":"ArrayExpression","endLine":83,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [digits, value]","fix":{"range":[3105,3112],"text":"[digits, value]"}}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\n\ninterface SmartDurationInputProps {\n    value?: number; // Value in seconds\n    onChange: (seconds: number | undefined) => void;\n    placeholder?: string;\n    autoFocus?: boolean;\n    className?: string; // Additional classes for the input\n}\n\nexport const SmartDurationInput: React.FC<SmartDurationInputProps> = ({\n    value,\n    onChange,\n    placeholder = 'Duration',\n    autoFocus,\n    className\n}) => {\n    // We maintain rawDigits as the source of truth for user input.\n    // e.g. \"2\" gives \"00:02\"\n    // \"20\" gives \"00:20\"\n    // \"222\" gives \"02:22\"\n    // \"222222\" -> \"22:22:22\"\n\n    // We also need to construct initial digits from `value` (seconds) if present.\n    const secondsToDigits = (secs: number | undefined): string => {\n        if (secs === undefined || isNaN(secs) || secs === 0) return '';\n        const h = Math.floor(secs / 3600);\n        const m = Math.floor((secs % 3600) / 60);\n        const s = secs % 60;\n\n        let str = '';\n        if (h > 0) {\n            str += h.toString();\n            str += m.toString().padStart(2, '0');\n            str += s.toString().padStart(2, '0');\n        } else {\n            // If m > 0, we can omit H? \n            // Logic says if user enters 222 -> 02:22.\n            // If we have seconds 142 (2:22) -> convert back to 222\n            if (m > 0) {\n                str += m.toString(); // e.g. 2\n                str += s.toString().padStart(2, '0'); // 22\n            } else {\n                str += s.toString();\n            }\n        }\n        // This is imperfect because reversing standard format to \"what user typed\" is lossy for leading zeros logic.\n        // But for display we can just stick to standard formatting if not editing?\n        // Let's try to maintain a consistent formatted view. \n        // Better: Convert seconds to HHMMSS string and strip leading zeros?\n\n        // Actually, let's keep it simple: If prop updates, we overwrite our state.\n\n        const hStr = h > 0 ? h.toString() : '';\n        const mStr = m.toString().padStart(2, '0');\n        const sStr = s.toString().padStart(2, '0');\n\n        if (h > 0) return `${hStr}${mStr}${sStr}`;\n        if (m > 0) return `${parseInt(mStr)}${sStr}`;\n        return parseInt(sStr).toString();\n    };\n\n    function parseDigitsToSeconds(d: string): number {\n        if (!d) return 0;\n        const padded = d.padStart(6, '0');\n        const h = parseInt(padded.slice(0, -4));\n        const m = parseInt(padded.slice(-4, -2));\n        const s = parseInt(padded.slice(-2));\n        return h * 3600 + m * 60 + s;\n    }\n\n    const [digits, setDigits] = useState<string>(secondsToDigits(value));\n\n    useEffect(() => {\n        // Sync with props if they change externally (and aren't result of our own change)\n        const currentSecondsFromDigits = parseDigitsToSeconds(digits);\n        if (value !== undefined && value !== currentSecondsFromDigits) {\n            setDigits(secondsToDigits(value));\n        }\n        if (value === undefined || value === 0) {\n            // Check if we should clear\n        }\n    }, [value]);\n\n\n\n    // Formatting logic for display (00:00 style) while typing\n    const formatDisplay = (d: string): string => {\n        if (!d) return '';\n        const val = parseInt(d, 10);\n        if (isNaN(val) || val === 0) return '';\n\n        // Ensure strictly clean digits for length check just in case, though state should be clean\n        const clean = val.toString();\n\n        // 1-2 digits: S or SS -> 00:SS\n        // e.g. 2 -> 00:02\n        // e.g. 20 -> 00:20\n        if (clean.length <= 2) {\n            return `00:${clean.padStart(2, '0')}`;\n        }\n\n        // 3-4 digits: M:SS or MM:SS\n        // e.g. 202 -> 02:02\n        // e.g. 2022 -> 20:22\n        if (clean.length <= 4) {\n            const s = clean.slice(-2);\n            const m = clean.slice(0, -2).padStart(2, '0');\n            return `${m}:${s}`;\n        }\n\n        // 5-6 digits: H:MM:SS or HH:MM:SS\n        // e.g. 20222 -> 2:02:22\n        // e.g. 120222 -> 12:02:22\n        if (clean.length <= 6) {\n            const s = clean.slice(-2);\n            const m = clean.slice(-4, -2);\n            const h = clean.slice(0, -4).padStart(2, '0');\n            return `${h}:${m}:${s}`;\n        }\n\n        return clean;\n    }\n\n    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        const raw = e.target.value;\n        // Strip non-digits\n        let newDigits = raw.replace(/\\D/g, '');\n\n        // Strip leading zeros immediately to maintain the \"push\" feel\n        // e.g. user sees \"00:02\", types 0 -> \"00020\" -> strip -> \"20\"\n        newDigits = newDigits.replace(/^0+/, '');\n\n        // Cap length to reasonable (6 digits for HHMMSS)\n        if (newDigits.length > 6) return;\n\n        // Check 24 hour limit (245959)\n        if (newDigits.length === 6 && parseInt(newDigits) > 245959) return;\n\n        setDigits(newDigits);\n\n        // Convert digits to total seconds for the parent callback\n        const seconds = parseDigitsToSeconds(newDigits);\n        onChange(seconds > 0 ? seconds : undefined);\n    };\n\n    return (\n        <input\n            type=\"text\"\n            className={`w-full bg-transparent border-b border-[#737373] focus:border-[#111111] py-1 text-white outline-none transition-colors text-base placeholder-[#555555] ${className}`}\n            placeholder={placeholder}\n            value={formatDisplay(digits)}\n            onChange={handleChange}\n            autoFocus={autoFocus}\n            inputMode=\"numeric\"\n        />\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/SmartNumericInput.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterInputs/SmartNumericInput.tsx:24:13\n  22 |     useEffect(() => {\n  23 |         if (value === '' || value === undefined || value === null) {\n> 24 |             setDisplayValue('');\n     |             ^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  25 |         } else {\n  26 |             // Format existing number with commas\n  27 |             const num = Number(value);","line":24,"column":13,"nodeType":null,"endLine":24,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\n\ninterface SmartNumericInputProps {\n    value: number | string;\n    onChange: (value: string | number) => void;\n    placeholder?: string;\n    autoFocus?: boolean;\n    className?: string;\n}\n\nexport const SmartNumericInput: React.FC<SmartNumericInputProps> = ({\n    value,\n    onChange,\n    placeholder,\n    autoFocus,\n    className = ''\n}) => {\n    // Internal state stores the formatted string\n    const [displayValue, setDisplayValue] = useState('');\n\n    // Update display when external value changes\n    useEffect(() => {\n        if (value === '' || value === undefined || value === null) {\n            setDisplayValue('');\n        } else {\n            // Format existing number with commas\n            const num = Number(value);\n            if (!isNaN(num)) {\n                setDisplayValue(num.toLocaleString('en-US'));\n            } else {\n                setDisplayValue(String(value));\n            }\n        }\n    }, [value]);\n\n    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        const inputVal = e.target.value;\n\n        // Allow clearing\n        if (inputVal === '') {\n            setDisplayValue('');\n            onChange('');\n            return;\n        }\n\n        // Remove commas to get raw number string (e.g. \"1,234\" -> \"1234\")\n        const rawValue = inputVal.replace(/,/g, '');\n\n        // Validate: must be digits only\n        if (/^\\d*$/.test(rawValue)) {\n            const num = Number(rawValue);\n\n            // Update display with formatted version\n            // Note: We use the raw inputVal for the *current* change to avoid\n            // cursor jumping issues if we re-format aggressively, \n            // BUT for this specific \"Smart\" requirement, we usually want auto-formatting.\n            // Let's formatting on the fly.\n\n            const formatted = num.toLocaleString('en-US');\n            setDisplayValue(formatted);\n            onChange(num);\n        }\n    };\n\n    return (\n        <input\n            type=\"text\"\n            className={`bg-transparent border-b border-[#737373] focus:border-[#111111] py-1 text-white outline-none transition-colors text-base text-center placeholder-[#555555] ${className}`}\n            placeholder={placeholder}\n            value={displayValue}\n            onChange={handleChange}\n            autoFocus={autoFocus}\n            inputMode=\"numeric\"\n        />\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FilterSortDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FloatingBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/FloatingDropdownPortal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/GlobalMiniPlayer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/PortalTooltip.tsx","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `estimatedHeight`, but the source dependencies were [align, side, anchorRect]. Inferred different dependency than source.\n\n/Users/muramets/Documents/youtube-interface/src/components/Shared/PortalTooltip.tsx:57:40\n   55 |     const positionRaf = useRef<number | null>(null);\n   56 |\n>  57 |     const updatePosition = useCallback(() => {\n      |                                        ^^^^^^^\n>  58 |         if (positionRaf.current) return;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  59 |\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 173 |         });\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 174 |     }, [align, side, anchorRect]);\n      | ^^^^^^ Could not preserve existing manual memoization\n  175 |\n  176 |     const showTooltip = useCallback(() => {\n  177 |         updatePosition();","line":57,"column":40,"nodeType":null,"endLine":174,"endColumn":6},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'estimatedHeight'. Either include it or remove the dependency array.","line":174,"column":8,"nodeType":"ArrayExpression","endLine":174,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [anchorRect, align, side, estimatedHeight]","fix":{"range":[7941,7966],"text":"[anchorRect, align, side, estimatedHeight]"}}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/components/Shared/PortalTooltip.tsx:204:13\n  202 |     useEffect(() => {\n  203 |         if (disabled) {\n> 204 |             hideTooltip();\n      |             ^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  205 |             return;\n  206 |         }\n  207 |","line":204,"column":13,"nodeType":null,"endLine":204,"endColumn":24}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport { createPortal } from 'react-dom';\n\ninterface PortalTooltipProps {\n    content: React.ReactNode;\n    children?: React.ReactElement; // Make optional if using anchorRect\n    anchorRect?: { top: number; left: number; width: number; height: number; right?: number; bottom?: number };\n    align?: 'left' | 'center' | 'right';\n    side?: 'bottom' | 'left' | 'right' | 'top';\n    onOpenChange?: (isOpen: boolean) => void;\n    variant?: 'default' | 'glass';\n    className?: string;\n    triggerClassName?: string;\n    enterDelay?: number;\n    forceOpen?: boolean;\n    noAnimation?: boolean;\n    title?: string;\n    estimatedHeight?: number;\n    fixedWidth?: number;\n    disabled?: boolean;\n}\n\nexport const PortalTooltip: React.FC<PortalTooltipProps> = ({\n    content,\n    children,\n    anchorRect,\n    align = 'left',\n    side = 'bottom',\n    onOpenChange,\n    variant = 'default',\n    className = '',\n    triggerClassName = '',\n    enterDelay = 0,\n    forceOpen,\n    noAnimation = false,\n    title,\n    estimatedHeight = 80,\n    fixedWidth,\n    disabled\n}) => {\n    const [isVisible, setIsVisible] = useState(false); // Controls visual opacity/transform\n    const [shouldRender, setShouldRender] = useState(false); // Controls mounting\n    const [maxWidth, setMaxWidth] = useState<number | undefined>(undefined);\n    const [finalTransform, setFinalTransform] = useState('none');\n\n    const [position, setPosition] = useState({ top: 0, left: 0 });\n    const triggerRef = useRef<HTMLDivElement>(null);\n    const tooltipRef = useRef<HTMLDivElement>(null);\n    const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const closeTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const enterTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n    const isHoveredRef = useRef(false);\n\n    const positionRaf = useRef<number | null>(null);\n\n    const updatePosition = useCallback(() => {\n        if (positionRaf.current) return;\n\n        positionRaf.current = requestAnimationFrame(() => {\n            const rect = anchorRect || (triggerRef.current?.getBoundingClientRect());\n            if (rect) {\n                const viewportWidth = document.documentElement.clientWidth;\n                const viewportHeight = document.documentElement.clientHeight;\n                const padding = 32; // Increased buffer to trigger flip earlier\n                const minWidth = 200;\n\n                let top = 0;\n                let left = 0;\n                let calculatedMaxWidth: number | undefined = undefined;\n                let transform = 'none';\n\n                let effectiveAlign = align;\n                let effectiveSide = side;\n\n                // Dynamic Height Measurement: Use actual height if rendered, else estimate\n                const currentHeight = tooltipRef.current?.offsetHeight || estimatedHeight;\n\n                // Vertical Flipping logic for 'top'/'bottom' sides\n                if (side === 'bottom' || side === 'top') {\n                    const spaceBottom = viewportHeight - (rect.bottom || (rect.top + rect.height)) - 4 - padding;\n                    const spaceTop = rect.top - 4 - padding;\n\n                    if (side === 'bottom' && spaceBottom < currentHeight && spaceTop > spaceBottom) {\n                        effectiveSide = 'top';\n                    } else if (side === 'top' && spaceTop < currentHeight && spaceBottom > spaceTop) {\n                        effectiveSide = 'bottom';\n                    }\n                }\n\n                if (effectiveSide === 'left' || effectiveSide === 'right') {\n                    // Vertical alignment for left/right sides\n                    top = rect.top;\n\n                    // Clamping for Left/Right Logic (keep vertical in bounds)\n                    const currentHeight = tooltipRef.current?.offsetHeight || estimatedHeight;\n                    const maxTop = viewportHeight - currentHeight - padding;\n                    top = Math.max(padding, Math.min(top, maxTop));\n\n                    const spaceRight = viewportWidth - (rect.right || (rect.left + rect.width)) - 4 - padding;\n                    const spaceLeft = rect.left - 4 - padding;\n\n                    if (effectiveSide === 'right' && spaceRight < minWidth && spaceLeft > spaceRight) {\n                        effectiveSide = 'left';\n                    } else if (effectiveSide === 'left' && spaceLeft < minWidth && spaceRight > spaceLeft) {\n                        effectiveSide = 'right';\n                    }\n\n                    if (effectiveSide === 'left') {\n                        left = rect.left - 4;\n                        transform = 'translateX(-100%)';\n                        calculatedMaxWidth = left - padding;\n                    } else {\n                        left = (rect.right || (rect.left + rect.width)) + 4;\n                        transform = 'none';\n                        calculatedMaxWidth = viewportWidth - left - padding;\n                    }\n                } else {\n                    // Horizontal alignment for top/bottom sides\n                    top = effectiveSide === 'bottom' ? (rect.bottom || (rect.top + rect.height)) + 4 : rect.top - 4;\n\n                    // Vertical Clamping Logic\n                    // We need to know the visual top/bottom to clamp.\n                    // If side=top, visualTop = top - height.\n                    // If side=bottom, visualTop = top.\n\n                    const height = tooltipRef.current?.offsetHeight || estimatedHeight;\n\n                    if (effectiveSide === 'top') {\n                        // Visual Top is (top - height). We want (top - height) >= padding.\n                        // So top >= padding + height.\n                        if (top - height < padding) {\n                            top = padding + height;\n                        }\n                    } else {\n                        // Visual Bottom is (top + height). We want (top + height) <= viewportHeight - padding.\n                        // So top <= viewportHeight - padding - height.\n                        if (top + height > viewportHeight - padding) {\n                            top = viewportHeight - padding - height;\n                        }\n                    }\n\n\n                    const spaceRight = viewportWidth - rect.left - padding;\n                    const spaceLeft = (rect.right || (rect.left + rect.width)) - padding;\n\n                    if (align === 'left' && spaceRight < minWidth && spaceLeft > spaceRight) {\n                        effectiveAlign = 'right';\n                    } else if (align === 'right' && spaceLeft < minWidth && spaceRight > spaceLeft) {\n                        effectiveAlign = 'left';\n                    }\n\n                    if (effectiveAlign === 'left') {\n                        left = rect.left;\n                        transform = effectiveSide === 'top' ? 'translateY(-100%)' : 'none';\n                        calculatedMaxWidth = viewportWidth - left - padding;\n                    } else if (effectiveAlign === 'right') {\n                        left = (rect.right || (rect.left + rect.width));\n                        transform = `translateX(-100%) ${effectiveSide === 'top' ? 'translateY(-100%)' : ''}`;\n                        calculatedMaxWidth = left - padding;\n                    } else { // center\n                        left = rect.left + (rect.width / 2);\n                        transform = `translateX(-50%) ${effectiveSide === 'top' ? 'translateY(-100%)' : ''}`;\n                        calculatedMaxWidth = Math.min(left - padding, viewportWidth - left - padding) * 2;\n                    }\n                }\n\n                setPosition({ top, left });\n                setMaxWidth(calculatedMaxWidth);\n                setFinalTransform(transform);\n            }\n            positionRaf.current = null;\n        });\n    }, [align, side, anchorRect]);\n\n    const showTooltip = useCallback(() => {\n        updatePosition();\n        setShouldRender(true);\n\n        requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n                setIsVisible(true);\n                onOpenChange?.(true);\n            });\n        });\n    }, [updatePosition, onOpenChange]);\n\n    const hideTooltip = useCallback(() => {\n        setIsVisible(false);\n        onOpenChange?.(false);\n\n        const delay = noAnimation ? 0 : 200;\n\n        closeTimeoutRef.current = setTimeout(() => {\n            // Only unmount if not visible (handled by isVisible check in effect usually, but here relies on timeout)\n            // We can just unmount.\n            setShouldRender(false);\n        }, delay);\n    }, [onOpenChange, noAnimation]);\n\n    // Handle External Control\n    useEffect(() => {\n        if (disabled) {\n            hideTooltip();\n            return;\n        }\n\n        // If disabled state changes to false and we are STILL hovered, re-show\n        if (!disabled && isHoveredRef.current && !forceOpen) {\n            // We can optionally check enterDelay here, but immediate show feels more responsive\n            // for these kinds of interactions (e.g. moving out of a sub-menu).\n            showTooltip();\n        }\n\n        if (forceOpen !== undefined) {\n            if (forceOpen) {\n                // Clear closing timeouts\n                if (closeTimeoutRef.current) {\n                    clearTimeout(closeTimeoutRef.current);\n                    closeTimeoutRef.current = null;\n                }\n                showTooltip();\n            } else {\n                if (timeoutRef.current) clearTimeout(timeoutRef.current);\n                if (enterTimeoutRef.current) clearTimeout(enterTimeoutRef.current);\n                hideTooltip();\n            }\n        }\n    }, [forceOpen, disabled, showTooltip, hideTooltip]);\n\n\n    const handleMouseEnter = () => {\n        if (disabled) return;\n        if (forceOpen !== undefined) return; // Ignore internal hover if forced\n        isHoveredRef.current = true;\n\n        if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n        }\n        if (closeTimeoutRef.current) {\n            clearTimeout(closeTimeoutRef.current);\n            closeTimeoutRef.current = null;\n        }\n        if (enterTimeoutRef.current) {\n            clearTimeout(enterTimeoutRef.current);\n            enterTimeoutRef.current = null;\n        }\n\n        // If already rendered/visible, we don't need to queue another show\n        // BUT if it's rendered but NOT visible (e.g. in the middle of closing animation), \n        // we MUST restore visibility immediately.\n        if (shouldRender) {\n            if (!isVisible) {\n                setIsVisible(true);\n                onOpenChange?.(true);\n            }\n            return;\n        }\n\n        if (enterDelay > 0) {\n            enterTimeoutRef.current = setTimeout(showTooltip, enterDelay);\n        } else {\n            showTooltip();\n        }\n    };\n\n    const handleMouseLeave = () => {\n        if (forceOpen !== undefined) return; // Ignore internal hover if forced\n        isHoveredRef.current = false;\n\n        if (enterTimeoutRef.current) {\n            clearTimeout(enterTimeoutRef.current);\n            enterTimeoutRef.current = null;\n        }\n\n        timeoutRef.current = setTimeout(() => {\n            hideTooltip();\n        }, 300); // Delay to allow moving to tooltip\n    };\n\n    // Update position on scroll or resize while visible\n    useEffect(() => {\n        if (shouldRender) {\n            updatePosition();\n            window.addEventListener('scroll', updatePosition, true);\n            window.addEventListener('resize', updatePosition);\n            return () => {\n                window.removeEventListener('scroll', updatePosition, true);\n                window.removeEventListener('resize', updatePosition);\n                if (positionRaf.current) {\n                    cancelAnimationFrame(positionRaf.current);\n                    positionRaf.current = null;\n                }\n            };\n        }\n    }, [shouldRender, updatePosition]);\n\n\n\n    return (\n        <div\n            ref={triggerRef}\n            onPointerEnter={handleMouseEnter}\n            onPointerLeave={handleMouseLeave}\n            className={`relative flex items-center justify-center ${triggerClassName}`}\n            title={title}\n        >\n            {children}\n            {shouldRender && createPortal(\n                <div\n                    className={`fixed z-[10000] pointer-events-auto will-change-transform`}\n                    style={{\n                        top: Math.round(position.top),\n                        left: Math.round(position.left),\n                        transform: finalTransform,\n                        maxWidth: fixedWidth ? undefined : (maxWidth ? Math.round(maxWidth) : undefined),\n                        width: fixedWidth ? `${fixedWidth}px` : undefined,\n                    }}\n                    onPointerEnter={handleMouseEnter} // Keep open when hovering tooltip\n                    onPointerLeave={() => {\n                        if (forceOpen === undefined) handleMouseLeave();\n                    }}\n                >\n                    <div\n                        ref={tooltipRef}\n                        className={`\n                            text-white text-[11px] leading-relaxed\n                            whitespace-normal break-all max-w-full text-left\n                            transition-all ease-out origin-top-right\n                            ${variant === 'glass'\n                                ? 'bg-[#1a1a1a]/85 backdrop-blur-xl p-2 rounded-lg shadow-lg w-auto max-w-[340px]'\n                                : 'bg-[#1F1F1F] px-3 py-2 rounded-lg shadow-xl'\n                            }\n                            ${noAnimation ? 'duration-0' : 'duration-200'}\n                            ${isVisible ? 'opacity-100 scale-100' : 'opacity-0 scale-95'}\n                            ${className}\n                        `}\n                    >\n                        {content}\n                    </div>\n                </div>,\n                document.body\n            )}\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/SortButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/SubTabs.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[268,271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[268,271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React, { useRef, useState, useEffect } from 'react';\nimport { Trash2, ChevronLeft, ChevronRight } from 'lucide-react';\n\nexport interface SubTab {\n    id: string;\n    label: string;\n    icon?: React.ReactNode;\n    color?: string;\n    count?: number;\n    data?: any;\n    onDelete?: () => void;\n}\n\ninterface SubTabsProps {\n    tabs: SubTab[];\n    activeTabId: string;\n    onTabChange: (id: string) => void;\n    className?: string;\n}\n\nexport const SubTabs: React.FC<SubTabsProps> = ({\n    tabs,\n    activeTabId,\n    onTabChange,\n    className = ''\n}) => {\n    const scrollContainerRef = useRef<HTMLDivElement>(null);\n    const [showLeftGradient, setShowLeftGradient] = useState(false);\n    const [showRightGradient, setShowRightGradient] = useState(false);\n\n    // Check scroll position to toggle gradients\n    const checkScroll = () => {\n        if (!scrollContainerRef.current) return;\n        const { scrollLeft, scrollWidth, clientWidth } = scrollContainerRef.current;\n        setShowLeftGradient(scrollLeft > 0);\n        setShowRightGradient(scrollLeft < scrollWidth - clientWidth - 1); // -1 buffer for float precision\n    };\n\n    // Initial check and event listener\n    useEffect(() => {\n        checkScroll();\n        window.addEventListener('resize', checkScroll);\n        return () => window.removeEventListener('resize', checkScroll);\n    }, [tabs]);\n\n    // Scroll handlers\n    const scroll = (direction: 'left' | 'right') => {\n        if (!scrollContainerRef.current) return;\n        const scrollAmount = 200;\n        scrollContainerRef.current.scrollBy({\n            left: direction === 'left' ? -scrollAmount : scrollAmount,\n            behavior: 'smooth'\n        });\n    };\n\n    return (\n        <div className={`relative group w-full min-w-0 ${className}`}>\n            {/* Left Gradient & Button */}\n            <div\n                className={`absolute left-0 top-0 bottom-0 w-12 bg-gradient-to-r from-bg-secondary to-transparent z-10 transition-opacity duration-300 pointer-events-none ${showLeftGradient ? 'opacity-100' : 'opacity-0'}`}\n            />\n            {showLeftGradient && (\n                <button\n                    onClick={() => scroll('left')}\n                    className=\"absolute left-0 top-1/2 -translate-y-1/2 z-20 w-6 h-6 flex items-center justify-center rounded-full bg-[#1F1F1F] text-white shadow-lg hover:bg-white/10 transition-colors opacity-0 group-hover:opacity-100\"\n                >\n                    <ChevronLeft size={14} />\n                </button>\n            )}\n\n            {/* Scroll Container */}\n            <div\n                ref={scrollContainerRef}\n                onScroll={checkScroll}\n                className=\"flex items-center gap-2 overflow-x-auto scrollbar-none px-4 pb-0\"\n                style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}\n            >\n                {tabs.map(tab => {\n                    const isActive = activeTabId === tab.id;\n\n                    return (\n                        <button\n                            key={tab.id}\n                            onClick={() => {\n                                onTabChange(tab.id);\n                                // Optional: center the clicked tab\n                                // e.currentTarget.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });\n                            }}\n                            className={`\n                                relative flex items-center gap-2 px-4 py-2 text-xs font-medium transition-all whitespace-nowrap select-none\n                                ${isActive\n                                    ? 'text-text-primary bg-white/5'\n                                    : 'text-text-secondary hover:text-text-primary'\n                                }\n                            `}\n                        >\n                            {/* Active Indicator Line */}\n                            {isActive && (\n                                <div className=\"absolute bottom-0 left-0 right-0 h-0.5 bg-text-primary rounded-b-lg\" />\n                            )}\n\n                            {/* Niche Color Dot */}\n                            {tab.color && (\n                                <div\n                                    className=\"w-2 h-2 rounded-full shadow-[0_0_4px_rgba(0,0,0,0.5)] flex-shrink-0\"\n                                    style={{ backgroundColor: tab.color }}\n                                />\n                            )}\n\n                            {/* Icon */}\n                            {tab.icon && (\n                                <span className={isActive ? 'text-text-primary' : 'text-text-secondary'}>\n                                    {tab.icon}\n                                </span>\n                            )}\n\n                            {/* Label */}\n                            <span>{tab.label}</span>\n\n                            {/* Count Badge */}\n                            {tab.count !== undefined && (\n                                <span className={`\n                                    ml-1 text-[10px] px-1.5 py-0.5 rounded-full font-bold\n                                    ${isActive ? 'bg-white/10 text-white' : 'bg-white/5 text-text-secondary'}\n                                `}>\n                                    {tab.count}\n                                </span>\n                            )}\n\n                            {/* Delete Action */}\n                            {tab.onDelete && (\n                                <div\n                                    role=\"button\"\n                                    onClick={(e) => {\n                                        e.stopPropagation();\n                                        tab.onDelete?.();\n                                    }}\n                                    className=\"ml-1 p-1 rounded-full text-text-secondary hover:text-red-500 hover:bg-white/10 transition-colors opacity-0 group-hover:opacity-100\"\n                                >\n                                    <Trash2 size={12} />\n                                </div>\n                            )}\n                        </button>\n                    );\n                })}\n            </div>\n\n            {/* Right Gradient & Button */}\n            <div\n                className={`absolute right-0 top-0 bottom-0 w-12 bg-gradient-to-l from-bg-secondary to-transparent z-10 transition-opacity duration-300 pointer-events-none ${showRightGradient ? 'opacity-100' : 'opacity-0'}`}\n            />\n            {showRightGradient && (\n                <button\n                    onClick={() => scroll('right')}\n                    className=\"absolute right-0 top-1/2 -translate-y-1/2 z-20 w-6 h-6 flex items-center justify-center rounded-full bg-[#1F1F1F] text-white shadow-lg hover:bg-white/10 transition-colors opacity-0 group-hover:opacity-100\"\n                >\n                    <ChevronRight size={14} />\n                </button>\n            )}\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/ImageActionOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/ThumbnailHistoryModal.tsx","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `visibleHistory`, but the source dependencies were [getChangesToApply, onDelete, selectedVersion, visibleHistory.length, effectiveCurrentThumbnail, onApply, onClose, history]. Inferred less specific property than source.\n\n/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/ThumbnailHistoryModal.tsx:120:43\n  118 |      * in the main Packaging tab, not this History modal.\n  119 |      */\n> 120 |     const handleApply = React.useCallback(() => {\n      |                                           ^^^^^^^\n> 121 |         const changes = getChangesToApply();\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 122 |\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 148 |         onClose();\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 149 |     }, [getChangesToApply, onDelete, selectedVersion, visibleHistory.length, effectiveCurrentThumbnail, onApply, onClose, history]);\n      | ^^^^^^ Could not preserve existing manual memoization\n  150 |\n  151 |     const showHistoricalColumn = !hasOnlyCurrentThumbnail;\n  152 |","line":120,"column":43,"nodeType":null,"endLine":149,"endColumn":6},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useCallback has a missing dependency: 'visibleHistory'. Either include it or remove the dependency array.","line":149,"column":8,"nodeType":"ArrayExpression","endLine":149,"endColumn":131,"suggestions":[{"desc":"Update the dependencies array to be: [getChangesToApply, onDelete, selectedVersion, visibleHistory, effectiveCurrentThumbnail, onClose, onApply]","fix":{"range":[5796,5919],"text":"[getChangesToApply, onDelete, selectedVersion, visibleHistory, effectiveCurrentThumbnail, onClose, onApply]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { createPortal } from 'react-dom';\nimport { X, Check, ChevronLeft, ChevronRight } from 'lucide-react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { type CoverVersion } from '../../../core/utils/youtubeApi';\nimport { ImageActionOverlay } from './ImageActionOverlay';\nimport { Button } from '../../../components/ui/atoms/Button';\nimport { useThumbnailHistoryModalState } from './hooks';\nimport { slideVariants, containerVariants, itemVariants } from './constants';\n\nexport interface ThumbnailHistoryModalProps {\n    isOpen: boolean;\n    onClose: () => void;\n    currentThumbnail: string | null;\n    history: CoverVersion[];\n    onApply: (url: string, originalName?: string, version?: number, close?: boolean) => void;\n    onDelete?: (timestamp: number) => void;\n    onClone?: (version: CoverVersion) => void;\n    cloningVersion?: number | null;\n    currentVersionInfo?: {\n        version?: number;\n        originalName?: string;\n    };\n    checkIsCloned?: (thumbnailUrl: string) => boolean;\n    likedThumbnailVersions?: number[];\n    onLikeThumbnail?: (version: number) => void;\n    onRemoveThumbnail?: (version: number) => void;\n}\n\n/**\n * Modal for comparing and applying thumbnail versions from history.\n * \n * BUSINESS LOGIC: Pending Changes Pattern\n * ----------------------------------------\n * All changes (deletions, version selection) are tracked as \"pending\"\n * and NOT applied until the user clicks \"Apply Version\":\n * \n * - Cancel  discards all changes, closes modal (no side effects)\n * - Apply Version  commits changes to parent, closes modal\n * - X button  same as Cancel\n * \n * This ensures users can safely explore and modify without fear\n * of accidental changes being persisted.\n */\nexport const ThumbnailHistoryModal: React.FC<ThumbnailHistoryModalProps> = ({\n    isOpen,\n    onClose,\n    currentThumbnail,\n    history,\n    onApply,\n    onDelete,\n    onClone,\n    cloningVersion,\n    currentVersionInfo,\n    checkIsCloned,\n    likedThumbnailVersions = [],\n    onLikeThumbnail,\n    onRemoveThumbnail\n}) => {\n    const {\n        selectedIndex,\n        direction,\n        selectedVersion,\n        visibleHistory,\n        effectiveCurrentThumbnail,\n        pendingChanges,\n        openTooltipTimestamp,\n        isCurrentTooltipOpen,\n        isHistoricalTooltipOpen,\n        handleNext,\n        handlePrev,\n        handleThumbnailSelect,\n        setOpenTooltipTimestamp,\n        setIsCurrentTooltipOpen,\n        setIsHistoricalTooltipOpen,\n        onAnimationComplete,\n        markForDeletion,\n        discardChanges,\n        getChangesToApply\n    } = useThumbnailHistoryModalState({\n        isOpen,\n        history,\n        currentThumbnail\n    });\n\n    // Check if all versions have been deleted (for empty state)\n    const allVersionsDeleted = visibleHistory.length === 0;\n\n    // BUSINESS LOGIC: Button text depends on current state\n    // - \"Save\"  only current thumbnail exists (user deleted all history, just confirming to close)\n    // - \"Clear Thumbnail\"  everything deleted (user wants to remove all)\n    // - \"Apply Version\"  historical versions exist (user can apply one)\n    const hasOnlyCurrentThumbnail = effectiveCurrentThumbnail && visibleHistory.length === 0;\n    const hasNothingLeft = !effectiveCurrentThumbnail && visibleHistory.length === 0;\n\n    /**\n     * Handle Cancel: discard all pending changes and close.\n     */\n    const handleCancel = React.useCallback(() => {\n        discardChanges();\n        onClose();\n    }, [discardChanges, onClose]);\n\n    /**\n     * Handle Apply: commit all pending changes and close.\n     * \n     * BUSINESS LOGIC: Delete Current = Replace with Selected\n     * --------------------------------------------------------\n     * When user deletes the current thumbnail in this modal, we don't\n     * just clear it  we replace it with the currently selected\n     * historical version. This is the expected behavior:\n     * \n     * - User wants to \"undo\" current thumbnail  picks historical  Apply\n     * - User deletes current from overlay  the selected historical becomes new current\n     * - User deletes ALL versions  Apply clears the current thumbnail\n     * \n     * To actually clear the thumbnail, user should use \"More\" > \"Remove\"\n     * in the main Packaging tab, not this History modal.\n     */\n    const handleApply = React.useCallback(() => {\n        const changes = getChangesToApply();\n\n        // 1. Execute pending deletions from history\n        if (onDelete && changes.deletedTimestamps.length > 0) {\n            changes.deletedTimestamps.forEach(timestamp => {\n                onDelete(timestamp);\n            });\n        }\n\n        // 2. Determine what thumbnail to apply\n        if (selectedVersion) {\n            // Apply selected historical version with filename and original version\n            onApply(selectedVersion.url, selectedVersion.originalName, selectedVersion.version);\n        } else if (visibleHistory.length === 0 && !effectiveCurrentThumbnail) {\n            // All versions deleted AND no current thumbnail  clear the thumbnail\n            onApply('', '', undefined);\n        } else if (changes.thumbnailUrl !== null && changes.thumbnailUrl !== '') {\n            // Explicit pending thumbnail URL (not empty)\n            const matchedVersion = visibleHistory.find(v => v.url === changes.thumbnailUrl);\n            onApply(changes.thumbnailUrl, matchedVersion?.originalName || '', matchedVersion?.version);\n        } else {\n            // If only current thumbnail remains (hasOnlyCurrentThumbnail case)\n            //  just close without calling onApply, keeping current thumbnail intact\n            // Or if no changes were made and nothing was selected, just close.\n            onClose();\n        }\n\n        onClose();\n    }, [getChangesToApply, onDelete, selectedVersion, visibleHistory.length, effectiveCurrentThumbnail, onApply, onClose, history]);\n\n    const showHistoricalColumn = !hasOnlyCurrentThumbnail;\n\n    // Keyboard shortcuts: Esc  Cancel, Enter  Apply Version\n    React.useEffect(() => {\n        if (!isOpen) return;\n\n        const handleKeyDown = (e: KeyboardEvent) => {\n            // Esc  Cancel\n            if (e.key === 'Escape') {\n                e.preventDefault();\n                handleCancel();\n            }\n            // Enter  Apply Version (if enabled)\n            else if (e.key === 'Enter') {\n                const isApplyDisabled = !selectedVersion && !allVersionsDeleted && pendingChanges.thumbnailUrl === null;\n                if (!isApplyDisabled) {\n                    e.preventDefault();\n                    handleApply();\n                }\n            }\n        };\n\n        window.addEventListener('keydown', handleKeyDown);\n        return () => window.removeEventListener('keydown', handleKeyDown);\n    }, [isOpen, selectedVersion, allVersionsDeleted, pendingChanges.thumbnailUrl, handleCancel, handleApply]);\n\n    if (!isOpen) return null;\n\n    return createPortal(\n        <div className=\"fixed inset-0 z-[1000] flex items-center justify-center p-6\">\n            {/* Backdrop - same as Cancel */}\n            <motion.div\n                initial={{ opacity: 0 }}\n                animate={{ opacity: 1 }}\n                exit={{ opacity: 0 }}\n                onClick={handleCancel}\n                className=\"absolute inset-0 bg-black/60 backdrop-blur-xl\"\n            />\n\n            {/* Modal Container */}\n            <motion.div\n                initial={{ opacity: 0, scale: 0.95, y: 20 }}\n                animate={{ opacity: 1, scale: 1, y: 0 }}\n                exit={{ opacity: 0, scale: 0.95, y: 20 }}\n                className=\"relative bg-modal-bg border border-modal-border rounded-2xl w-full max-w-7xl max-h-[90vh] overflow-hidden flex flex-col shadow-2xl\"\n            >\n                {/* Header */}\n                <div className=\"flex items-center justify-between px-8 py-5 border-b border-modal-border\">\n                    <div>\n                        <h2 className=\"text-xl font-semibold text-modal-text-primary\">Compare Version History</h2>\n                        <p className=\"text-sm text-modal-text-secondary mt-0.5\">Compare your current thumbnail with previous versions</p>\n                    </div>\n                    <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={handleCancel}\n                        className=\"!p-2 !rounded-full\"\n                    >\n                        <X size={24} />\n                    </Button>\n                </div>\n\n                {/* Main Comparison Area */}\n                <div className=\"flex-1 overflow-y-auto overflow-x-hidden p-5 lg:p-10\">\n                    <div className={`grid gap-16 items-center relative transition-all duration-300\n                        ${effectiveCurrentThumbnail && showHistoricalColumn ? 'grid-cols-1 lg:grid-cols-2' : 'grid-cols-1 flex justify-center'}`}>\n\n                        {/* Current (Left) - Only show if current thumbnail exists */}\n                        {effectiveCurrentThumbnail && (\n                            <div className={`space-y-4 ${hasOnlyCurrentThumbnail ? 'w-full max-w-xl mx-auto' : ''}`}>\n                                <div className=\"flex items-center justify-between\">\n                                    <span className=\"text-xs font-bold uppercase tracking-widest text-modal-text-secondary\">Current Version</span>\n                                </div>\n                                <div className={`aspect-video rounded-xl overflow-hidden border transition-all bg-black/40 shadow-inner group relative\n                                ${isCurrentTooltipOpen ? 'border-white/20 ring-1 ring-white/10' : 'border-white/10'}`}>\n                                    <img src={effectiveCurrentThumbnail} alt=\"Current\" className=\"w-full h-full object-cover\" />\n                                    <div className=\"absolute inset-0 ring-1 ring-inset ring-white/5 pointer-events-none\" />\n\n                                    {/* Overlay for Current Version */}\n                                    <ImageActionOverlay\n                                        version={currentVersionInfo?.version || history.find(v => v.url === effectiveCurrentThumbnail)?.version || 0}\n                                        originalName={currentVersionInfo?.originalName || history.find(v => v.url === effectiveCurrentThumbnail)?.originalName}\n                                        onDelete={() => {\n                                            // Mark for deletion (pending, not immediate)\n                                            const item = history.find(v => v.url === effectiveCurrentThumbnail);\n                                            if (item) {\n                                                markForDeletion(item.timestamp, item.url);\n                                            } else {\n                                                // Current thumbnail not in history, just clear it\n                                                markForDeletion(0, effectiveCurrentThumbnail);\n                                            }\n                                        }}\n                                        onTooltipOpenChange={setIsCurrentTooltipOpen}\n                                        isCloned={checkIsCloned?.(effectiveCurrentThumbnail) || false}\n                                        isLiked={likedThumbnailVersions.includes(currentVersionInfo?.version || 0)}\n                                        onLike={() => onLikeThumbnail?.(currentVersionInfo?.version || 0)}\n                                        onRemove={() => onRemoveThumbnail?.(currentVersionInfo?.version || 0)}\n                                    />\n                                </div>\n                            </div>\n                        )}\n\n                        {/* Historical (Right) */}\n                        {showHistoricalColumn && (\n                            <div className={`space-y-4 relative ${!effectiveCurrentThumbnail ? 'w-full max-w-xl mx-auto' : ''}`}>\n                                <div className=\"flex items-center justify-between px-1\">\n                                    <span className=\"text-xs font-bold uppercase tracking-widest text-[#3ea6ff]\">\n                                        {allVersionsDeleted ? 'No Versions' : 'Historical'}\n                                    </span>\n                                    <span className=\"text-[10px] text-modal-text-secondary font-medium\">\n                                        {selectedVersion ? new Date(selectedVersion.timestamp).toLocaleDateString() : ''}\n                                    </span>\n                                </div>\n\n                                <div className=\"relative group z-20\">\n                                    <div className={`aspect-video rounded-xl overflow-hidden border transition-all bg-black/40 shadow-2xl relative\n                                        ${allVersionsDeleted\n                                            ? 'border-white/10'\n                                            : (isHistoricalTooltipOpen ? 'border-[#3ea6ff]/60 ring-1 ring-[#3ea6ff]/20' : 'border-[#3ea6ff]/30')}`}>\n\n                                        {/* Empty State - All versions deleted */}\n                                        {allVersionsDeleted ? (\n                                            <div className=\"absolute inset-0 flex flex-col items-center justify-center text-center p-6\">\n                                                <div className=\"w-16 h-16 rounded-full bg-white/5 flex items-center justify-center mb-4\">\n                                                    <svg\n                                                        className=\"w-8 h-8 text-modal-text-secondary opacity-60\"\n                                                        fill=\"none\"\n                                                        viewBox=\"0 0 24 24\"\n                                                        stroke=\"currentColor\"\n                                                    >\n                                                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5}\n                                                            d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\"\n                                                        />\n                                                    </svg>\n                                                </div>\n                                                <p className=\"text-modal-text-secondary text-sm font-medium mb-1\">\n                                                    All versions removed\n                                                </p>\n                                                <p className=\"text-modal-text-secondary/60 text-xs\">\n                                                    Click Apply to clear the current thumbnail\n                                                </p>\n                                            </div>\n                                        ) : (\n                                            <>\n                                                <AnimatePresence initial={false} custom={direction}>\n                                                    <motion.img\n                                                        key={selectedVersion?.url}\n                                                        custom={direction}\n                                                        variants={slideVariants}\n                                                        initial=\"enter\"\n                                                        animate=\"center\"\n                                                        exit=\"exit\"\n                                                        onAnimationComplete={onAnimationComplete}\n                                                        transition={{\n                                                            x: { duration: 0.4, ease: [0.32, 0.72, 0, 1] }\n                                                        }}\n                                                        src={selectedVersion?.url}\n                                                        alt={`Version ${selectedVersion?.version}`}\n                                                        className=\"absolute inset-0 w-full h-full object-cover\"\n                                                    />\n                                                </AnimatePresence>\n                                                <div className=\"absolute inset-0 ring-1 ring-inset ring-white/10 pointer-events-none\" />\n\n                                                {/* Overlay for Historical Preview */}\n                                                {selectedVersion && (\n                                                    <ImageActionOverlay\n                                                        version={selectedVersion.version}\n                                                        originalName={selectedVersion.originalName}\n                                                        onDelete={() => {\n                                                            // Mark for deletion (pending)\n                                                            markForDeletion(selectedVersion.timestamp, selectedVersion.url);\n                                                        }}\n                                                        onClone={() => onClone && onClone(selectedVersion)}\n                                                        isCloning={cloningVersion === selectedVersion.version}\n                                                        className=\"z-30\"\n                                                        onTooltipOpenChange={setIsHistoricalTooltipOpen}\n                                                        isCloned={checkIsCloned?.(selectedVersion.url) || false}\n                                                        isLiked={likedThumbnailVersions.includes(selectedVersion.version)}\n                                                        onLike={() => onLikeThumbnail?.(selectedVersion.version)}\n                                                        onRemove={() => onRemoveThumbnail?.(selectedVersion.version)}\n                                                    />\n                                                )}\n                                            </>\n                                        )}\n                                    </div>\n\n                                    {/* Quick Nav Arrows - only show if more than 1 visible version */}\n                                    {visibleHistory.length > 1 && (\n                                        <>\n                                            <div className=\"absolute left-[-40px] top-0 bottom-0 w-[80px] flex items-center justify-start z-10\">\n                                                <button\n                                                    onClick={handlePrev}\n                                                    className=\"ml-4 w-10 h-10 rounded-full bg-bg-secondary/90 backdrop-blur-md border border-border shadow-lg \n                                                        flex items-center justify-center text-text-secondary\n                                                        transition-all hover:brightness-125 hover:text-text-primary hover:scale-110 hover:animate-none\n                                                        animate-[pulse-subtle_2s_ease-in-out_infinite]\"\n                                                >\n                                                    <ChevronLeft size={24} />\n                                                </button>\n                                            </div>\n                                            <div className=\"absolute right-[-40px] top-0 bottom-0 w-[80px] flex items-center justify-end z-10\">\n                                                <button\n                                                    onClick={handleNext}\n                                                    className=\"mr-4 w-10 h-10 rounded-full bg-bg-secondary/90 backdrop-blur-md border border-border shadow-lg \n                                                        flex items-center justify-center text-text-secondary\n                                                        transition-all hover:brightness-125 hover:text-text-primary hover:scale-110 hover:animate-none\n                                                        animate-[pulse-subtle_2s_ease-in-out_infinite]\"\n                                                >\n                                                    <ChevronRight size={24} />\n                                                </button>\n                                            </div>\n                                        </>\n                                    )}\n                                </div>\n                            </div>\n                        )}\n\n                        {/* Comparison Indicator (Middle) */}\n                        {effectiveCurrentThumbnail && showHistoricalColumn && (\n                            <div className=\"hidden lg:flex absolute inset-0 items-center justify-center z-10 pointer-events-none\">\n                                <div className=\"px-3 py-1.5 rounded-full\">\n                                    <span className=\"text-modal-text-secondary font-bold text-xs tracking-widest opacity-80\">\n                                        VS\n                                    </span>\n                                </div>\n                            </div>\n                        )}\n                    </div>\n                </div>\n\n                {/* Footer */}\n                <div className=\"px-8 bg-modal-surface/50 border-t border-modal-border\">\n                    <div className=\"flex flex-col\">\n                        {visibleHistory.length > 1 && (\n                            <div className=\"flex items-center justify-between py-4\">\n                                <motion.div\n                                    variants={containerVariants}\n                                    initial=\"hidden\"\n                                    animate=\"visible\"\n                                    className=\"flex gap-1.5 overflow-x-auto p-2 scrollbar-hide -mx-2 px-2\"\n                                >\n                                    {visibleHistory.map((version, index) => (\n                                        <motion.div\n                                            key={version.timestamp}\n                                            variants={itemVariants}\n                                            onClick={() => handleThumbnailSelect(index)}\n                                            className={`flex-shrink-0 w-36 aspect-video rounded-lg overflow-hidden border-2 transition-all relative group group/item cursor-pointer\n                                                ${selectedIndex === index\n                                                    ? 'border-[#3ea6ff] scale-105 z-10 shadow-lg shadow-[#3ea6ff]/10'\n                                                    : (openTooltipTimestamp === version.timestamp\n                                                        ? 'opacity-100 border-white/20 ring-1 ring-white/10'\n                                                        : 'border-transparent opacity-60 hover:opacity-100 hover:border-white/20')}`}\n                                        >\n                                            <img\n                                                src={version.url}\n                                                alt={`v.${version.version}`}\n                                                className=\"w-full h-full object-cover\"\n                                            />\n\n                                            {/* Overlay for Carousel Items */}\n                                            <ImageActionOverlay\n                                                version={version.version}\n                                                originalName={version.originalName}\n                                                onDelete={() => {\n                                                    // Mark for deletion (pending)\n                                                    markForDeletion(version.timestamp, version.url);\n                                                }}\n                                                isCloning={cloningVersion === version.version}\n                                                size=\"small\"\n                                                onTooltipOpenChange={(open) => setOpenTooltipTimestamp(open ? version.timestamp : null)}\n                                                isCloned={checkIsCloned?.(version.url) || false}\n                                                isLiked={likedThumbnailVersions.includes(version.version)}\n                                                onLike={() => onLikeThumbnail?.(version.version)}\n                                                onRemove={() => onRemoveThumbnail?.(version.version)}\n                                            />\n\n                                            {selectedIndex === index && (\n                                                <div className=\"absolute top-1 right-1 w-4 h-4 rounded-full bg-[#3ea6ff] flex items-center justify-center shadow-lg pointer-events-none\">\n                                                    <Check size={10} strokeWidth={3} className=\"text-[#1f1f1f]\" />\n                                                </div>\n                                            )}\n                                            <div className=\"absolute bottom-1 left-1.5 text-[9px] font-bold text-white px-1.5 py-0.5 rounded bg-black/60 backdrop-blur-sm border border-white/10 pointer-events-none\">\n                                                v{version.version}\n                                            </div>\n                                        </motion.div>\n                                    ))}\n                                </motion.div>\n                            </div>\n                        )}\n\n                        <div className={`flex items-center justify-between py-4 ${visibleHistory.length > 1 ? 'border-t border-modal-border' : ''}`}>\n                            <div className=\"text-sm text-modal-text-secondary font-medium\">\n                                {visibleHistory.length} versions in history\n                            </div>\n                            <div className=\"flex gap-3\">\n                                <Button\n                                    variant=\"secondary\"\n                                    size=\"sm\"\n                                    onClick={handleApply}\n                                    disabled={!selectedVersion && !allVersionsDeleted && pendingChanges.thumbnailUrl === null}\n                                    className=\"!bg-[#3ea6ff] !text-[#1f1f1f] hover:!bg-[#65b8ff]\"\n                                >\n                                    {hasOnlyCurrentThumbnail ? 'Save' : (hasNothingLeft ? 'Clear Thumbnail' : 'Apply Version')}\n                                </Button>\n                                <Button variant=\"primary\" size=\"sm\" onClick={handleCancel}>\n                                    Cancel\n                                </Button>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </motion.div>\n        </div>,\n        document.body\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/ThumbnailSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/constants/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/constants/thumbnailHistoryAnimations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/hooks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/hooks/useThumbnailHistoryModalState.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/hooks/useThumbnailHistoryModalState.ts:133:9\n  131 |\n  132 |         // Reset pending changes\n> 133 |         setPendingChanges({\n      |         ^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  134 |             thumbnailUrl: null,\n  135 |             deletedTimestamps: []\n  136 |         });","line":133,"column":9,"nodeType":null,"endLine":133,"endColumn":26},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'currentThumbnail' and 'history'. Either include them or remove the dependency array.","line":147,"column":8,"nodeType":"ArrayExpression","endLine":147,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [currentThumbnail, history, isOpen]","fix":{"range":[4840,4848],"text":"[currentThumbnail, history, isOpen]"}}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/components/Shared/Thumbnail/hooks/useThumbnailHistoryModalState.ts:152:13\n  150 |     useEffect(() => {\n  151 |         if (visibleHistory.length === 0) {\n> 152 |             setSelectedIndex(0);\n      |             ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  153 |             return;\n  154 |         }\n  155 |         if (selectedIndex >= visibleHistory.length) {","line":152,"column":13,"nodeType":null,"endLine":152,"endColumn":29}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useMemo } from 'react';\nimport { type CoverVersion } from '../../../../core/utils/youtubeApi';\n\nexport interface UseThumbnailHistoryModalStateProps {\n    isOpen: boolean;\n    history: CoverVersion[];\n    currentThumbnail: string | null;\n}\n\n/**\n * Represents a pending change made within the modal.\n * Changes are NOT applied until user clicks \"Apply Version\".\n * Clicking \"Cancel\" discards all pending changes.\n */\nexport interface PendingChanges {\n    /** URL to apply when committing (empty string = clear thumbnail) */\n    thumbnailUrl: string | null;\n    /** Timestamps of versions marked for deletion */\n    deletedTimestamps: number[];\n}\n\nexport interface UseThumbnailHistoryModalStateReturn {\n    // Navigation state\n    selectedIndex: number;\n    direction: number;\n    isAnimating: boolean;\n    selectedVersion: CoverVersion | undefined;\n\n    // Visible history (filtered, excluding pending deletions)\n    visibleHistory: CoverVersion[];\n\n    // Pending changes state\n    pendingChanges: PendingChanges;\n    hasPendingChanges: boolean;\n\n    // Computed: effective current thumbnail (considering pending changes)\n    effectiveCurrentThumbnail: string | null;\n\n    // Tooltip state\n    openTooltipTimestamp: number | null;\n    isCurrentTooltipOpen: boolean;\n    isHistoricalTooltipOpen: boolean;\n\n    // Navigation handlers\n    handleNext: () => void;\n    handlePrev: () => void;\n    handleThumbnailSelect: (index: number) => void;\n    onAnimationComplete: () => void;\n\n    // Tooltip handlers\n    setOpenTooltipTimestamp: (timestamp: number | null) => void;\n    setIsCurrentTooltipOpen: (open: boolean) => void;\n    setIsHistoricalTooltipOpen: (open: boolean) => void;\n\n    // Change management handlers\n    /**\n     * Marks a version for deletion (pending, not immediate).\n     * Automatically adjusts selection to next available version.\n     */\n    markForDeletion: (timestamp: number, url: string) => void;\n\n    /**\n     * Sets the pending thumbnail URL to apply.\n     */\n    setPendingThumbnail: (url: string) => void;\n\n    /**\n     * Resets all pending changes (called on Cancel).\n     */\n    discardChanges: () => void;\n\n    /**\n     * Returns data to commit (called on Apply).\n     */\n    getChangesToApply: () => {\n        thumbnailUrl: string | null;\n        deletedTimestamps: number[];\n    };\n}\n\n/**\n * Manages all state and logic for ThumbnailHistoryModal.\n * \n * BUSINESS LOGIC: Pending Changes Pattern\n * ----------------------------------------\n * All modifications (deletions, thumbnail selection) are tracked as \"pending\"\n * and NOT applied immediately. This allows the Cancel button to properly\n * discard changes and restore the original state.\n * \n * Navigation operates on VISIBLE history (excluding pending deletions).\n */\nexport function useThumbnailHistoryModalState({\n    isOpen,\n    history,\n    currentThumbnail\n}: UseThumbnailHistoryModalStateProps): UseThumbnailHistoryModalStateReturn {\n    // === Navigation State ===\n    const [selectedIndex, setSelectedIndex] = useState(0);\n    const [direction, setDirection] = useState(0);\n    const [isAnimating, setIsAnimating] = useState(false);\n\n    // === Tooltip State ===\n    const [openTooltipTimestamp, setOpenTooltipTimestamp] = useState<number | null>(null);\n    const [isCurrentTooltipOpen, setIsCurrentTooltipOpen] = useState(false);\n    const [isHistoricalTooltipOpen, setIsHistoricalTooltipOpen] = useState(false);\n\n    // === Pending Changes State ===\n    const [pendingChanges, setPendingChanges] = useState<PendingChanges>({\n        thumbnailUrl: null,\n        deletedTimestamps: []\n    });\n\n    // === Computed: Visible History ===\n    // Filter out items marked for deletion (pending) AND the current thumbnail\n    // (to prevent showing it in both \"Current\" and \"Historical\" columns)\n    const effectiveCurrentThumbnail = pendingChanges.thumbnailUrl === ''\n        ? null\n        : (pendingChanges.thumbnailUrl ?? currentThumbnail);\n\n    const visibleHistory = useMemo(() =>\n        history.filter(v =>\n            !pendingChanges.deletedTimestamps.includes(v.timestamp) &&\n            v.url !== effectiveCurrentThumbnail\n        ),\n        [history, pendingChanges.deletedTimestamps, effectiveCurrentThumbnail]\n    );\n\n    // === Initialize on Modal Open ===\n    useEffect(() => {\n        if (!isOpen) return;\n\n        // Reset pending changes\n        setPendingChanges({\n            thumbnailUrl: null,\n            deletedTimestamps: []\n        });\n\n        // Find and select current thumbnail in history\n        if (history.length > 0) {\n            const currentIdx = history.findIndex(v => v.url === currentThumbnail);\n            setSelectedIndex(currentIdx !== -1 ? currentIdx : 0);\n        }\n\n        // Reset animation state\n        setDirection(0);\n        setIsAnimating(false);\n    }, [isOpen]); // Only re-run when modal opens/closes\n\n    // === Keep Selection in Bounds (for visible history) ===\n    useEffect(() => {\n        if (visibleHistory.length === 0) {\n            setSelectedIndex(0);\n            return;\n        }\n        if (selectedIndex >= visibleHistory.length) {\n            setSelectedIndex(Math.max(0, visibleHistory.length - 1));\n        }\n    }, [visibleHistory.length, selectedIndex]);\n\n    // === Keyboard Navigation (uses visible history) ===\n    useEffect(() => {\n        if (!isOpen || visibleHistory.length <= 1) return;\n\n        const handleKeyDown = (e: KeyboardEvent) => {\n            if (isAnimating) return;\n\n            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {\n                e.preventDefault();\n                setIsAnimating(true);\n                setDirection(1);\n                setSelectedIndex(prev => (prev + 1) % visibleHistory.length);\n            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {\n                e.preventDefault();\n                setIsAnimating(true);\n                setDirection(-1);\n                setSelectedIndex(prev => (prev - 1 + visibleHistory.length) % visibleHistory.length);\n            }\n        };\n\n        window.addEventListener('keydown', handleKeyDown);\n        return () => window.removeEventListener('keydown', handleKeyDown);\n    }, [isOpen, visibleHistory.length, isAnimating]);\n\n    // === Navigation Handlers (use visible history) ===\n    const handleNext = useCallback(() => {\n        if (isAnimating || visibleHistory.length <= 1) return;\n        setIsAnimating(true);\n        setDirection(1);\n        setSelectedIndex(prev => (prev + 1) % visibleHistory.length);\n    }, [isAnimating, visibleHistory.length]);\n\n    const handlePrev = useCallback(() => {\n        if (isAnimating || visibleHistory.length <= 1) return;\n        setIsAnimating(true);\n        setDirection(-1);\n        setSelectedIndex(prev => (prev - 1 + visibleHistory.length) % visibleHistory.length);\n    }, [isAnimating, visibleHistory.length]);\n\n    const handleThumbnailSelect = useCallback((index: number) => {\n        if (index === selectedIndex) return;\n        setDirection(index > selectedIndex ? 1 : -1);\n        setSelectedIndex(index);\n    }, [selectedIndex]);\n\n    const onAnimationComplete = useCallback(() => {\n        setIsAnimating(false);\n    }, []);\n\n    // === Pending Changes Handlers ===\n\n    /**\n     * Marks a version for deletion.\n     * Automatically adjusts selection to next available version.\n     */\n    const markForDeletion = useCallback((timestamp: number, url: string) => {\n        setPendingChanges(prev => {\n            const newDeletions = prev.deletedTimestamps.includes(timestamp)\n                ? prev.deletedTimestamps\n                : [...prev.deletedTimestamps, timestamp];\n\n            // If deleting the current thumbnail, mark it as cleared\n            const shouldClearThumbnail = url === currentThumbnail ||\n                (prev.thumbnailUrl === null && url === currentThumbnail) ||\n                url === prev.thumbnailUrl;\n\n            return {\n                thumbnailUrl: shouldClearThumbnail ? '' : prev.thumbnailUrl,\n                deletedTimestamps: newDeletions\n            };\n        });\n\n        // Adjust selection if we're deleting the currently selected item\n        // This will be handled by the useEffect that keeps selection in bounds\n    }, [currentThumbnail]);\n\n    /**\n     * Sets the pending thumbnail to apply.\n     */\n    const setPendingThumbnail = useCallback((url: string) => {\n        setPendingChanges(prev => ({\n            ...prev,\n            thumbnailUrl: url\n        }));\n    }, []);\n\n    /**\n     * Discards all pending changes (Cancel action).\n     * Restores state to what it was when modal opened.\n     */\n    const discardChanges = useCallback(() => {\n        setPendingChanges({\n            thumbnailUrl: null,\n            deletedTimestamps: []\n        });\n    }, []);\n\n    /**\n     * Returns the changes to apply (Apply action).\n     */\n    const getChangesToApply = useCallback(() => ({\n        thumbnailUrl: pendingChanges.thumbnailUrl,\n        deletedTimestamps: pendingChanges.deletedTimestamps\n    }), [pendingChanges]);\n\n    // === Computed Values ===\n    // Selected version from VISIBLE history (not original)\n    const selectedVersion = visibleHistory[selectedIndex];\n\n    const hasPendingChanges = pendingChanges.thumbnailUrl !== null ||\n        pendingChanges.deletedTimestamps.length > 0;\n\n    return {\n        // Navigation\n        selectedIndex,\n        direction,\n        isAnimating,\n        selectedVersion,\n\n        // Visible history\n        visibleHistory,\n\n        // Pending changes\n        pendingChanges,\n        hasPendingChanges,\n        effectiveCurrentThumbnail,\n\n        // Tooltips\n        openTooltipTimestamp,\n        isCurrentTooltipOpen,\n        isHistoricalTooltipOpen,\n\n        // Navigation handlers\n        handleNext,\n        handlePrev,\n        handleThumbnailSelect,\n        onAnimationComplete,\n\n        // Tooltip handlers\n        setOpenTooltipTimestamp,\n        setIsCurrentTooltipOpen,\n        setIsHistoricalTooltipOpen,\n\n        // Change management\n        markForDeletion,\n        setPendingThumbnail,\n        discardChanges,\n        getChangesToApply\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/Tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/VideoCardSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/VideoPreviewTooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/Shared/YouTubeCreateIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/auth/ProtectedRoute.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/providers/QueryProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/TagsInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/atoms/Badge/Badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/atoms/Badge/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/atoms/Button/Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/atoms/Button/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/atoms/Checkbox/Checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/atoms/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/molecules/FilterChips.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/molecules/FilterDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/molecules/SegmentedControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/molecules/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/components/ui/organisms/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/config/firebase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/config/firebaseConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/constants/enums.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/constants/languages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/contexts/VideoPlayerContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Move your React context(s) to a separate file.","line":15,"column":14,"nodeType":"Identifier","messageId":"reactContext","endLine":15,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useState, useCallback, useMemo } from 'react';\n\ninterface VideoPlayerState {\n    activeVideoId: string | null;\n    isMinimized: boolean;\n    videoTitle?: string; // Optional title for the mini player\n}\n\ninterface VideoPlayerContextType extends VideoPlayerState {\n    minimize: (videoId: string, title?: string) => void;\n    close: () => void;\n    maximize: () => void; // Potential future use, or just to un-minimize if we had a full modal\n}\n\nexport const VideoPlayerContext = createContext<VideoPlayerContextType | null>(null);\n\nexport const VideoPlayerProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n    const [state, setState] = useState<VideoPlayerState>({\n        activeVideoId: null,\n        isMinimized: false,\n        videoTitle: undefined\n    });\n\n    const minimize = useCallback((videoId: string, title?: string) => {\n        setState({\n            activeVideoId: videoId,\n            isMinimized: true,\n            videoTitle: title\n        });\n    }, []);\n\n    const close = useCallback(() => {\n        setState({\n            activeVideoId: null,\n            isMinimized: false,\n            videoTitle: undefined\n        });\n    }, []);\n\n    const maximize = useCallback(() => {\n        // For now, this effectively closes the mini-player as we don't have a \"maximized\" modal mode \n        // distinct from the tooltip (which is ephemeral). \n        // In the future this could open a full mock-modal.\n        setState(prev => ({ ...prev, isMinimized: false }));\n    }, []);\n\n    const value = useMemo(() => ({\n        ...state,\n        minimize,\n        close,\n        maximize\n    }), [state, minimize, close, maximize]);\n\n    return (\n        <VideoPlayerContext.Provider value={value}>\n            {children}\n        </VideoPlayerContext.Provider>\n    );\n};\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useApiKey.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useAutoCleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useAutoSync.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'generalSettings'. Either include it or remove the dependency array.","line":102,"column":8,"nodeType":"ArrayExpression","endLine":111,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [user, currentChannel, syncSettings, generalSettings.apiKey, syncAllVideos, updateSyncSettings, addNotification, isLoading, generalSettings]","fix":{"range":[4380,4573],"text":"[user, currentChannel, syncSettings, generalSettings.apiKey, syncAllVideos, updateSyncSettings, addNotification, isLoading, generalSettings]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef } from 'react';\nimport { useSettings } from './useSettings';\nimport { useVideoSync } from './useVideoSync';\n\nimport { useAuth } from './useAuth';\nimport { useChannelStore } from '../stores/channelStore';\nimport { useNotificationStore } from '../stores/notificationStore';\n\nexport const useAutoSync = () => {\n    const { syncSettings, updateSyncSettings, generalSettings, isLoading } = useSettings();\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { syncAllVideos } = useVideoSync(user?.uid || '', currentChannel?.id || '');\n    const { addNotification } = useNotificationStore.getState();\n\n    const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const lastAlertRef = useRef<number>(0);\n\n    useEffect(() => {\n        const checkAndSync = async () => {\n            if (!user || !currentChannel || !syncSettings.autoSync || isLoading) return;\n\n            const now = Date.now();\n            const lastSync = syncSettings.lastGlobalSync || 0;\n            const frequencyMs = syncSettings.frequencyHours * 60 * 60 * 1000;\n            const nextSyncTime = lastSync + frequencyMs;\n\n            if (now >= nextSyncTime) {\n                console.log('[AutoSync] Checking API Key:', {\n                    apiKey: generalSettings.apiKey,\n                    hasKey: !!generalSettings.apiKey,\n                    settings: generalSettings\n                });\n\n                // Time to sync!\n                if (!generalSettings.apiKey) {\n                    // Check if we already have a recent \"Missing API Key\" notification (e.g., last 24h)\n                    // to avoid spamming the user every time the interval hits.\n                    const { notifications } = useNotificationStore.getState();\n\n                    // Check both the store (persistent) and our local ref (immediate)\n                    const hasRecentAlertInStore = notifications.some(n =>\n                        n.title === 'Auto-Sync Failed' &&\n                        n.message.includes('Missing API Key') &&\n                        (now - (n.timestamp || 0)) < 24 * 60 * 60 * 1000 // 24 hours\n                    );\n\n\n\n                    const hasRecentAlertLocal = (now - lastAlertRef.current) < 24 * 60 * 60 * 1000;\n\n                    if (!hasRecentAlertInStore && !hasRecentAlertLocal) {\n                        lastAlertRef.current = now; // Update local ref immediately\n                        addNotification({\n                            title: 'Auto-Sync Failed',\n                            message: 'Missing API Key. Please configure it in Settings.',\n                            type: 'error',\n                            link: 'settings'\n                        });\n                    }\n\n                    // IMPORTANT: Update lastGlobalSync even if we failed/skipped due to missing key.\n                    // This prevents the system from retrying immediately and getting into a loop.\n                    // It will try again after the configured frequencyHours.\n                    updateSyncSettings(user.uid, currentChannel.id, {\n                        ...syncSettings,\n                        lastGlobalSync: Date.now()\n                    });\n                    return;\n                }\n\n                await syncAllVideos(generalSettings.apiKey);\n\n                // Update last sync time\n                updateSyncSettings(user.uid, currentChannel.id, {\n                    ...syncSettings,\n                    lastGlobalSync: Date.now()\n                });\n            } else {\n                // Schedule next check\n                const delay = nextSyncTime - now;\n                if (timeoutRef.current) clearTimeout(timeoutRef.current);\n                timeoutRef.current = setTimeout(checkAndSync, delay);\n            }\n        };\n\n        // 1. Check on mount / settings change\n        checkAndSync();\n\n        // 2. Check on tab focus\n        const handleVisibilityChange = () => {\n            if (document.visibilityState === 'visible') {\n                checkAndSync();\n            }\n        };\n        document.addEventListener('visibilitychange', handleVisibilityChange);\n\n        return () => {\n            if (timeoutRef.current) clearTimeout(timeoutRef.current);\n            document.removeEventListener('visibilitychange', handleVisibilityChange);\n        };\n    }, [\n        user,\n        currentChannel,\n        syncSettings,\n        generalSettings.apiKey,\n        syncAllVideos,\n        updateSyncSettings,\n        addNotification,\n        isLoading\n    ]);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useChannels.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useCheckinScheduler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3485,3488],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3485,3488],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3493,3496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3493,3496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4291,4294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4291,4294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4299,4302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4299,4302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'updateVideo'. Either include it or remove the dependency array.","line":131,"column":8,"nodeType":"ArrayExpression","endLine":131,"endColumn":87,"suggestions":[{"desc":"Update the dependencies array to be: [videos, packagingSettings, notifications, addNotification, removeNotification, updateVideo]","fix":{"range":[6383,6462],"text":"[videos, packagingSettings, notifications, addNotification, removeNotification, updateVideo]"}}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef } from 'react';\nimport { useVideos } from './useVideos';\nimport { useAuth } from './useAuth';\nimport { useChannelStore } from '../stores/channelStore';\n\nimport { useSettings } from './useSettings';\nimport { useNotificationStore } from '../stores/notificationStore';\nimport { calculateDueDate } from '../utils/dueDateUtils';\n\nexport const useCheckinScheduler = () => {\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { videos, updateVideo } = useVideos(user?.uid || '', currentChannel?.id || '');\n    const { packagingSettings } = useSettings();\n    const { notifications, addNotification, removeNotification } = useNotificationStore();\n\n    const processedIdsRef = useRef(new Set<string>());\n\n    useEffect(() => {\n        const checkDueCheckins = async () => {\n            const now = Date.now();\n            const customVideos = videos.filter(v => v.isCustom && v.publishedVideoId);\n\n            for (const video of customVideos) {\n                // Use YouTube's publishedAt from mergedVideoData if available, fallback to video.publishedAt\n                const publishedAt = video.mergedVideoData?.publishedAt || video.publishedAt;\n                if (!publishedAt) continue;\n\n                for (const rule of packagingSettings.checkinRules) {\n                    // Calculate due time using utility that accounts for YouTube analytics update at 12:00\n                    const dueTime = calculateDueDate(publishedAt, rule.hoursAfterPublish);\n\n                    const notificationId = `checkin-due-${video.id}-${rule.id}`;\n\n                    // Check if this check-in has already been done (exists in history)\n                    const videoHistory = video.packagingHistory || [];\n                    let existingCheckin = videoHistory.flatMap(v => v.checkins).find(c => c.ruleId === rule.id);\n\n                    const isCheckinComplete = existingCheckin && (existingCheckin.metrics.ctr !== null || existingCheckin.metrics.impressions !== null || existingCheckin.metrics.views !== null);\n\n                    if (isCheckinComplete) {\n                        // If job is done, remove the notification if it exists\n                        const existingNotification = notifications.find(n => n.internalId === notificationId);\n                        if (existingNotification) {\n                            await removeNotification(existingNotification.id);\n                        }\n                        processedIdsRef.current.delete(notificationId);\n                        continue;\n                    }\n\n                    // If it's not due yet, skip\n                    if (now < dueTime) {\n                        continue;\n                    }\n\n                    // It IS due (or past due).\n\n                    // CRITICAL CHANGE: If it's due but MISSING in DB, we must CREATE it now.\n                    // This ensures Notification implies Checkin Row Exists.\n                    if (!existingCheckin) {\n                        // We need to add it to the LATEST version.\n                        // Clone history to avoid mutation\n                        const newHistory = JSON.parse(JSON.stringify(videoHistory));\n                        if (newHistory.length === 0) continue; // Should have history if custom? If not, maybe skip or create v1? Let's skip for safety if no version exists.\n\n                        // Sort by version desc\n                        newHistory.sort((a: any, b: any) => b.versionNumber - a.versionNumber);\n                        const latestVersion = newHistory[0];\n\n                        const newCheckin = {\n                            id: crypto.randomUUID(),\n                            date: dueTime, // Use the scheduled time, not 'now', for accuracy\n                            metrics: {\n                                impressions: null,\n                                ctr: null,\n                                views: null,\n                                avdSeconds: null\n                            },\n                            ruleId: rule.id\n                        };\n\n                        latestVersion.checkins.push(newCheckin);\n                        // Sort checkins by date\n                        latestVersion.checkins.sort((a: any, b: any) => a.date - b.date);\n\n                        // Update DB\n                        try {\n                            await updateVideo({\n                                videoId: video.id,\n                                updates: { packagingHistory: newHistory }\n                            });\n                            // Update local reference immediately so we don't try to add it again in next loop iteration (if it runs fast)\n                            existingCheckin = newCheckin;\n                        } catch (e) {\n                            console.error(\"Failed to auto-create checkin row\", e);\n                            continue; // Retry next loop\n                        }\n                    }\n\n                    // Now check Notification status\n                    const alreadyNotified = notifications.some(n => n.internalId === notificationId);\n                    const isProcessing = processedIdsRef.current.has(notificationId);\n\n                    if (alreadyNotified || isProcessing) continue;\n\n                    processedIdsRef.current.add(notificationId);\n\n                    try {\n                        await addNotification({\n                            title: 'Packaging Check-in Due',\n                            message: `Time to check in on \"${video.title}\" (${rule.badgeText})`,\n                            type: 'info',\n                            link: `/video/${video.id}`,\n                            internalId: notificationId,\n                            customColor: rule.badgeColor,\n                            thumbnail: video.thumbnail || video.customImage,\n                            isPersistent: true\n                        });\n                    } catch (e) {\n                        processedIdsRef.current.delete(notificationId);\n                        console.error(\"Failed to add notification\", e);\n                    }\n                }\n            }\n        };\n\n        checkDueCheckins();\n        const interval = setInterval(checkDueCheckins, 60000);\n\n        return () => clearInterval(interval);\n    }, [videos, packagingSettings, notifications, addNotification, removeNotification]);\n\n    // Cleanup Effect: Auto-remove duplicates\n    // This handles the transition from Random IDs to Deterministic IDs\n    useEffect(() => {\n        const deduplicate = async () => {\n            const groups = new Map<string, typeof notifications>();\n\n            notifications.forEach(n => {\n                if (n.internalId && n.internalId.startsWith('checkin-due-')) {\n                    const group = groups.get(n.internalId) || [];\n                    group.push(n);\n                    groups.set(n.internalId, group);\n                }\n            });\n\n            const idsToDelete: string[] = [];\n\n            for (const [internalId, group] of groups.entries()) {\n                if (group.length > 1) {\n                    // Strategy: Prefer the \"Idempotent\" one (ID === InternalID)\n                    const idempotentMatch = group.find(n => n.id === internalId);\n\n                    if (idempotentMatch) {\n                        // Keep the idempotent one, remove all leftovers\n                        group.forEach(n => {\n                            if (n.id !== internalId) idsToDelete.push(n.id);\n                        });\n                    } else {\n                        // Fallback: Keep the newest one\n                        group.sort((a, b) => b.timestamp - a.timestamp);\n                        // Remove all except the first (newest)\n                        for (let i = 1; i < group.length; i++) {\n                            idsToDelete.push(group[i].id);\n                        }\n                    }\n                }\n            }\n\n            if (idsToDelete.length > 0) {\n                // Use getState() to access the action directly without adding it to dependencies\n                useNotificationStore.getState().removeNotifications(idsToDelete);\n            }\n        };\n\n        // Debounce slightly to allow initial load to settle\n        const timeoutId = setTimeout(deduplicate, 2000);\n        return () => clearTimeout(timeoutId);\n    }, [notifications]);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useDebounce.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useFilterChannelSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useGlobalTimer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/usePlaylists.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useStoreInitialization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useThrottle.ts","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Date.now` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n/Users/muramets/Documents/youtube-interface/src/core/hooks/useThrottle.ts:12:28\n  10 | export function useThrottle<T>(value: T, limit: number = 16): T {\n  11 |     const [throttledValue, setThrottledValue] = useState<T>(value);\n> 12 |     const lastRan = useRef(Date.now());\n     |                            ^^^^^^^^^^ Cannot call impure function\n  13 |\n  14 |     useEffect(() => {\n  15 |         const now = Date.now();","line":12,"column":28,"nodeType":null,"endLine":12,"endColumn":38}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef } from 'react';\n\n/**\n * Throttle hook - limits how often a value updates.\n * Useful for expensive computations that don't need to run every frame.\n * \n * @param value - The value to throttle\n * @param limit - Minimum ms between updates (default: 16ms = ~60fps)\n */\nexport function useThrottle<T>(value: T, limit: number = 16): T {\n    const [throttledValue, setThrottledValue] = useState<T>(value);\n    const lastRan = useRef(Date.now());\n\n    useEffect(() => {\n        const now = Date.now();\n        const elapsed = now - lastRan.current;\n\n        if (elapsed >= limit) {\n            lastRan.current = now;\n            setThrottledValue(value);\n        } else {\n            const handler = setTimeout(() => {\n                lastRan.current = Date.now();\n                setThrottledValue(value);\n            }, limit - elapsed);\n\n            return () => clearTimeout(handler);\n        }\n    }, [value, limit]);\n\n    return throttledValue;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useThumbnailActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1976,1979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1976,1979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3883,3886],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3883,3886],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5969,5972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5969,5972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport { deleteField } from 'firebase/firestore';\nimport { useAuth } from './useAuth';\nimport { useChannelStore } from '../stores/channelStore';\nimport { useVideos } from './useVideos';\nimport { deleteImageFromStorage } from '../services/storageService';\n\n/**\n * Hook for managing thumbnail version actions (like, remove)\n */\nexport const useThumbnailActions = (videoId: string) => {\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { updateVideo, removeVideo, videos } = useVideos(user?.uid || '', currentChannel?.id || '');\n\n    const handleLikeThumbnail = useCallback(async (version: number) => {\n        if (!user || !currentChannel) return;\n\n        const video = videos.find(v => v.id === videoId);\n        if (!video) return;\n\n        const likedVersions = video.likedThumbnailVersions || [];\n        const isLiked = likedVersions.includes(version);\n\n        const updatedLikedVersions = isLiked\n            ? likedVersions.filter(v => v !== version)\n            : [...likedVersions, version];\n\n        await updateVideo({\n            videoId,\n            updates: { likedThumbnailVersions: updatedLikedVersions }\n        });\n    }, [user, currentChannel, videoId, videos, updateVideo]);\n\n    const handleRemoveThumbnail = useCallback(async (version: number) => {\n        if (!user || !currentChannel) return;\n\n        const video = videos.find(v => v.id === videoId);\n        if (!video) return;\n\n        console.log('[useThumbnailActions] Removing thumbnail version:', version, 'from video:', videoId, 'isCloned:', video.isCloned);\n\n        // If this is a clone, delete the clone AND remove thumbnail from original video's history\n        if (video.isCloned && video.clonedFromId) {\n            console.log('[useThumbnailActions] Deleting clone:', videoId);\n\n            // Execute operations in parallel to avoid race conditions (visual glitches)\n            const operations: Promise<any>[] = [removeVideo(videoId)];\n\n            // Find original video and update history if found\n            const originalVideo = videos.find(v => v.id === video.clonedFromId);\n            if (originalVideo) {\n                const updatedHistory = (originalVideo.coverHistory || []).filter(v => v.version !== version);\n                console.log('[useThumbnailActions] Removing from original video history:', video.clonedFromId, 'updated history:', updatedHistory);\n\n                operations.push(\n                    updateVideo({\n                        videoId: video.clonedFromId,\n                        updates: { coverHistory: updatedHistory }\n                    })\n                );\n            }\n\n            await Promise.all(operations);\n            return;\n        }\n\n        // For regular videos: remove from history and delete associated clones\n        const itemToRemove = (video.coverHistory || []).find(v => v.version === version);\n        const urlToCleanup = itemToRemove?.url;\n\n        const updatedHistory = (video.coverHistory || []).filter(v => v.version !== version);\n        console.log('[useThumbnailActions] Updated history:', updatedHistory);\n\n        // Smart Cleanup: Only delete from Storage if NOT referenced in packaging or current\n        if (urlToCleanup && urlToCleanup.includes('firebasestorage.googleapis.com')) {\n            const isUsedInPackaging = (video.packagingHistory || []).some(v =>\n                v.configurationSnapshot?.coverImage === urlToCleanup ||\n                v.configurationSnapshot?.abTestVariants?.includes(urlToCleanup)\n            );\n            const isCurrent = video.customImage === urlToCleanup;\n\n            if (!isUsedInPackaging && !isCurrent) {\n                console.log('[useThumbnailActions] Smart Cleanup: Deleting unused file from storage', urlToCleanup);\n                deleteImageFromStorage(urlToCleanup).catch((err: any) =>\n                    console.error('[useThumbnailActions] Failed to cleanup storage:', err)\n                );\n            } else {\n                console.log('[useThumbnailActions] Smart Cleanup: Preserving image (in use)', {\n                    isUsedInPackaging,\n                    isCurrent\n                });\n            }\n        }\n\n        // Find and remove associated clone\n        const cloneToRemove = videos.find(v =>\n            v.isCloned &&\n            v.clonedFromId === videoId &&\n            v.customImageVersion === version\n        );\n\n        if (cloneToRemove) {\n            console.log('[useThumbnailActions] Found clone to remove:', cloneToRemove.id);\n            await removeVideo(cloneToRemove.id);\n        }\n\n        // If removing current thumbnail, apply previous version from history (if exists)\n        if (video.customImageVersion === version) {\n            console.log('[useThumbnailActions] Removing current thumbnail');\n\n            // Find the most recent version in updated history\n            const previousVersion = updatedHistory.length > 0\n                ? updatedHistory.reduce((max, v) => v.version > max.version ? v : max)\n                : null;\n\n            if (previousVersion) {\n                console.log('[useThumbnailActions] Applying previous version:', previousVersion.version);\n                await updateVideo({\n                    videoId,\n                    updates: {\n                        customImage: previousVersion.url,\n                        customImageName: previousVersion.originalName,\n                        customImageVersion: previousVersion.version,\n                        coverHistory: updatedHistory\n                    }\n                });\n            } else {\n                console.log('[useThumbnailActions] No history left, clearing thumbnail');\n                await updateVideo({\n                    videoId,\n                    updates: {\n                        customImage: '',\n                        customImageName: '',\n                        customImageVersion: deleteField() as any,\n                        coverHistory: updatedHistory\n                    }\n                });\n            }\n        } else {\n            console.log('[useThumbnailActions] Updating history only');\n            await updateVideo({\n                videoId,\n                updates: { coverHistory: updatedHistory }\n            });\n        }\n    }, [user, currentChannel, videoId, videos, updateVideo, removeVideo]);\n\n    return {\n        handleLikeThumbnail,\n        handleRemoveThumbnail\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useUserPersistence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useVideoFetchRetry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useVideoForm.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useVideoPlayer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useVideoSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1832,1835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1832,1835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":174,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7450,7453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7450,7453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { VideoService } from '../services/videoService';\nimport { fetchVideoDetails, fetchVideosBatch, type VideoDetails } from '../utils/youtubeApi';\nimport { useNotificationStore } from '../stores/notificationStore';\nimport { useUIStore } from '../stores/uiStore';\n\nexport const useVideoSync = (userId: string, channelId: string) => {\n    const [isSyncing, setIsSyncing] = useState(false);\n    const queryClient = useQueryClient();\n    const queryKey = ['videos', userId, channelId];\n\n    const syncVideo = async (videoId: string, apiKey: string, options: { silent?: boolean } = {}) => {\n        const videos = queryClient.getQueryData<VideoDetails[]>(queryKey) || [];\n        const video = videos.find(v => v.id === videoId);\n        if (!video) return;\n\n        const targetId = video.publishedVideoId || videoId;\n        if (video.isCustom && !video.publishedVideoId) return;\n\n        try {\n            const details = await fetchVideoDetails(targetId, apiKey);\n\n            if (details) {\n                const updates = video.publishedVideoId ? {\n                    mergedVideoData: details,\n                    lastUpdated: Date.now(),\n                    fetchStatus: 'success' as const,\n                    lastFetchAttempt: Date.now()\n                } : {\n                    ...details,\n                    lastUpdated: Date.now(),\n                    fetchStatus: 'success' as const,\n                    lastFetchAttempt: Date.now()\n                };\n\n                await VideoService.updateVideo(userId, channelId, videoId, updates);\n\n                if (!options.silent) {\n                    useUIStore.getState().showToast('Video synced successfully', 'success');\n                }\n            }\n        } catch (error: any) {\n            console.error('[useVideoSync] Sync failed for video:', videoId, error);\n            const isUnavailable = error.message === 'VIDEO_NOT_FOUND' || error.message === 'VIDEO_PRIVATE';\n\n            if (isUnavailable) {\n                await VideoService.updateVideo(userId, channelId, videoId, {\n                    fetchStatus: 'failed',\n                    lastFetchAttempt: Date.now()\n                    // Note: Do NOT set isPlaylistOnly here - that would hide the video from Home page\n                    // The video should still appear with an \"Unavailable\" placeholder\n                });\n\n                if (!options.silent) {\n                    useUIStore.getState().showToast('Video is no longer available on YouTube', 'error');\n                }\n            } else if (!options.silent) {\n                useUIStore.getState().showToast('Failed to sync video', 'error');\n            }\n        }\n    };\n\n    const syncAllVideos = async (apiKey: string) => {\n        if (isSyncing) return;\n        setIsSyncing(true);\n\n        try {\n            const videos = queryClient.getQueryData<VideoDetails[]>(queryKey) || [];\n            const syncableVideos = videos.filter(v => !v.isCustom && !v.isCloned);\n\n            if (syncableVideos.length === 0) return;\n\n            const CHUNK_SIZE = 50;\n            const now = Date.now();\n\n            for (let i = 0; i < syncableVideos.length; i += CHUNK_SIZE) {\n                const chunk = syncableVideos.slice(i, i + CHUNK_SIZE);\n                const videoIds = chunk.map(v => v.id);\n\n                try {\n                    const updatedDetails = await fetchVideosBatch(videoIds, apiKey);\n                    const returnedIds = new Set(updatedDetails.map(d => d.id));\n\n                    const updates: { videoId: string; data: Partial<VideoDetails> }[] = updatedDetails.map(details => ({\n                        videoId: details.id,\n                        data: {\n                            ...details,\n                            lastUpdated: now,\n                            fetchStatus: 'success',\n                            lastFetchAttempt: now\n                        }\n                    }));\n\n                    // Handle missing videos (likely deleted or private)\n                    videoIds.forEach(id => {\n                        if (!returnedIds.has(id)) {\n                            updates.push({\n                                videoId: id,\n                                data: {\n                                    fetchStatus: 'failed',\n                                    lastFetchAttempt: now\n                                }\n                            });\n                        }\n                    });\n\n                    if (updates.length > 0) {\n                        await VideoService.batchUpdateVideos(userId, channelId, updates);\n                    }\n                } catch (error: unknown) {\n                    console.error(\"Batch sync failed:\", error);\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n\n                    if (errorMessage.includes('403') || errorMessage.includes('quota')) {\n                        useNotificationStore.getState().addNotification({\n                            title: 'Auto-Sync Failed',\n                            message: 'YouTube API quota exceeded. Please try again later.',\n                            type: 'error'\n                        });\n                        break;\n                    }\n                }\n            }\n\n            const totalQuota = Math.ceil(syncableVideos.length / 50) * 2;\n            useNotificationStore.getState().addNotification({\n                title: 'Sync Completed',\n                message: `Successfully synced ${syncableVideos.length} videos.`,\n                type: 'success',\n                meta: `${totalQuota}`,\n                quotaBreakdown: {\n                    details: totalQuota\n                }\n            });\n\n        } catch (error) {\n            console.error(\"Global sync failed:\", error);\n            useNotificationStore.getState().addNotification({\n                title: 'Sync Failed',\n                message: 'An error occurred during synchronization.',\n                type: 'error'\n            });\n        } finally {\n            setIsSyncing(false);\n        }\n    };\n\n    const manualSync = async (apiKey: string, syncFrequencyHours: number) => {\n        if (isSyncing) return;\n        setIsSyncing(true);\n        try {\n            const videos = queryClient.getQueryData<VideoDetails[]>(queryKey) || [];\n            const now = Date.now();\n            const videosToUpdate = videos.filter(v => {\n                if (v.isCustom || v.isCloned) return false;\n                const lastUpdated = v.lastUpdated || 0;\n                const hoursSinceUpdate = (now - lastUpdated) / (1000 * 60 * 60);\n                return hoursSinceUpdate >= syncFrequencyHours;\n            });\n\n            if (videosToUpdate.length === 0) return;\n\n            const CHUNK_SIZE = 50;\n            for (let i = 0; i < videosToUpdate.length; i += CHUNK_SIZE) {\n                const chunk = videosToUpdate.slice(i, i + CHUNK_SIZE);\n                const updates: { videoId: string; data: Partial<VideoDetails> }[] = [];\n\n                const results = await Promise.all(\n                    chunk.map(async (video) => {\n                        try {\n                            const details = await fetchVideoDetails(video.id, apiKey);\n                            return details ? { videoId: video.id, details } : null;\n                        } catch (e: any) {\n                            console.error(`Failed to fetch details for ${video.id}`, e);\n                            const isUnavailable = e.message === 'VIDEO_NOT_FOUND' || e.message === 'VIDEO_PRIVATE';\n                            if (isUnavailable) {\n                                return { videoId: video.id, unavailable: true };\n                            }\n                            return null;\n                        }\n                    })\n                );\n\n                results.forEach(result => {\n                    if (result) {\n                        if ('unavailable' in result) {\n                            updates.push({\n                                videoId: result.videoId,\n                                data: {\n                                    fetchStatus: 'failed',\n                                    lastFetchAttempt: now\n                                }\n                            });\n                        } else {\n                            updates.push({\n                                videoId: result.videoId,\n                                data: {\n                                    ...result.details,\n                                    lastUpdated: now,\n                                    fetchStatus: 'success',\n                                    lastFetchAttempt: now\n                                }\n                            });\n                        }\n                    }\n                });\n\n                if (updates.length > 0) {\n                    await VideoService.batchUpdateVideos(userId, channelId, updates);\n                }\n            }\n\n        } catch (error) {\n            console.error(\"Sync failed:\", error);\n        } finally {\n            setIsSyncing(false);\n        }\n    };\n\n    return {\n        isSyncing,\n        syncVideo,\n        syncAllVideos,\n        manualSync\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/hooks/useVideos.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7064,7067],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7064,7067],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":144,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7146,7149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7146,7149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":161,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8135,8138],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8135,8138],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":162,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8208,8211],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8208,8211],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":163,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8282,8285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8282,8285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useEffect, useMemo, useCallback } from 'react';\nimport { deleteField } from 'firebase/firestore';\nimport { useChannelStore } from '../stores/channelStore';\nimport { VideoService } from '../services/videoService';\nimport { fetchVideoDetails, extractVideoId, type VideoDetails, type PackagingCheckin, type HistoryItem, type CoverVersion } from '../utils/youtubeApi';\nimport type { PackagingVersion } from '../types/versioning';\nimport { SettingsService } from '../services/settingsService';\n\n// Global set to track videos currently being deleted across all instances of the hook\n// This prevents \"flickering\" where a video reappears in one instance (e.g. HomePage)\n// because an unrelated update in another instance (e.g. VideoCard) triggered a snapshot\nconst terminatingVideoIds = new Set<string>();\n\n// Export the return type for use in other components\nexport interface UseVideosResult {\n    videos: VideoDetails[];\n    isLoading: boolean;\n    error: unknown;\n    addVideo: (vars: { url: string; apiKey: string }) => Promise<VideoDetails>;\n    addCustomVideo: (video: Omit<VideoDetails, 'id'> & { id?: string }) => Promise<string>;\n    updateVideo: (vars: { videoId: string; updates?: Partial<VideoDetails>; apiKey?: string; expectedRevision?: number }) => Promise<boolean>;\n    removeVideo: (videoId: string) => Promise<void>;\n    cloneVideo: (vars: { originalVideo: VideoDetails; coverVersion: CoverVersion | null; cloneDurationSeconds: number }) => Promise<void>;\n    saveDraft: (vars: { videoId: string; expectedRevision: number }) => Promise<void>;\n    createVersion: (vars: { videoId: string; snapshot: PackagingVersion['configurationSnapshot']; expectedRevision: number }) => Promise<void>;\n    addCheckin: (vars: { videoId: string; versionNumber: number; checkin: PackagingCheckin; expectedRevision: number }) => Promise<void>;\n    saveVideoHistory: (vars: { videoId: string; historyItem: HistoryItem }) => Promise<void>;\n    deleteVideoHistoryItem: (vars: { videoId: string; historyId: string }) => Promise<void>;\n    fetchVideoHistory: (videoId: string) => Promise<CoverVersion[]>;\n}\n\nexport const useVideos = (userId: string, channelId: string): UseVideosResult => {\n    const queryClient = useQueryClient();\n    const { currentChannel } = useChannelStore();\n    const queryKey = useMemo(() => ['videos', userId, channelId], [userId, channelId]);\n\n    const EMPTY_VIDEOS: VideoDetails[] = useMemo(() => [], []);\n    const { data: rawVideos, isLoading, error } = useQuery<VideoDetails[]>({\n        queryKey,\n        queryFn: async () => {\n            // Perform initial fetch to ensure isLoading is true until data arrives\n            const videos = await VideoService.fetchVideos(userId, channelId);\n\n            // Apply terminator filter to initial fetch too (prevents flicker if invalidation happens fast)\n            return videos.filter(v => !terminatingVideoIds.has(v.id));\n        },\n        staleTime: Infinity,\n        enabled: !!userId && !!channelId,\n    });\n\n    const videos = rawVideos || EMPTY_VIDEOS;\n\n    useEffect(() => {\n        if (!userId || !channelId) return;\n        const unsubscribe = VideoService.subscribeToVideos(userId, channelId, (data) => {\n            // Filter out videos that are currently being deleted\n            const filteredData = data.filter(v => !terminatingVideoIds.has(v.id));\n            queryClient.setQueryData(queryKey, filteredData);\n        });\n        return () => {\n            unsubscribe();\n        }\n    }, [userId, channelId, queryClient, queryKey]);\n\n    // 2. Mutations\n\n    // Add Video\n    const addVideoMutation = useMutation({\n        mutationFn: async ({ url, apiKey }: { url: string, apiKey: string }) => {\n            const videoId = extractVideoId(url);\n            if (!videoId) throw new Error('Invalid YouTube URL');\n\n            // Check if exists in current cache\n            const currentVideos = queryClient.getQueryData<VideoDetails[]>(queryKey) || [];\n            if (currentVideos.some(v => v.id === videoId)) throw new Error('Video already exists');\n\n            const details = await fetchVideoDetails(videoId, apiKey);\n            if (!details) throw new Error('Failed to fetch video details');\n\n            const videoWithTimestamp: VideoDetails = {\n                ...details,\n                createdAt: Date.now(),\n                addedToHomeAt: Date.now()\n            };\n\n            await VideoService.addVideo(userId, channelId, videoWithTimestamp);\n            return videoWithTimestamp;\n        }\n    });\n\n    // Add Custom Video\n    const addCustomVideoMutation = useMutation({\n        mutationFn: async (video: Omit<VideoDetails, 'id'> & { id?: string }) => {\n            const id = video.id || `custom-${Date.now()}`;\n            const newVideo: VideoDetails = {\n                ...video,\n                id,\n                isCustom: true,\n                channelTitle: video.channelTitle || currentChannel?.name || '',\n                channelAvatar: video.channelAvatar || currentChannel?.avatar || '',\n                viewCount: video.viewCount || '1000000',\n                createdAt: Date.now(),\n                addedToHomeAt: Date.now()\n            };\n\n            // Optimistic Order Update\n            const videoOrder = queryClient.getQueryData<string[]>(['settings', 'videoOrder', userId, channelId]) || [];\n            const newOrder = [id, ...videoOrder];\n\n            // Update cache and firestore\n            queryClient.setQueryData(['settings', 'videoOrder', userId, channelId], newOrder);\n            await SettingsService.updateVideoOrder(userId, channelId, newOrder);\n\n            await VideoService.addVideo(userId, channelId, newVideo);\n            return id;\n        }\n    });\n\n    // Update Video\n    const updateVideoMutation = useMutation({\n        mutationFn: async ({ videoId, updates, apiKey, expectedRevision }: { videoId: string, updates?: Partial<VideoDetails>, apiKey?: string, expectedRevision?: number }) => {\n            // Real update fetch logic\n            if (!videoId.startsWith('custom-') && !updates && apiKey) {\n                const details = await fetchVideoDetails(videoId, apiKey);\n                if (details) {\n                    await VideoService.updateVideo(userId, channelId, videoId, details);\n                    return true;\n                }\n                return false;\n            }\n\n            if (updates) {\n                const finalUpdates = { ...updates };\n                // Merged video logic\n                if (updates.publishedVideoId && apiKey) {\n                    try {\n                        const mergedDetails = await fetchVideoDetails(updates.publishedVideoId, apiKey);\n                        if (mergedDetails) {\n                            finalUpdates.mergedVideoData = mergedDetails;\n                            // Clear retry state on success\n                            finalUpdates.fetchStatus = 'success';\n                            finalUpdates.fetchRetryCount = deleteField() as any;\n                            finalUpdates.lastFetchAttempt = deleteField() as any;\n                        } else {\n                            // Failed to fetch - initialize retry state\n                            finalUpdates.fetchStatus = 'pending';\n                            finalUpdates.fetchRetryCount = 0;\n                            finalUpdates.lastFetchAttempt = Date.now();\n                        }\n                    } catch (error) {\n                        console.error(\"Failed to fetch merged video details:\", error);\n                        // Initialize retry state on error\n                        finalUpdates.fetchStatus = 'pending';\n                        finalUpdates.fetchRetryCount = 0;\n                        finalUpdates.lastFetchAttempt = Date.now();\n                    }\n                } else if (updates.publishedVideoId === '') {\n                    // Clearing publishedVideoId - reset all related fields\n                    delete finalUpdates.mergedVideoData;\n                    finalUpdates.fetchStatus = deleteField() as any;\n                    finalUpdates.fetchRetryCount = deleteField() as any;\n                    finalUpdates.lastFetchAttempt = deleteField() as any;\n                }\n\n                if (expectedRevision !== undefined) {\n                    await VideoService.updateVideoSafe(userId, channelId, videoId, finalUpdates, expectedRevision);\n                } else {\n                    await VideoService.updateVideo(userId, channelId, videoId, finalUpdates);\n                }\n                return true;\n            }\n            return false;\n        }\n    });\n\n    // Remove Video\n    const removeVideoMutation = useMutation({\n        mutationFn: async (videoId: string) => {\n            await VideoService.deleteVideo(userId, channelId, videoId);\n        },\n        onMutate: async (videoId: string) => {\n            // Cancel any outgoing refetches\n            await queryClient.cancelQueries({ queryKey: ['videos', userId, channelId] });\n\n            // Mark video as being terminated globally\n            terminatingVideoIds.add(videoId);\n\n            // Snapshot the previous value\n            const previousVideos = queryClient.getQueryData<VideoDetails[]>(['videos', userId, channelId]);\n\n            // Optimistically update to remove the video\n            queryClient.setQueryData<VideoDetails[]>(['videos', userId, channelId], (old) => {\n                if (!old) return old;\n                return old.filter(v => v.id !== videoId);\n            });\n\n            // Return context with the snapshotted value\n            return { previousVideos };\n        },\n        onError: (_err, videoId, context) => {\n            // Remove from terminating set on error\n            terminatingVideoIds.delete(videoId);\n\n            // If the mutation fails, use the context returned from onMutate to roll back\n            if (context?.previousVideos) {\n                queryClient.setQueryData(['videos', userId, channelId], context.previousVideos);\n            }\n        },\n        onSettled: (_data, _error, videoId) => {\n            // Remove from terminating set when done (success or error) after a delay\n            // to allow for consistency propagation\n            setTimeout(() => {\n                terminatingVideoIds.delete(videoId);\n            }, 3000);\n\n            // Still invalidate to ensure we have the correct state eventually\n            queryClient.invalidateQueries({ queryKey: ['videos', userId, channelId] });\n        }\n    });\n\n    // Clone Video\n    const cloneVideoMutation = useMutation({\n        mutationFn: async ({ originalVideo, coverVersion, cloneDurationSeconds }: { originalVideo: VideoDetails, coverVersion: CoverVersion | null, cloneDurationSeconds: number }) => {\n            const now = Date.now();\n            const id = `clone-${now}-${Math.random().toString(36).substr(2, 9)}`;\n            const expiresAt = now + (cloneDurationSeconds * 1000);\n\n            const newVideo: VideoDetails = {\n                ...originalVideo,\n                id,\n                channelId: originalVideo.channelId || channelId,\n                channelTitle: originalVideo.channelTitle || currentChannel?.name || '',\n                channelAvatar: originalVideo.channelAvatar || currentChannel?.avatar || '',\n                viewCount: originalVideo.viewCount || '1000000',\n                publishedAt: originalVideo.publishedAt || new Date().toISOString(),\n                isCustom: true,\n                isCloned: true,\n                clonedFromId: originalVideo.id,\n                createdAt: now,\n                expiresAt,\n                customImage: coverVersion?.url || originalVideo.customImage,\n                customImageName: coverVersion?.originalName || originalVideo.customImageName,\n                customImageVersion: coverVersion?.version || originalVideo.customImageVersion,\n                coverHistory: originalVideo.coverHistory || []\n            };\n\n            // Optimistic Order Update\n            const videoOrder = queryClient.getQueryData<string[]>(['settings', 'videoOrder', userId, channelId]) || [];\n            const newOrder = [id, ...videoOrder];\n\n            // Update cache and firestore\n            queryClient.setQueryData(['settings', 'videoOrder', userId, channelId], newOrder);\n            await SettingsService.updateVideoOrder(userId, channelId, newOrder);\n\n            await VideoService.addVideo(userId, channelId, newVideo);\n        }\n    });\n\n    // Packaging Mutations\n    const saveDraftMutation = useMutation({\n        mutationFn: async ({ videoId, expectedRevision }: { videoId: string, expectedRevision: number }) => {\n            await VideoService.updateVideoSafe(userId, channelId, videoId, { isDraft: true }, expectedRevision);\n        }\n    });\n\n    const createVersionMutation = useMutation({\n        mutationFn: async ({ videoId, snapshot, expectedRevision }: { videoId: string, snapshot: PackagingVersion['configurationSnapshot'], expectedRevision: number }) => {\n            const video = (queryClient.getQueryData<VideoDetails[]>(queryKey) || []).find(v => v.id === videoId);\n            if (!video) return;\n\n            const currentHistory = video.packagingHistory || [];\n            const nextVersionNumber = currentHistory.length > 0\n                ? Math.max(...currentHistory.map(v => v.versionNumber)) + 1\n                : 1;\n\n            const newVersion: PackagingVersion = {\n                versionNumber: nextVersionNumber,\n                startDate: Date.now(),\n                endDate: null,\n                configurationSnapshot: snapshot,\n                revision: 1, // Start revision at 1 for the first snapshot in this version object? \n                // Wait, packagingRevision is at video level. This is fine.\n                checkins: [{\n                    id: `v${nextVersionNumber}-creation`,\n                    date: Date.now(),\n                    metrics: {\n                        impressions: 0,\n                        ctr: 0,\n                        views: 0,\n                        avdSeconds: 0\n                    }\n                }]\n            };\n\n            const updatedHistory = [...currentHistory, newVersion];\n            await VideoService.updateVideoSafe(userId, channelId, videoId, {\n                packagingHistory: updatedHistory,\n                isDraft: false\n            }, expectedRevision);\n        }\n    });\n\n    const addCheckinMutation = useMutation({\n        mutationFn: async ({ videoId, versionNumber, checkin, expectedRevision }: { videoId: string, versionNumber: number, checkin: PackagingCheckin, expectedRevision: number }) => {\n            const video = (queryClient.getQueryData<VideoDetails[]>(queryKey) || []).find(v => v.id === videoId);\n            if (!video || !video.packagingHistory) return;\n\n            const updatedHistory = video.packagingHistory.map(version => {\n                if (version.versionNumber === versionNumber) {\n                    return {\n                        ...version,\n                        checkins: [...version.checkins, checkin]\n                    };\n                }\n                return version;\n            });\n\n            await VideoService.updateVideoSafe(userId, channelId, videoId, { packagingHistory: updatedHistory }, expectedRevision);\n        }\n    });\n\n    // History Mutations\n    const saveVideoHistoryMutation = useMutation({\n        mutationFn: async ({ videoId, historyItem }: { videoId: string, historyItem: HistoryItem }) => {\n            await VideoService.saveVideoHistory(userId, channelId, videoId, historyItem);\n        }\n    });\n\n    const deleteVideoHistoryItemMutation = useMutation({\n        mutationFn: async ({ videoId, historyId }: { videoId: string, historyId: string }) => {\n            await VideoService.deleteVideoHistoryItem(userId, channelId, videoId, historyId);\n        }\n    });\n\n    return {\n        videos,\n        isLoading,\n        error,\n        addVideo: addVideoMutation.mutateAsync,\n        addCustomVideo: addCustomVideoMutation.mutateAsync,\n        updateVideo: updateVideoMutation.mutateAsync,\n        removeVideo: removeVideoMutation.mutateAsync,\n        cloneVideo: cloneVideoMutation.mutateAsync,\n        saveDraft: saveDraftMutation.mutateAsync,\n        createVersion: createVersionMutation.mutateAsync,\n        addCheckin: addCheckinMutation.mutateAsync,\n        saveVideoHistory: saveVideoHistoryMutation.mutateAsync,\n        deleteVideoHistoryItem: deleteVideoHistoryItemMutation.mutateAsync,\n        fetchVideoHistory: useCallback((videoId: string) => VideoService.fetchVideoHistory(userId, channelId, videoId), [userId, channelId])\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/TrafficNicheService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2085,2088],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2085,2088],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n    collection,\n    doc,\n    onSnapshot,\n    query,\n    setDoc,\n    deleteDoc,\n    writeBatch,\n    deleteField\n} from 'firebase/firestore';\nimport { db } from '../../config/firebase';\nimport type { SuggestedTrafficNiche, TrafficNicheAssignment } from '../types/suggestedTrafficNiches';\n\nexport class TrafficNicheService {\n\n    // --- Niches ---\n\n    static subscribeToTrafficNiches(\n        userId: string,\n        channelId: string,\n        callback: (niches: SuggestedTrafficNiche[]) => void\n    ) {\n        if (!userId || !channelId) return () => { };\n\n        const path = `users/${userId}/channels/${channelId}/suggested_traffic_niches`;\n        const q = query(collection(db, path));\n\n        return onSnapshot(q, (snapshot) => {\n            const niches = snapshot.docs.map(doc => doc.data() as SuggestedTrafficNiche);\n            // Sort by creation time desc (newest first)\n            niches.sort((a, b) => b.createdAt - a.createdAt);\n            callback(niches);\n        }, (error) => {\n            console.error(\"Error subscribing to suggested traffic niches:\", error);\n            callback([]);\n        });\n    }\n\n    static async addTrafficNiche(\n        userId: string,\n        channelId: string,\n        niche: Omit<SuggestedTrafficNiche, 'createdAt'>\n    ): Promise<void> {\n        if (!userId || !channelId) return;\n\n        const path = `users/${userId}/channels/${channelId}/suggested_traffic_niches`;\n        const nicheRef = doc(db, path, niche.id);\n\n        await setDoc(nicheRef, {\n            ...niche,\n            createdAt: Date.now()\n        });\n    }\n\n    static async updateTrafficNiche(\n        userId: string,\n        channelId: string,\n        nicheId: string,\n        updates: Partial<SuggestedTrafficNiche>\n    ): Promise<void> {\n        if (!userId || !channelId) return;\n\n        const path = `users/${userId}/channels/${channelId}/suggested_traffic_niches`;\n        const nicheRef = doc(db, path, nicheId);\n\n        // Prepare updates: if value is undefined, use deleteField() to remove it from Firestore\n        const firestoreUpdates: any = { ...updates };\n        Object.keys(firestoreUpdates).forEach(key => {\n            if (firestoreUpdates[key] === undefined) {\n                firestoreUpdates[key] = deleteField();\n            }\n        });\n\n        await setDoc(nicheRef, firestoreUpdates, { merge: true });\n    }\n\n    static async deleteTrafficNiche(\n        userId: string,\n        channelId: string,\n        nicheId: string,\n        assignments: TrafficNicheAssignment[] // Pass current assignments to batch delete them\n    ): Promise<void> {\n        if (!userId || !channelId) return;\n\n        const batch = writeBatch(db);\n\n        // Delete the niche meta\n        const nichePath = `users/${userId}/channels/${channelId}/suggested_traffic_niches`;\n        const nicheRef = doc(db, nichePath, nicheId);\n        batch.delete(nicheRef);\n\n        // Delete all assignments for this niche\n        const assignmentsPath = `users/${userId}/channels/${channelId}/traffic_niche_assignments`;\n\n        // Filter assignments strictly for this niche\n        const relatedAssignments = assignments.filter(a => a.nicheId === nicheId);\n\n        relatedAssignments.forEach(assignment => {\n            // Assignment Key is typically composite videoId_nicheId for easy direct access, \n            // but here we might store them as individual docs. \n            // Let's assume ID is `${videoId}_${nicheId}`.\n            const assignmentId = `${assignment.videoId}_${assignment.nicheId}`;\n            const assignmentRef = doc(db, assignmentsPath, assignmentId);\n            batch.delete(assignmentRef);\n        });\n\n        await batch.commit();\n    }\n\n\n    // --- Assignments ---\n\n    static subscribeToTrafficAssignments(\n        userId: string,\n        channelId: string,\n        callback: (assignments: TrafficNicheAssignment[]) => void\n    ) {\n        if (!userId || !channelId) return () => { };\n\n        const path = `users/${userId}/channels/${channelId}/traffic_niche_assignments`;\n        const q = query(collection(db, path));\n\n        return onSnapshot(q, (snapshot) => {\n            const assignments = snapshot.docs.map(doc => doc.data() as TrafficNicheAssignment);\n            callback(assignments);\n        }, (error) => {\n            console.error(\"Error subscribing to traffic niche assignments:\", error);\n            callback([]);\n        });\n    }\n\n    static async assignVideoToTrafficNiche(\n        userId: string,\n        channelId: string,\n        videoId: string,\n        nicheId: string\n    ): Promise<void> {\n        if (!userId || !channelId) return;\n\n        const path = `users/${userId}/channels/${channelId}/traffic_niche_assignments`;\n        const assignmentId = `${videoId}_${nicheId}`;\n        const ref = doc(db, path, assignmentId);\n\n        const assignment: TrafficNicheAssignment = {\n            videoId,\n            nicheId,\n            addedAt: Date.now()\n        };\n\n        await setDoc(ref, assignment);\n    }\n\n    static async removeVideoFromTrafficNiche(\n        userId: string,\n        channelId: string,\n        videoId: string,\n        nicheId: string\n    ): Promise<void> {\n        if (!userId || !channelId) return;\n\n        const path = `users/${userId}/channels/${channelId}/traffic_niche_assignments`;\n        const assignmentId = `${videoId}_${nicheId}`;\n        const ref = doc(db, path, assignmentId);\n\n        await deleteDoc(ref);\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/TrafficTypeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/ViewerTypeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/channelService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/firestore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/notificationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/playlistService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/settingsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/storageService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[328,331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[328,331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":116,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3798,3801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3798,3801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5567,5570],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5567,5570],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { storage } from '../../config/firebase';\n\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';\n\nexport const deleteImageFromStorage = async (url: string): Promise<void> => {\n    try {\n        const storageRef = ref(storage, url);\n        await deleteObject(storageRef);\n    } catch (error: any) {\n        // Ignore \"object not found\" errors, as the file might already be gone\n        if (error.code !== 'storage/object-not-found') {\n            console.error('Error deleting image from storage:', error);\n            throw error;\n        }\n    }\n};\n\nexport const uploadImageToStorage = async (file: Blob, path: string): Promise<string> => {\n    const storageRef = ref(storage, path);\n    const metadata = {\n        cacheControl: 'public,max-age=31536000', // Cache for 1 year\n    };\n    const snapshot = await uploadBytes(storageRef, file, metadata);\n    return getDownloadURL(snapshot.ref);\n};\n\nexport const uploadBase64ToStorage = async (base64String: string, userId: string): Promise<string> => {\n    if (!base64String.startsWith('data:image')) return base64String;\n\n    const blob = dataURLtoBlob(base64String);\n    const timestamp = Date.now();\n    const randomId = Math.random().toString(36).substring(7);\n    const path = `covers/${userId}/legacy_${timestamp}_${randomId}.jpg`;\n\n    return uploadImageToStorage(blob, path);\n};\n\nexport const dataURLtoBlob = (dataurl: string): Blob => {\n    const arr = dataurl.split(',');\n    const mime = arr[0].match(/:(.*?);/)?.[1];\n    const bstr = atob(arr[1]);\n    let n = bstr.length;\n    const u8arr = new Uint8Array(n);\n    while (n--) {\n        u8arr[n] = bstr.charCodeAt(n);\n    }\n    return new Blob([u8arr], { type: mime });\n};\n\n// ============================================================================\n// CSV SNAPSHOT STORAGE (Hybrid Approach)\n// ============================================================================\n\n/**\n * BUSINESS LOGIC: CSV File Storage Management\n * \n * Storage Structure:\n * gs://bucket/users/{userId}/channels/{channelId}/videos/{videoId}/snapshots/{snapshotId}.csv\n * \n * Benefits:\n * - No Firestore document size limits (1MB)\n * - Cheaper storage costs\n * - Original CSV files preserved\n * - Scalable to thousands of snapshots\n */\n\n/**\n * Upload a CSV file to Cloud Storage.\n * \n * @param userId - User ID\n * @param channelId - Channel ID\n * @param videoId - Video ID\n * @param snapshotId - Unique snapshot ID (e.g., \"snap_1704672000000_v1\")\n * @param file - CSV file to upload\n * @returns Storage path and download URL\n */\nexport const uploadCsvSnapshot = async (\n    userId: string,\n    channelId: string,\n    videoId: string,\n    snapshotId: string,\n    file: File\n): Promise<{ storagePath: string; downloadUrl: string }> => {\n    try {\n        // Construct storage path\n        const storagePath = `users/${userId}/channels/${channelId}/videos/${videoId}/snapshots/${snapshotId}.csv`;\n        const storageRef = ref(storage, storagePath);\n\n        // Upload file with metadata\n        await uploadBytes(storageRef, file, {\n            contentType: 'text/csv',\n            customMetadata: {\n                snapshotId,\n                uploadedAt: new Date().toISOString()\n            }\n        });\n\n        // Get download URL\n        const downloadUrl = await getDownloadURL(storageRef);\n\n        return { storagePath, downloadUrl };\n    } catch (error) {\n        console.error('Error uploading CSV to Storage:', error);\n        throw error;\n    }\n};\n\n/**\n * Download a CSV file from Cloud Storage.\n * \n * @param storagePath - Full storage path (e.g., \"users/.../snap_v1.csv\")\n * @returns CSV file as Blob\n */\n// Helper to timeout a promise\nconst withTimeout = <T>(promise: Promise<T>, timeoutMs: number, errorMessage: string): Promise<T> => {\n    let timeoutId: any;\n    const timeoutPromise = new Promise<T>((_, reject) => {\n        timeoutId = setTimeout(() => {\n            reject(new Error(errorMessage));\n        }, timeoutMs);\n    });\n\n    return Promise.race([\n        promise.then((res) => {\n            clearTimeout(timeoutId);\n            return res;\n        }),\n        timeoutPromise\n    ]);\n};\n\n/**\n * Download a CSV file from Cloud Storage.\n * \n * @param storagePath - Full storage path (e.g., \"users/.../snap_v1.csv\")\n * @returns CSV file as Blob\n */\nexport const downloadCsvSnapshot = async (storagePath: string): Promise<Blob> => {\n    try {\n        const storageRef = ref(storage, storagePath);\n\n        // Add 15s timeout for getting URL\n        const downloadUrl = await withTimeout(\n            getDownloadURL(storageRef),\n            15000,\n            'Timeout getting download URL'\n        );\n\n        // Fetch the file with 30s timeout\n        const fetchPromise = fetch(downloadUrl + (downloadUrl.includes('?') ? '&' : '?') + `t=${Date.now()}`).then(async (response) => {\n            if (!response.ok) {\n                throw new Error(`Failed to download CSV: ${response.statusText}`);\n            }\n            return response.blob();\n        });\n\n        return await withTimeout(\n            fetchPromise,\n            30000,\n            'Timeout downloading CSV file'\n        );\n    } catch (error) {\n        console.error('Error downloading CSV from Storage:', error);\n        throw error;\n    }\n};\n\n/**\n * Delete a CSV file from Cloud Storage.\n * \n * @param storagePath - Full storage path\n */\nexport const deleteCsvSnapshot = async (storagePath: string): Promise<void> => {\n    try {\n        const storageRef = ref(storage, storagePath);\n        await deleteObject(storageRef);\n    } catch (error: any) {\n        // Ignore \"object not found\" errors\n        if (error.code !== 'storage/object-not-found') {\n            console.error('Error deleting CSV from Storage:', error);\n            throw error;\n        }\n    }\n};\n\n/**\n * Get download URL for a CSV file without downloading it.\n * \n * @param storagePath - Full storage path\n * @returns Download URL\n */\nexport const getCsvDownloadUrl = async (storagePath: string): Promise<string> => {\n    try {\n        const storageRef = ref(storage, storagePath);\n        return await getDownloadURL(storageRef);\n    } catch (error) {\n        console.error('Error getting download URL:', error);\n        throw error;\n    }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/traffic/TrafficDataService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4324,4327],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4324,4327],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5206,5209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5206,5209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5212,5215],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5212,5215],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5370,5373],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5370,5373],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '../../../config/firebase';\nimport { doc, setDoc, deleteField, getDocFromServer } from 'firebase/firestore';\nimport type { TrafficData, TrafficSource } from '../../types/traffic';\n\n/**\n *       .\n *   ,    .\n */\nexport const TrafficDataService = {\n    /**\n     * Gets the document reference for the main traffic data\n     */\n    getMainDocRef(userId: string, channelId: string, videoId: string) {\n        return doc(db, `users/${userId}/channels/${channelId}/videos/${videoId}/traffic/main`);\n    },\n\n    /**\n     *     \n     */\n    async fetch(userId: string, channelId: string, videoId: string): Promise<TrafficData | null> {\n        const path = `users/${userId}/channels/${channelId}/videos/${videoId}/traffic/main`;\n        try {\n            const docRef = doc(db, path);\n            // Use getDocFromServer to ensure we don't get stale cached data\n            const snapshot = await getDocFromServer(docRef);\n            if (snapshot.exists()) {\n                const data = snapshot.data() as TrafficData;\n                // Ensure array existence for older data\n                return {\n                    ...data,\n                    snapshots: data.snapshots || []\n                };\n            }\n            return null;\n        } catch (error) {\n            console.error('Error fetching traffic data:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * /  \n     */\n    async save(userId: string, channelId: string, videoId: string, data: TrafficData): Promise<void> {\n        const path = `users/${userId}/channels/${channelId}/videos/${videoId}/traffic/main`;\n        try {\n            const docRef = doc(db, path);\n            // Sanitize data to remove any undefined fields that Firestore rejects\n            const sanitizedData = TrafficDataService.sanitize(data);\n            await setDoc(docRef, sanitizedData, { merge: true });\n        } catch (error) {\n            console.error('Error saving traffic data:', error);\n            throw error;\n        }\n    },\n\n    /**\n     *   CSV   .\n     * - sources:     \n     * - groups:    \n     * - snapshots:    \n     */\n    merge(\n        currentData: TrafficData | null,\n        newSources: TrafficSource[],\n        newTotalRow?: TrafficSource\n    ): TrafficData {\n        const now = Date.now();\n        console.log('[TrafficDataService] merge:', {\n            newSourcesLen: newSources.length,\n            currentSnapshotsLen: currentData?.snapshots?.length\n        });\n\n        const merged: TrafficData = {\n            ...currentData,\n            lastUpdated: now,\n            sources: newSources,\n            totalRow: newTotalRow || currentData?.totalRow,\n            snapshots: currentData?.snapshots || []\n        } as TrafficData;\n\n        return merged;\n    },\n\n    /**\n     *     (sources  totalRow).\n     *     .\n     *   .\n     */\n    async clear(userId: string, channelId: string, videoId: string): Promise<void> {\n        console.log('[TrafficDataService] clear called');\n        const currentData = await TrafficDataService.fetch(userId, channelId, videoId);\n\n        const path = `users/${userId}/channels/${channelId}/videos/${videoId}/traffic/main`;\n        const docRef = doc(db, path);\n        try {\n            await setDoc(docRef, {\n                lastUpdated: Date.now(),\n                sources: [],\n                totalRow: deleteField(),\n                snapshots: currentData?.snapshots || [],\n                groups: currentData?.groups || []\n            }, { merge: true });\n            console.log('[TrafficDataService] Data cleared successfully');\n        } catch (e) {\n            console.error('[TrafficDataService] Failed to clear data:', e);\n            throw e;\n        }\n    },\n\n    /**\n     *  snapshots ( packaging snapshot preservation).\n     *       traffic .\n     */\n    async updateSnapshots(userId: string, channelId: string, videoId: string, snapshots: any[]): Promise<void> {\n        const currentData = await TrafficDataService.fetch(userId, channelId, videoId);\n        if (!currentData) return;\n\n        const path = `users/${userId}/channels/${channelId}/videos/${videoId}/traffic/main`;\n        const docRef = doc(db, path);\n\n        try {\n            // FIX: Sanitize snapshots to remove undefined fields (like abTestResults)\n            const sanitizedSnapshots = TrafficDataService.sanitize(snapshots);\n\n            await setDoc(docRef, {\n                ...currentData,\n                snapshots: sanitizedSnapshots,\n                lastUpdated: Date.now()\n            }, { merge: true });\n        } catch (error) {\n            console.error('Error updating snapshots:', error);\n            throw error;\n        }\n    },\n\n    /**\n     *    Firestore,  undefined \n     */\n    sanitize(data: any): any {\n        const json = JSON.parse(JSON.stringify(data));\n        // Remove undefined/null if they still exist for some reason\n        const clean = (obj: any) => {\n            Object.keys(obj).forEach(key => {\n                if (obj[key] === undefined) {\n                    delete obj[key];\n                } else if (obj[key] !== null && typeof obj[key] === 'object') {\n                    clean(obj[key]);\n                }\n            });\n            return obj;\n        };\n        return clean(json);\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/traffic/TrafficDeltaService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3514,3517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3514,3517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":119,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":122,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3889,3892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3889,3892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4353,4356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4353,4356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4956,4959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4956,4959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\nimport { TrafficDeltaService } from './TrafficDeltaService';\nimport type { TrafficSource } from '../../types/traffic';\n\n//   ()  ,    ,\n//      .\nvi.mock('./TrafficSnapshotService', () => ({\n    TrafficSnapshotService: {\n        getVersionSources: vi.fn()\n    }\n}));\n\ndescribe('TrafficDeltaService', () => {\n\n    //    \n    describe('calculateSourcesDelta', () => {\n        const currentData: TrafficSource[] = [\n            { sourceTitle: '', views: 100, impressions: 1000, watchTimeHours: 10, ctr: 10, videoId: 'v1', sourceType: 'TEST', avgViewDuration: '0:00' },\n            { sourceTitle: '', views: 50, impressions: 500, watchTimeHours: 5, ctr: 10, videoId: 'v2', sourceType: 'TEST', avgViewDuration: '0:00' }\n        ];\n\n        const previousData: TrafficSource[] = [\n            { sourceTitle: '', views: 60, impressions: 800, watchTimeHours: 6, ctr: 7.5, videoId: 'v1', sourceType: 'TEST', avgViewDuration: '0:00' },\n            { sourceTitle: '', views: 50, impressions: 500, watchTimeHours: 5, ctr: 10, videoId: 'v2', sourceType: 'TEST', avgViewDuration: '0:00' }\n        ];\n\n        it('      CTR', () => {\n            const result = TrafficDeltaService.calculateSourcesDelta(currentData, previousData);\n\n            //  '': 100 - 60 = 40 . 1000 - 800 = 200 .\n            // CTR = (40 / 200) * 100 = 20%\n            const searchDelta = result.sources.find(d => d.sourceTitle === '');\n            expect(searchDelta?.views).toBe(40);\n            expect(searchDelta?.ctr).toBe(20);\n        });\n\n        it('  () ,   0  ', () => {\n            const result = TrafficDeltaService.calculateSourcesDelta(currentData, previousData);\n\n            // '': 50 - 50 = 0.     .\n            const recDelta = result.sources.find(d => d.sourceTitle === '');\n            expect(recDelta).toBeUndefined();\n        });\n\n        it('   ,    ', () => {\n            const result = TrafficDeltaService.calculateSourcesDelta(currentData, []);\n            expect(result.sources.length).toBe(2);\n            expect(result.sources[0].views).toBe(100);\n        });\n    });\n\n    //      \n    describe('calculateVersionDelta', () => {\n        const currentSources: TrafficSource[] = [{ sourceTitle: 'X', views: 10, videoId: '1', sourceType: 'TEST', avgViewDuration: '0:00', impressions: 100, ctr: 10, watchTimeHours: 1 }];\n\n        it('   ,    ', async () => {\n            const result = await TrafficDeltaService.calculateVersionDelta(currentSources, undefined, 1, []);\n            expect(result.sources).toEqual(currentSources);\n        });\n\n        //     ,         \n        it('       ', async () => {\n            //   ,    \n            const { TrafficSnapshotService } = await import('./TrafficSnapshotService');\n\n            // \"\",    v.1  4 \n            (TrafficSnapshotService.getVersionSources as any).mockResolvedValue({\n                sources: [{ sourceTitle: 'X', views: 4, videoId: '1' }]\n            });\n\n            const snapshots = [\n                { version: 1, timestamp: 100 },\n                { version: 2, timestamp: 200 }\n            ];\n\n            const result = await TrafficDeltaService.calculateVersionDelta(currentSources, undefined, 2, snapshots as any);\n\n            // 10 - 4 = 6\n            expect(result.sources[0].views).toBe(6);\n        });\n\n        //     \n        it('  closingSnapshotId   ', async () => {\n            const { TrafficSnapshotService } = await import('./TrafficSnapshotService');\n\n            //      (v.3  8 )\n            (TrafficSnapshotService.getVersionSources as any).mockResolvedValue({\n                sources: [{ sourceTitle: 'X', views: 8, videoId: '1' }]\n            });\n\n            const snapshots = [\n                { id: 'snap-v1', version: 1, timestamp: 100 },\n                { id: 'snap-v2', version: 2, timestamp: 200 },\n                { id: 'snap-v3', version: 3, timestamp: 300 }\n            ];\n\n            //  v.1,  closingSnapshotId  v.3\n            const result = await TrafficDeltaService.calculateVersionDelta(\n                currentSources,\n                undefined,\n                1,\n                snapshots as any,\n                'snap-v3' //      \n            );\n\n            // 10 - 8 = 2 (   v.3,     < 1)\n            expect(result.sources[0].views).toBe(2);\n        });\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/traffic/TrafficDeltaService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/traffic/TrafficSnapshotService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1296,1299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1296,1299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1743,1746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1743,1746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2024,2027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2024,2027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":98,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":101,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2443,2446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2443,2446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\nimport { TrafficSnapshotService } from './TrafficSnapshotService';\n\n//    (    )\nvi.mock('./TrafficDataService', () => ({\n    TrafficDataService: {\n        fetch: vi.fn(),\n        save: vi.fn()\n    }\n}));\n\nvi.mock('../storageService', () => ({\n    uploadCsvSnapshot: vi.fn(),\n    downloadCsvSnapshot: vi.fn(),\n    deleteCsvSnapshot: vi.fn()\n}));\n\n//  :      CSV  , \n//   \nvi.mock('../../../pages/DetailsPage/tabs/Traffic/utils/csvParser', () => ({\n    parseTrafficCsv: vi.fn().mockResolvedValue({ sources: [{ sourceTitle: 'CSV Data' }] })\n}));\n\ndescribe('TrafficSnapshotService', () => {\n\n    describe('getVersionSources', () => {\n        const snapshots = [\n            { id: '1', version: 1, timestamp: 1000, sources: [{ sourceTitle: 'V1 Start' }] },\n            { id: '2', version: 1, timestamp: 20000, sources: [{ sourceTitle: 'V1 End' }] },\n            { id: '3', version: 2, timestamp: 30000, sources: [{ sourceTitle: 'V2' }] }\n        ];\n\n        it('       ', async () => {\n            const sources = await TrafficSnapshotService.getVersionSources(1, snapshots as any);\n\n            //   1   .     (V1 End).\n            expect(sources.sources[0].sourceTitle).toBe('V1 End');\n        });\n\n        it('       (  Restored )', async () => {\n            //   1,      0  5000\n            const sources = await TrafficSnapshotService.getVersionSources(1, snapshots as any, 0, 5000);\n\n            expect(sources.sources[0].sourceTitle).toBe('V1 Start');\n        });\n\n        it('   ,     ', async () => {\n            const sources = await TrafficSnapshotService.getVersionSources(99, snapshots as any);\n            expect(sources.sources).toEqual([]);\n        });\n\n        it('  \"\"  ( Cloud Storage),     ', async () => {\n            const hybridSnapshots = [\n                { id: 'h1', version: 3, timestamp: 5000, storagePath: 'test/path.csv' }\n            ];\n\n            const sources = await TrafficSnapshotService.getVersionSources(3, hybridSnapshots as any);\n\n            //    ,    'CSV Data'\n            expect(sources.sources[0].sourceTitle).toBe('CSV Data');\n        });\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/traffic/TrafficSnapshotService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/traffic/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/trendService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4130,4133],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4130,4133],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4991,4994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4991,4994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":594,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":594,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23442,23445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23442,23445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { openDB, type DBSchema, type IDBPDatabase } from 'idb';\nimport {\n    collection,\n    doc,\n    setDoc,\n    getDoc,\n    deleteDoc,\n    onSnapshot,\n    updateDoc,\n    writeBatch,\n    getDocs,\n    increment\n} from 'firebase/firestore';\nimport { db } from '../../config/firebase';\nimport type { TrendChannel, TrendVideo, TrendNiche, HiddenVideo } from '../types/trends';\n\n// IndexedDB Schema\ninterface TrendsDB extends DBSchema {\n    videos: {\n        key: string;\n        value: TrendVideo;\n        indexes: { 'by-channel': string; 'by-published': number };\n    };\n}\n\nlet dbPromise: Promise<IDBPDatabase<TrendsDB>>;\n\nconst getDB = () => {\n    if (!dbPromise) {\n        dbPromise = openDB<TrendsDB>('trends-db', 1, {\n            upgrade(db) {\n                const store = db.createObjectStore('videos', { keyPath: 'id' });\n                store.createIndex('by-channel', 'channelId');\n                store.createIndex('by-published', 'publishedAtTimestamp');\n            },\n        });\n    }\n    return dbPromise;\n};\n\nexport const TrendService = {\n    // --- Channel Management (Firestore) ---\n\n    subscribeToTrendChannels: (userId: string, userChannelId: string, callback: (channels: TrendChannel[]) => void) => {\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/trendChannels`);\n        return onSnapshot(ref, (snapshot) => {\n            const channels = snapshot.docs.map(doc => doc.data() as TrendChannel);\n            callback(channels);\n        });\n    },\n\n    // --- Niche Management (Firestore) ---\n\n    subscribeToNiches: (userId: string, userChannelId: string, callback: (niches: TrendNiche[]) => void) => {\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/trendNiches`);\n        return onSnapshot(ref, (snapshot) => {\n            const niches = snapshot.docs.map(doc => doc.data() as TrendNiche);\n            callback(niches);\n        });\n    },\n\n    addNiche: async (userId: string, userChannelId: string, niche: Omit<TrendNiche, 'createdAt' | 'viewCount'>) => {\n        const id = niche.id || crypto.randomUUID();\n        const fullNiche: TrendNiche = {\n            ...niche,\n            id,\n            viewCount: 0,\n            createdAt: Date.now()\n        };\n        await setDoc(doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, id), fullNiche);\n        return fullNiche;\n    },\n\n    updateNiche: async (userId: string, userChannelId: string, nicheId: string, updates: Partial<TrendNiche>) => {\n        const ref = doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, nicheId);\n        await updateDoc(ref, updates);\n    },\n\n    deleteNiche: async (userId: string, userChannelId: string, nicheId: string) => {\n        // Just delete the niche document. \n        // We leave the assignments as \"orphaned\" references - the UI naturally filters them out\n        // because it only renders/counts based on the implementation of the 'niches' list.\n        await deleteDoc(doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, nicheId));\n    },\n\n    // --- Niche View Count Recalculation (Global) ---\n\n\n    // --- Niche Assignment (Firestore) ---\n\n    subscribeToNicheAssignments: (userId: string, userChannelId: string, callback: (assignments: Record<string, { nicheId: string; addedAt: number }[]>) => void) => {\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`);\n        return onSnapshot(ref, (snapshot) => {\n            const data: Record<string, { nicheId: string; addedAt: number }[]> = {};\n            snapshot.docs.forEach(doc => {\n                data[doc.id] = doc.data().assignments || [];\n            });\n            callback(data);\n        });\n    },\n\n    assignVideoToNiche: async (userId: string, userChannelId: string, videoId: string, nicheId: string, videoViewCount: number) => {\n        const ref = doc(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`, videoId);\n        const snapshot = await getDoc(ref);\n        const current = snapshot.exists() ? (snapshot.data().assignments || []) : [];\n\n        if (current.some((a: any) => a.nicheId === nicheId)) return;\n\n        await setDoc(ref, {\n            assignments: [...current, { nicheId, addedAt: Date.now() }]\n        }, { merge: true });\n\n        // Atomic incremental update for niche viewCount\n        const nicheRef = doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, nicheId);\n        await updateDoc(nicheRef, {\n            viewCount: increment(videoViewCount)\n        });\n    },\n\n    removeVideoFromNiche: async (userId: string, userChannelId: string, videoId: string, nicheId: string, videoViewCount: number) => {\n        const ref = doc(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`, videoId);\n        const snapshot = await getDoc(ref);\n        if (!snapshot.exists()) return;\n\n        const current = snapshot.data().assignments || [];\n        const filtered = current.filter((a: any) => a.nicheId !== nicheId);\n\n        if (filtered.length === 0) {\n            await deleteDoc(ref);\n        } else {\n            await setDoc(ref, { assignments: filtered });\n        }\n\n        // Atomic incremental update for niche viewCount (decrement)\n        const nicheRef = doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, nicheId);\n        await updateDoc(nicheRef, {\n            viewCount: increment(-videoViewCount)\n        });\n    },\n\n    migrateLocalDataToFirestore: async (\n        userId: string,\n        userChannelId: string,\n        niches: TrendNiche[],\n        assignments: Record<string, { nicheId: string; addedAt: number }[]>,\n        hiddenVideos: HiddenVideo[] = []\n    ) => {\n        const nicheBatch = writeBatch(db);\n        niches.forEach(n => {\n            const ref = doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, n.id);\n            nicheBatch.set(ref, n);\n        });\n        await nicheBatch.commit();\n\n        const assignmentBatch = writeBatch(db);\n        Object.entries(assignments).forEach(([videoId, videoAssignments]) => {\n            const ref = doc(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`, videoId);\n            assignmentBatch.set(ref, { assignments: videoAssignments });\n        });\n        await assignmentBatch.commit();\n\n        if (hiddenVideos.length > 0) {\n            const hiddenBatch = writeBatch(db);\n            hiddenVideos.forEach(hv => {\n                const ref = doc(db, `users/${userId}/channels/${userChannelId}/hiddenVideos`, hv.id);\n                hiddenBatch.set(ref, hv);\n            });\n            await hiddenBatch.commit();\n        }\n    },\n\n    // --- Niche Split/Merge Operations ---\n\n    /**\n     * Batch create multiple niches at once\n     */\n    batchAddNiches: async (userId: string, userChannelId: string, niches: TrendNiche[]) => {\n        const batch = writeBatch(db);\n        niches.forEach(niche => {\n            const ref = doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, niche.id);\n            batch.set(ref, niche);\n        });\n        await batch.commit();\n    },\n\n    /**\n     * Batch delete multiple niches at once\n     */\n    batchDeleteNiches: async (userId: string, userChannelId: string, nicheIds: string[]) => {\n        const batch = writeBatch(db);\n        nicheIds.forEach(id => {\n            const ref = doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, id);\n            batch.delete(ref);\n        });\n        await batch.commit();\n    },\n\n    /**\n     * Get all video assignments for a specific niche, with video channel info\n     */\n    getVideoAssignmentsByNiche: async (\n        userId: string,\n        userChannelId: string,\n        nicheId: string,\n        videos: TrendVideo[]\n    ): Promise<{ videoId: string; channelId: string; viewCount: number }[]> => {\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`);\n        const snapshot = await getDocs(ref);\n\n        const videoMap = new Map(videos.map(v => [v.id, v]));\n        const results: { videoId: string; channelId: string; viewCount: number }[] = [];\n\n        snapshot.docs.forEach(docSnap => {\n            const videoId = docSnap.id;\n            const assignments = docSnap.data().assignments || [];\n            const isAssigned = assignments.some((a: { nicheId: string }) => a.nicheId === nicheId);\n\n            if (isAssigned) {\n                const video = videoMap.get(videoId);\n                if (video) {\n                    results.push({\n                        videoId,\n                        channelId: video.channelId,\n                        viewCount: video.viewCount\n                    });\n                }\n            }\n        });\n\n        return results;\n    },\n\n    /**\n     * Migrate all video assignments from one niche to another\n     */\n    migrateNicheAssignments: async (\n        userId: string,\n        userChannelId: string,\n        fromNicheId: string,\n        toNicheId: string\n    ) => {\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`);\n        const snapshot = await getDocs(ref);\n\n        const batch = writeBatch(db);\n\n        snapshot.docs.forEach(docSnap => {\n            const videoId = docSnap.id;\n            const assignments: { nicheId: string; addedAt: number }[] = docSnap.data().assignments || [];\n            const hasFromNiche = assignments.some(a => a.nicheId === fromNicheId);\n            const hasToNiche = assignments.some(a => a.nicheId === toNicheId);\n\n            if (hasFromNiche) {\n                // Remove fromNiche, add toNiche if not already present\n                const newAssignments = assignments.filter(a => a.nicheId !== fromNicheId);\n                if (!hasToNiche) {\n                    newAssignments.push({ nicheId: toNicheId, addedAt: Date.now() });\n                }\n\n                const docRef = doc(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`, videoId);\n                if (newAssignments.length === 0) {\n                    batch.delete(docRef);\n                } else {\n                    batch.set(docRef, { assignments: newAssignments });\n                }\n            }\n        });\n\n        await batch.commit();\n    },\n\n    /**\n     * Remove video-niche assignments for videos NOT from the specified channel\n     */\n    removeNonChannelAssignments: async (\n        userId: string,\n        userChannelId: string,\n        nicheId: string,\n        keepChannelId: string,\n        videos: TrendVideo[]\n    ) => {\n        const videoMap = new Map(videos.map(v => [v.id, v]));\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`);\n        const snapshot = await getDocs(ref);\n\n        const batch = writeBatch(db);\n        let removedViewCount = 0;\n\n        snapshot.docs.forEach(docSnap => {\n            const videoId = docSnap.id;\n            const video = videoMap.get(videoId);\n            const assignments: { nicheId: string; addedAt: number }[] = docSnap.data().assignments || [];\n\n            // Only process if video is NOT from keepChannelId and has this niche\n            if (video && video.channelId !== keepChannelId) {\n                const hasNiche = assignments.some(a => a.nicheId === nicheId);\n                if (hasNiche) {\n                    removedViewCount += video.viewCount;\n                    const newAssignments = assignments.filter(a => a.nicheId !== nicheId);\n\n                    const docRef = doc(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`, videoId);\n                    if (newAssignments.length === 0) {\n                        batch.delete(docRef);\n                    } else {\n                        batch.set(docRef, { assignments: newAssignments });\n                    }\n                }\n            }\n        });\n\n        await batch.commit();\n\n        // Update niche viewCount\n        if (removedViewCount > 0) {\n            const nicheRef = doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, nicheId);\n            await updateDoc(nicheRef, {\n                viewCount: increment(-removedViewCount)\n            });\n        }\n    },\n\n    /**\n     * Reassign videos from one niche to a new niche, filtered by channel\n     * Used during split operation\n     */\n    reassignVideosByChannel: async (\n        userId: string,\n        userChannelId: string,\n        fromNicheId: string,\n        toNicheId: string,\n        targetChannelId: string,\n        videos: TrendVideo[]\n    ) => {\n        const videoMap = new Map(videos.map(v => [v.id, v]));\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`);\n        const snapshot = await getDocs(ref);\n\n        const batch = writeBatch(db);\n        let movedViewCount = 0;\n\n        snapshot.docs.forEach(docSnap => {\n            const videoId = docSnap.id;\n            const video = videoMap.get(videoId);\n            const assignments: { nicheId: string; addedAt: number }[] = docSnap.data().assignments || [];\n\n            // Only process if video IS from targetChannelId and has fromNiche\n            if (video && video.channelId === targetChannelId) {\n                const hasFromNiche = assignments.some(a => a.nicheId === fromNicheId);\n                if (hasFromNiche) {\n                    movedViewCount += video.viewCount;\n\n                    // Replace fromNiche with toNiche\n                    const newAssignments = assignments\n                        .filter(a => a.nicheId !== fromNicheId)\n                        .concat([{ nicheId: toNicheId, addedAt: Date.now() }]);\n\n                    const docRef = doc(db, `users/${userId}/channels/${userChannelId}/videoNicheAssignments`, videoId);\n                    batch.set(docRef, { assignments: newAssignments });\n                }\n            }\n        });\n\n        await batch.commit();\n\n        // Update new niche viewCount\n        if (movedViewCount > 0) {\n            const nicheRef = doc(db, `users/${userId}/channels/${userChannelId}/trendNiches`, toNicheId);\n            await updateDoc(nicheRef, {\n                viewCount: increment(movedViewCount)\n            });\n        }\n\n        return movedViewCount;\n    },\n\n    // --- Hidden Videos (Firestore) ---\n\n    subscribeToHiddenVideos: (userId: string, userChannelId: string, callback: (hidden: HiddenVideo[]) => void) => {\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/hiddenVideos`);\n        return onSnapshot(ref, (snapshot) => {\n            callback(snapshot.docs.map(d => d.data() as HiddenVideo));\n        });\n    },\n\n    hideVideos: async (userId: string, userChannelId: string, videos: { id: string; channelId: string }[]) => {\n        const batch = writeBatch(db);\n        videos.forEach(v => {\n            const ref = doc(db, `users/${userId}/channels/${userChannelId}/hiddenVideos`, v.id);\n            batch.set(ref, { id: v.id, channelId: v.channelId, hiddenAt: Date.now() });\n        });\n        await batch.commit();\n    },\n\n    restoreVideos: async (userId: string, userChannelId: string, ids: string[]) => {\n        const batch = writeBatch(db);\n        ids.forEach(id => {\n            const ref = doc(db, `users/${userId}/channels/${userChannelId}/hiddenVideos`, id);\n            batch.delete(ref);\n        });\n        await batch.commit();\n    },\n\n    addTrendChannel: async (userId: string, userChannelId: string, channelUrl: string, apiKey: string) => {\n        // Smart Channel URL/Handle/ID Parser\n        let channelId = '';\n        let handle = '';\n\n        const input = channelUrl.trim();\n\n        // Try to parse as URL first\n        try {\n            const url = new URL(input.startsWith('http') ? input : `https://${input}`);\n            const pathname = url.pathname;\n\n            // Handle format: youtube.com/@handle or youtube.com/@handle/videos\n            const handleMatch = pathname.match(/\\/@([^/]+)/);\n            if (handleMatch) {\n                handle = '@' + handleMatch[1];\n            }\n            // Channel ID format: youtube.com/channel/UC...\n            else if (pathname.includes('/channel/')) {\n                const idMatch = pathname.match(/\\/channel\\/(UC[a-zA-Z0-9_-]+)/);\n                if (idMatch) channelId = idMatch[1];\n            }\n            // Custom URL format: youtube.com/c/ChannelName\n            else if (pathname.includes('/c/')) {\n                const customMatch = pathname.match(/\\/c\\/([^/]+)/);\n                if (customMatch) handle = '@' + customMatch[1];\n            }\n            // User format: youtube.com/user/Username\n            else if (pathname.includes('/user/')) {\n                const userMatch = pathname.match(/\\/user\\/([^/]+)/);\n                if (userMatch) handle = '@' + userMatch[1];\n            }\n        } catch {\n            // Not a valid URL, try direct parsing\n        }\n\n        // If URL parsing didn't yield results, try direct input\n        if (!channelId && !handle) {\n            if (input.startsWith('@')) {\n                handle = input;\n            } else if (input.startsWith('UC') && input.length >= 20) {\n                channelId = input;\n            } else {\n                // Assume it's a handle without @\n                handle = '@' + input;\n            }\n        }\n\n        // 2. Fetch Metadata from YouTube\n        const params = new URLSearchParams({\n            part: 'snippet,contentDetails,statistics',\n            key: apiKey,\n        });\n\n        if (channelId) {\n            params.append('id', channelId);\n        } else {\n            params.append('forHandle', handle);\n        }\n\n        const res = await fetch(`https://www.googleapis.com/youtube/v3/channels?${params.toString()}`);\n        const data = await res.json();\n\n        if (!data.items || data.items.length === 0) {\n            throw new Error('Channel not found');\n        }\n\n        const item = data.items[0];\n        const newChannel: TrendChannel = {\n            id: item.id,\n            title: item.snippet.title,\n            handle: item.snippet.customUrl,\n            avatarUrl: item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default?.url,\n            uploadsPlaylistId: item.contentDetails.relatedPlaylists.uploads,\n            isVisible: true,\n            subscriberCount: parseInt(item.statistics.subscriberCount),\n            lastUpdated: 0, // Never updated\n        };\n\n        // 3. Save to Firestore\n        await setDoc(doc(db, `users/${userId}/channels/${userChannelId}/trendChannels`, newChannel.id), newChannel);\n\n        // 4. Initial Sync of Videos\n        let initialSyncStats = { totalQuotaUsed: 0, totalNewVideos: 0, quotaBreakdown: { list: 0, details: 0 } };\n        try {\n            initialSyncStats = await TrendService.syncChannelVideos(userId, userChannelId, newChannel, apiKey);\n        } catch (error) {\n            console.error('Initial video sync failed:', error);\n            // We still return the channel even if sync fails, it will just be empty initially\n        }\n\n        return {\n            channel: newChannel,\n            quotaCost: 1 + initialSyncStats.totalQuotaUsed,\n            totalNewVideos: initialSyncStats.totalNewVideos,\n            quotaBreakdown: {\n                search: 1,\n                ...initialSyncStats.quotaBreakdown\n            }\n        }; // 1 (channel search) + sync cost\n    },\n\n    removeTrendChannel: async (userId: string, userChannelId: string, channelId: string) => {\n        await deleteDoc(doc(db, `users/${userId}/channels/${userChannelId}/trendChannels`, channelId));\n        // Cleanup IndexedDB videos for this channel\n        const idb = await getDB();\n        const tx = idb.transaction('videos', 'readwrite');\n        const index = tx.store.index('by-channel');\n        let cursor = await index.openCursor(IDBKeyRange.only(channelId));\n        while (cursor) {\n            await cursor.delete();\n            cursor = await cursor.continue();\n        }\n        await tx.done;\n    },\n\n    toggleVisibility: async (userId: string, userChannelId: string, channelId: string, isVisible: boolean) => {\n        await updateDoc(doc(db, `users/${userId}/channels/${userChannelId}/trendChannels`, channelId), { isVisible });\n    },\n\n    updateChannel: async (userId: string, userChannelId: string, channelId: string, updates: Partial<TrendChannel>) => {\n        await updateDoc(doc(db, `users/${userId}/channels/${userChannelId}/trendChannels`, channelId), updates);\n    },\n\n    // --- Video Fetching & Caching (IndexedDB) ---\n\n    syncChannelVideos: async (userId: string, userChannelId: string, channel: TrendChannel, apiKey: string, forceFullSync: boolean = false, refreshAvatar: boolean = false): Promise<{ totalNewVideos: number; totalQuotaUsed: number; quotaBreakdown: { list: number; details: number }; newAvatarUrl?: string }> => {\n        console.log(`[TrendService] Starting sync for channel: ${channel.title} (Full Sync: ${forceFullSync}, Refresh Avatar: ${refreshAvatar})`);\n\n        let nextPageToken: string | undefined = undefined;\n        let totalProcessedVideos = 0;\n        let totalQuotaUsed = 0;\n        const quotaBreakdown = { list: 0, details: 0 };\n\n        const idb = await getDB();\n\n        // Recursively fetch all pages from playlistItems\n        do {\n            const params = new URLSearchParams({\n                part: 'snippet,contentDetails',\n                playlistId: channel.uploadsPlaylistId,\n                maxResults: '50',\n                key: apiKey,\n            });\n\n            if (nextPageToken) {\n                params.append('pageToken', nextPageToken);\n            }\n\n            const res = await fetch(`https://www.googleapis.com/youtube/v3/playlistItems?${params.toString()}`);\n            const data = await res.json();\n            totalQuotaUsed += 1; // playlistItems cost\n            quotaBreakdown.list += 1;\n\n            if (!data.items || data.items.length === 0) {\n                break;\n            }\n\n            // Determine which videos to fetch details for\n            const videosToFetch: string[] = [];\n\n            for (const item of data.items) {\n                const videoId = item.contentDetails.videoId;\n\n                if (forceFullSync) {\n                    // In full sync, we update everything encountered\n                    videosToFetch.push(videoId);\n                } else {\n                    // In incremental sync, check against DB\n                    const existing = await idb.get('videos', videoId);\n                    if (!existing) {\n                        videosToFetch.push(videoId);\n                    }\n                }\n            }\n\n            if (videosToFetch.length > 0) {\n                // Fetch details for the chunk\n                const videoIdsChunk = videosToFetch.join(',');\n                const statsParams = new URLSearchParams({\n                    part: 'statistics,contentDetails,snippet',\n                    id: videoIdsChunk,\n                    key: apiKey,\n                });\n\n                const statsRes = await fetch(`https://www.googleapis.com/youtube/v3/videos?${statsParams.toString()}`);\n                const statsData = await statsRes.json();\n                totalQuotaUsed += 1; // videos list cost\n                quotaBreakdown.details += 1;\n\n                if (statsData.items) {\n                    const videos: TrendVideo[] = statsData.items.map((item: any) => ({\n                        id: item.id,\n                        channelId: channel.id,\n                        publishedAt: item.snippet.publishedAt,\n                        publishedAtTimestamp: new Date(item.snippet.publishedAt).getTime(),\n                        title: item.snippet.title,\n                        thumbnail: item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default?.url || '',\n                        viewCount: parseInt(item.statistics.viewCount || '0'),\n                        duration: item.contentDetails.duration || '',\n                        tags: item.snippet.tags || [],\n                        description: item.snippet.description || '',\n                    }));\n\n                    // 1. Save to IndexedDB (speed layer)\n                    const tx = idb.transaction('videos', 'readwrite');\n                    await Promise.all(videos.map(v => tx.store.put(v)));\n                    await tx.done;\n\n                    // 2. Save to Firestore (sync layer)\n                    const videoBatch = writeBatch(db);\n                    videos.forEach(v => {\n                        const vRef = doc(db, `users/${userId}/channels/${userChannelId}/trendChannels/${channel.id}/videos`, v.id);\n                        videoBatch.set(vRef, v);\n                    });\n                    await videoBatch.commit();\n\n                    totalProcessedVideos += videos.length;\n                }\n            } else {\n                console.log('[TrendService] All videos in this page already exist. Skipping details fetch.');\n            }\n\n            nextPageToken = data.nextPageToken;\n\n        } while (nextPageToken);\n\n        console.log(`[TrendService] Sync complete. Processed ${totalProcessedVideos} videos. Quota used: ${totalQuotaUsed}`);\n\n        // Update stats\n        const allVideos = await idb.getAllFromIndex('videos', 'by-channel', channel.id);\n        const totalViews = allVideos.reduce((sum, v) => sum + v.viewCount, 0);\n        const averageViews = allVideos.length > 0 ? totalViews / allVideos.length : 0;\n\n        // Refresh avatar if requested (when current avatar is broken)\n        let newAvatarUrl: string | undefined;\n        if (refreshAvatar) {\n            try {\n                const avatarParams = new URLSearchParams({\n                    part: 'snippet',\n                    id: channel.id,\n                    key: apiKey,\n                });\n                const avatarRes = await fetch(`https://www.googleapis.com/youtube/v3/channels?${avatarParams.toString()}`);\n                const avatarData = await avatarRes.json();\n                totalQuotaUsed += 1;\n\n                if (avatarData.items?.[0]?.snippet?.thumbnails) {\n                    const thumbnails = avatarData.items[0].snippet.thumbnails;\n                    newAvatarUrl = thumbnails.medium?.url || thumbnails.default?.url;\n                    console.log(`[TrendService] Refreshed avatar for ${channel.title}: ${newAvatarUrl}`);\n                }\n            } catch (err) {\n                console.error('[TrendService] Failed to refresh avatar:', err);\n            }\n        }\n\n        await updateDoc(doc(db, `users/${userId}/channels/${userChannelId}/trendChannels`, channel.id), {\n            lastUpdated: Date.now(),\n            averageViews,\n            totalViewCount: totalViews,\n            ...(newAvatarUrl ? { avatarUrl: newAvatarUrl } : {})\n        });\n\n        return { totalNewVideos: totalProcessedVideos, totalQuotaUsed, quotaBreakdown, newAvatarUrl };\n    },\n\n    getChannelVideosFromCache: async (channelId: string) => {\n        const idb = await getDB();\n        return idb.getAllFromIndex('videos', 'by-channel', channelId);\n    },\n\n    getChannelVideosFromFirestore: async (userId: string, userChannelId: string, channelId: string) => {\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/trendChannels/${channelId}/videos`);\n        const snapshot = await getDocs(ref);\n        return snapshot.docs.map(d => d.data() as TrendVideo);\n    },\n\n    // Migration helper: Recalculate stats from Firestore to ensure consistency across devices\n    recalcChannelStats: async (userId: string, userChannelId: string, channelId: string) => {\n        const allVideos = await TrendService.getChannelVideosFromFirestore(userId, userChannelId, channelId);\n\n        const totalViews = allVideos.reduce((sum, v) => sum + v.viewCount, 0);\n        const averageViews = allVideos.length > 0 ? totalViews / allVideos.length : 0;\n\n        await updateDoc(doc(db, `users/${userId}/channels/${userChannelId}/trendChannels`, channelId), {\n            totalViewCount: totalViews,\n            averageViews,\n            lastUpdated: Date.now() // Also mark as updated to prevent immediate sync if they were just migrated\n        });\n\n        return totalViews;\n    },\n\n    // --- Copy Channel to Another User Channel ---\n\n    /**\n     * Check if a TrendChannel exists in a target User Channel.\n     */\n    channelExistsInUserChannel: async (\n        userId: string,\n        targetUserChannelId: string,\n        trendChannelId: string\n    ): Promise<boolean> => {\n        const ref = doc(db, `users/${userId}/channels/${targetUserChannelId}/trendChannels`, trendChannelId);\n        const snapshot = await getDoc(ref);\n        return snapshot.exists();\n    },\n\n    /**\n     * Get all niches for a specific User Channel.\n     */\n    getNichesForUserChannel: async (\n        userId: string,\n        userChannelId: string\n    ): Promise<TrendNiche[]> => {\n        const ref = collection(db, `users/${userId}/channels/${userChannelId}/trendNiches`);\n        const snapshot = await getDocs(ref);\n        return snapshot.docs.map(d => d.data() as TrendNiche);\n    },\n\n    /**\n     * Copy a TrendChannel (with niches, video assignments, hidden videos) to another User Channel.\n     * \n     * @param merge - If true, the channel already exists in target and we merge niche data.\n     *                If false, create fresh copy.\n     */\n    copyTrendChannel: async (\n        userId: string,\n        sourceUserChannelId: string,\n        targetUserChannelId: string,\n        trendChannelId: string,\n        merge: boolean\n    ): Promise<void> => {\n        // 1. Get source channel data\n        const channelRef = doc(db, `users/${userId}/channels/${sourceUserChannelId}/trendChannels`, trendChannelId);\n        const channelSnap = await getDoc(channelRef);\n        if (!channelSnap.exists()) {\n            throw new Error('Source channel not found');\n        }\n        const channelData = channelSnap.data() as TrendChannel;\n\n        // 2. Get source niches related to this channel\n        const sourceNiches = await TrendService.getNichesForUserChannel(userId, sourceUserChannelId);\n        const sourceAssignmentsRef = collection(db, `users/${userId}/channels/${sourceUserChannelId}/videoNicheAssignments`);\n        const sourceAssignmentsSnap = await getDocs(sourceAssignmentsRef);\n\n        // Get videos to identify which niches are relevant\n        const videosRef = collection(db, `users/${userId}/channels/${sourceUserChannelId}/trendChannels/${trendChannelId}/videos`);\n        const videosSnap = await getDocs(videosRef);\n        const videoIds = new Set(videosSnap.docs.map(d => d.id));\n\n        // Collect relevant niche IDs (used by this channel's videos)\n        const relevantNicheIds = new Set<string>();\n        sourceAssignmentsSnap.docs.forEach(doc => {\n            if (videoIds.has(doc.id)) {\n                const assignments = doc.data().assignments || [];\n                assignments.forEach((a: { nicheId: string }) => relevantNicheIds.add(a.nicheId));\n            }\n        });\n\n        // Also include local niches for this channel\n        sourceNiches.forEach(n => {\n            if (n.type === 'local' && n.channelId === trendChannelId) {\n                relevantNicheIds.add(n.id);\n            }\n        });\n\n        const nichesToCopy = sourceNiches.filter(n => relevantNicheIds.has(n.id));\n\n        // 3. Get hidden videos for this channel\n        const hiddenRef = collection(db, `users/${userId}/channels/${sourceUserChannelId}/hiddenVideos`);\n        const hiddenSnap = await getDocs(hiddenRef);\n        const hiddenToCopy = hiddenSnap.docs\n            .map(d => d.data() as HiddenVideo)\n            .filter(hv => hv.channelId === trendChannelId);\n\n        // 4. Get target niches for merge mapping\n        let targetNiches: TrendNiche[] = [];\n        if (merge) {\n            targetNiches = await TrendService.getNichesForUserChannel(userId, targetUserChannelId);\n        }\n\n        // Build niche ID mapping: source niche ID -> target niche ID\n        const nicheIdMap = new Map<string, string>();\n\n        const batch = writeBatch(db);\n\n        // 5. Copy/create niches\n        for (const niche of nichesToCopy) {\n            if (merge) {\n                // Check if same-name niche exists in target\n                const existingNiche = targetNiches.find(n => n.name === niche.name);\n                if (existingNiche) {\n                    // Map to existing niche\n                    nicheIdMap.set(niche.id, existingNiche.id);\n                } else {\n                    // Create new niche in target\n                    const newNicheId = crypto.randomUUID();\n                    nicheIdMap.set(niche.id, newNicheId);\n                    const newNiche: TrendNiche = {\n                        ...niche,\n                        id: newNicheId,\n                        viewCount: 0, // Will be recalculated\n                        createdAt: Date.now()\n                    };\n                    const nicheRef = doc(db, `users/${userId}/channels/${targetUserChannelId}/trendNiches`, newNicheId);\n                    batch.set(nicheRef, newNiche);\n                }\n            } else {\n                // Fresh copy: create new niche with new ID\n                const newNicheId = crypto.randomUUID();\n                nicheIdMap.set(niche.id, newNicheId);\n                const newNiche: TrendNiche = {\n                    ...niche,\n                    id: newNicheId,\n                    viewCount: 0,\n                    createdAt: Date.now()\n                };\n                const nicheRef = doc(db, `users/${userId}/channels/${targetUserChannelId}/trendNiches`, newNicheId);\n                batch.set(nicheRef, newNiche);\n            }\n        }\n\n        // 6. Copy channel (if not merge)\n        if (!merge) {\n            const targetChannelRef = doc(db, `users/${userId}/channels/${targetUserChannelId}/trendChannels`, trendChannelId);\n            batch.set(targetChannelRef, channelData);\n        }\n\n        // 7. Copy videos\n        for (const videoDoc of videosSnap.docs) {\n            const videoData = videoDoc.data();\n            const targetVideoRef = doc(db, `users/${userId}/channels/${targetUserChannelId}/trendChannels/${trendChannelId}/videos`, videoDoc.id);\n            batch.set(targetVideoRef, videoData);\n        }\n\n        // 8. Copy video-niche assignments with mapped IDs\n        for (const assignDoc of sourceAssignmentsSnap.docs) {\n            if (!videoIds.has(assignDoc.id)) continue;\n\n            const sourceAssignments: { nicheId: string; addedAt: number }[] = assignDoc.data().assignments || [];\n            const mappedAssignments = sourceAssignments\n                .filter(a => nicheIdMap.has(a.nicheId))\n                .map(a => ({\n                    nicheId: nicheIdMap.get(a.nicheId)!,\n                    addedAt: Date.now()\n                }));\n\n            if (mappedAssignments.length > 0) {\n                const targetAssignRef = doc(db, `users/${userId}/channels/${targetUserChannelId}/videoNicheAssignments`, assignDoc.id);\n\n                if (merge) {\n                    // Get existing assignments and merge\n                    const existingSnap = await getDoc(targetAssignRef);\n                    const existing: { nicheId: string; addedAt: number }[] = existingSnap.exists()\n                        ? (existingSnap.data().assignments || [])\n                        : [];\n\n                    // Merge: add new assignments that don't already exist\n                    const existingNicheIds = new Set(existing.map(a => a.nicheId));\n                    const merged = [\n                        ...existing,\n                        ...mappedAssignments.filter(a => !existingNicheIds.has(a.nicheId))\n                    ];\n                    batch.set(targetAssignRef, { assignments: merged });\n                } else {\n                    batch.set(targetAssignRef, { assignments: mappedAssignments });\n                }\n            }\n        }\n\n        // 9. Copy hidden videos\n        for (const hv of hiddenToCopy) {\n            const targetHiddenRef = doc(db, `users/${userId}/channels/${targetUserChannelId}/hiddenVideos`, hv.id);\n            batch.set(targetHiddenRef, hv);\n        }\n\n        // 10. Commit all changes\n        await batch.commit();\n\n        // 11. Recalculate niche view counts in target\n        // This is done asynchronously to avoid blocking\n        const targetNicheIdsToUpdate = new Set(nicheIdMap.values());\n        for (const nicheId of targetNicheIdsToUpdate) {\n            // Get all videos assigned to this niche in target\n            const targetAssignRef = collection(db, `users/${userId}/channels/${targetUserChannelId}/videoNicheAssignments`);\n            const allAssigns = await getDocs(targetAssignRef);\n\n            let totalViews = 0;\n            for (const doc of allAssigns.docs) {\n                const assignments = doc.data().assignments || [];\n                if (assignments.some((a: { nicheId: string }) => a.nicheId === nicheId)) {\n                    // Get video view count\n                    // Try to find in the copied videos first\n                    const videoData = videosSnap.docs.find(v => v.id === doc.id)?.data();\n                    if (videoData) {\n                        totalViews += videoData.viewCount || 0;\n                    }\n                }\n            }\n\n            // Update niche view count\n            const nicheRef = doc(db, `users/${userId}/channels/${targetUserChannelId}/trendNiches`, nicheId);\n            await updateDoc(nicheRef, { viewCount: increment(totalViews) });\n        }\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/videoService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2335,2338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2335,2338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2399,2402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2399,2402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2539,2542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2539,2542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2569,2572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2569,2572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { VideoService } from './videoService';\nimport * as firestoreActions from 'firebase/firestore';\nimport * as storageActions from './storageService';\n\n// 1.  Firestore  Storage\nvi.mock('firebase/firestore', async () => {\n    const actual = await vi.importActual('firebase/firestore');\n    return {\n        ...actual,\n        getDocs: vi.fn(),\n        deleteDoc: vi.fn(),\n        writeBatch: vi.fn(() => ({\n            set: vi.fn(),\n            commit: vi.fn()\n        })),\n        doc: vi.fn(),\n        db: {}\n    };\n});\n\nvi.mock('./firestore', () => ({\n    getCollectionRef: vi.fn(),\n    getDocument: vi.fn(),\n    deleteDocument: vi.fn()\n}));\n\nvi.mock('./storageService', () => ({\n    deleteImageFromStorage: vi.fn(),\n    deleteCsvSnapshot: vi.fn()\n}));\n\n//  SettingsService,       videoOrder\nvi.mock('./settingsService', () => ({\n    SettingsService: {\n        fetchVideoOrder: vi.fn().mockResolvedValue([]),\n        updateVideoOrder: vi.fn()\n    }\n}));\n\ndescribe('VideoService.deleteVideo (Full Cleanup)', () => {\n    const userId = 'user-1';\n    const channelId = 'channel-1';\n    const videoId = 'video-123';\n\n    beforeEach(() => {\n        vi.clearAllMocks();\n    });\n\n    it('   : ,   Storage  ', async () => {\n        //       \n        const mockVideo = {\n            id: videoId,\n            customImage: `https://firebasestorage.googleapis.com/.../${videoId}/main.jpg`,\n            coverHistory: [\n                { url: `https://firebasestorage.googleapis.com/.../${videoId}/old.jpg` }\n            ],\n            packagingHistory: [\n                { configurationSnapshot: { coverImage: `https://firebasestorage.googleapis.com/.../${videoId}/v1.jpg` } }\n            ]\n        };\n\n        //    \n        const mockTrafficMainDoc = {\n            id: 'main',\n            data: () => ({\n                snapshots: [\n                    { storagePath: `traffic/${videoId}/snap1.csv` }\n                ]\n            })\n        };\n\n        //   \n        const { getCollectionRef, getDocument, deleteDocument } = await import('./firestore');\n        (getDocument as any).mockResolvedValue(mockVideo);\n        (getCollectionRef as any).mockImplementation((path: string) => ({ path }));\n\n        const { getDocs } = await import('firebase/firestore');\n        (getDocs as any).mockImplementation((ref: any) => {\n            //    (   )\n            if (ref && ref.path && ref.path.includes('traffic')) {\n                return Promise.resolve({\n                    empty: false,\n                    docs: [mockTrafficMainDoc]\n                });\n            }\n            //   \n            return Promise.resolve({ empty: true, docs: [] });\n        });\n\n        //  \n        await VideoService.deleteVideo(userId, channelId, videoId);\n\n        // ---  ---\n\n        // 1.     Storage (main + history + packaging)\n        //   3  (main.jpg, old.jpg, v1.jpg)\n        expect(storageActions.deleteImageFromStorage).toHaveBeenCalledTimes(3);\n        expect(storageActions.deleteImageFromStorage).toHaveBeenCalledWith(mockVideo.customImage);\n\n        // 2.   CSV    Storage\n        expect(storageActions.deleteCsvSnapshot).toHaveBeenCalledWith(`traffic/${videoId}/snap1.csv`);\n\n        // 3.      Firestore\n        expect(firestoreActions.deleteDoc).toHaveBeenCalled();\n\n        // 4.     \n        expect(deleteDocument).toHaveBeenCalledWith(expect.stringContaining('videos'), videoId);\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/services/videoService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":180,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":180,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":215,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8471,8474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8471,8474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8875,8878],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8875,8878],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":221,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8931,8934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8931,8934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":295,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11610,11613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11610,11613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n    getCollectionRef,\n    setDocument,\n    deleteDocument,\n    subscribeToCollection,\n    fetchCollection,\n    getDocument,\n    updateDocument\n} from './firestore';\nimport type { DocumentData } from 'firebase/firestore';\nimport type { VideoDetails, HistoryItem, CoverVersion } from '../utils/youtubeApi';\nimport { orderBy, getDocs, deleteDoc, writeBatch, doc } from 'firebase/firestore';\nimport { db } from '../../config/firebase';\nimport { deleteImageFromStorage } from './storageService';\n\nexport const getVideosPath = (userId: string, channelId: string) =>\n    `users/${userId}/channels/${channelId}/videos`;\n\nexport const getSuggestedVideosPath = (userId: string, channelId: string) =>\n    `users/${userId}/channels/${channelId}/cached_suggested_traffic_videos`;\n\nexport const VideoService = {\n    fetchVideos: async (userId: string, channelId: string) => {\n        return fetchCollection<VideoDetails>(getVideosPath(userId, channelId));\n    },\n\n    fetchSuggestedVideos: async (userId: string, channelId: string) => {\n        return fetchCollection<VideoDetails>(getSuggestedVideosPath(userId, channelId));\n    },\n\n    getVideoDocRef(userId: string, channelId: string, videoId: string) {\n        return doc(db, getVideosPath(userId, channelId), videoId);\n    },\n\n    getVideo: async (userId: string, channelId: string, videoId: string) => {\n        const path = `${getVideosPath(userId, channelId)}/${videoId}`;\n        return getDocument<VideoDetails>(path);\n    },\n\n    subscribeToVideos: (\n        userId: string,\n        channelId: string,\n        callback: (videos: VideoDetails[]) => void\n    ) => {\n        return subscribeToCollection<VideoDetails>(\n            getVideosPath(userId, channelId),\n            callback\n        );\n    },\n\n    addVideo: async (\n        userId: string,\n        channelId: string,\n        video: VideoDetails\n    ) => {\n        const videoWithTimestamp = { ...video };\n\n        // Auto-set addedToHomeAt if not provided and video is not playlist-only.\n        // If it is playlist-only, we do NOT want this field (it stays undefined/missing).\n        // Firestore setDoc throws on 'undefined', so we must ensure it's not present in the object.\n        if (video.addedToHomeAt) {\n            videoWithTimestamp.addedToHomeAt = video.addedToHomeAt;\n        } else if (!video.isPlaylistOnly) {\n            videoWithTimestamp.addedToHomeAt = Date.now();\n        } else {\n            // Explicitly delete if it exists as undefined to be safe\n            delete videoWithTimestamp.addedToHomeAt;\n        }\n\n        await setDocument(\n            getVideosPath(userId, channelId),\n            video.id,\n            videoWithTimestamp\n        );\n    },\n\n\n    batchUpdateVideos: async (\n        userId: string,\n        channelId: string,\n        updates: { videoId: string; data: Partial<VideoDetails> }[]\n    ) => {\n        const batch = writeBatch(db);\n        updates.forEach(({ videoId, data }) => {\n            const docRef = doc(db, getVideosPath(userId, channelId), videoId);\n            batch.set(docRef, data, { merge: true });\n        });\n        await batch.commit();\n    },\n\n    batchUpdateSuggestedVideos: async (\n        userId: string,\n        channelId: string,\n        updates: { videoId: string; data: Partial<VideoDetails> }[]\n    ) => {\n        const batch = writeBatch(db);\n        updates.forEach(({ videoId, data }) => {\n            const docRef = doc(db, getSuggestedVideosPath(userId, channelId), videoId);\n            batch.set(docRef, data, { merge: true });\n        });\n        await batch.commit();\n    },\n\n    updateVideo: async (\n        userId: string,\n        channelId: string,\n        videoId: string,\n        updates: Partial<VideoDetails>\n    ) => {\n        // Use updateDoc to properly replace fields (including arrays) instead of merge\n        await updateDocument(\n            getVideosPath(userId, channelId),\n            videoId,\n            updates as DocumentData\n        );\n    },\n\n    /**\n     * BUSINESS LOGIC: Safe Update with Optimistic Locking\n     * \n     * Uses packagingRevision to prevent concurrent edit conflicts.\n     */\n    updateVideoSafe: async (\n        userId: string,\n        channelId: string,\n        videoId: string,\n        updates: Partial<VideoDetails>,\n        expectedRevision?: number\n    ) => {\n        const { runSafeUpdate } = await import('./firestore');\n        return runSafeUpdate<VideoDetails>(\n            getVideosPath(userId, channelId),\n            videoId,\n            'packagingRevision',\n            expectedRevision,\n            () => {\n                // Determine if we need to auto-apply revision based on which fields are changing\n                // For now, any explicit call to updateVideoSafe assumes a revision increment is desired.\n                return updates;\n            }\n        );\n    },\n\n    deleteVideo: async (\n        userId: string,\n        channelId: string,\n        videoId: string\n    ) => {\n        // 1. Fetch video details to get image URLs\n        const videoPath = `${getVideosPath(userId, channelId)}/${videoId}`;\n        const video = await getDocument<VideoDetails>(videoPath);\n\n        if (video) {\n            const imagesToDelete = new Set<string>();\n\n            // Helper to add URL if it's a storage URL\n            const addUrl = (url?: string | null) => {\n                if (url && url.includes('firebasestorage.googleapis.com')) {\n                    // CRITICAL: Only delete if the URL path contains this specific video's ID\n                    // The path structure is users/{userId}/channels/{channelId}/videos/{videoId}/...\n                    // Or for legacy: covers/{userId}/...\n                    // If we are deleting a video, we should only delete files in its specific folder if following new structure.\n                    // For legacy structure, we might still have issues, but let's at least protect against cross-video deletion if we can identify the path.\n                    // Decoded URL contains the path.\n                    try {\n                        const decodedUrl = decodeURIComponent(url);\n                        // Check if the path contains the video ID\n                        if (decodedUrl.includes(videoId)) {\n                            imagesToDelete.add(url);\n                        } else if (decodedUrl.includes(`covers/${userId}`)) {\n                            // Legacy path: tricky. If it's a clone, this might be shared.\n                            // If it's a clone, `clonedFromId` will be set.\n                            // However, we don't know if other videos use it. \n                            // SAFEST BET: Don't delete legacy files automatically if we are unsure.\n                            // Or maybe just don't delete legacy files at all to be safe?\n                            // User complaint was about missing covers after delete.\n                            // Let's being conservative: ONLY delete if it explicitly matches the new structure with videoId.\n                            // imagesToDelete.add(url); // SKIP LEGACY DELETE TO BE SAFE\n                        }\n                    } catch (e) {\n                        // ignore\n                    }\n                }\n            };\n\n            // Collect URLs\n            addUrl(video.customImage);\n\n            // History\n            video.coverHistory?.forEach(h => addUrl(h.url));\n\n            // Packaging History\n            video.packagingHistory?.forEach(v => {\n                if (v.configurationSnapshot) {\n                    addUrl(v.configurationSnapshot.coverImage);\n                    v.configurationSnapshot.abTestVariants?.forEach(variant => addUrl(variant));\n                }\n            });\n\n            // A/B Test Variants (if stored at top level)\n            video.abTestVariants?.forEach(variant => addUrl(variant));\n\n            // Delete all images\n            await Promise.all(Array.from(imagesToDelete).map(url => deleteImageFromStorage(url)));\n        }\n\n        // 2. Traffic Data Cleanup (Snapshots & CSVs)\n        const trafficPath = `${getVideosPath(userId, channelId)}/${videoId}/traffic`;\n        const trafficSnapshot = await getDocs(getCollectionRef(trafficPath));\n\n        if (!trafficSnapshot.empty) {\n            // Fetch the main traffic document to get snapshots\n            const mainDoc = trafficSnapshot.docs.find(d => d.id === 'main');\n            if (mainDoc) {\n                const trafficData = mainDoc.data() as any; // Cast to avoid type issues if types are not perfectly aligned\n                if (trafficData.snapshots && Array.isArray(trafficData.snapshots)) {\n                    const { deleteCsvSnapshot } = await import('./storageService');\n                    // Delete all CSV snapshots from Cloud Storage\n                    const csvDeletions = trafficData.snapshots\n                        .filter((s: any) => s.storagePath)\n                        .map((s: any) => deleteCsvSnapshot(s.storagePath));\n\n                    await Promise.all(csvDeletions);\n                }\n            }\n\n            // Delete traffic subcollection documents\n            const deleteTrafficPromises = trafficSnapshot.docs.map(doc => deleteDoc(doc.ref));\n            await Promise.all(deleteTrafficPromises);\n        }\n\n        // 3. Delete History Subcollection\n        const historyPath = `${getVideosPath(userId, channelId)}/${videoId}/history`;\n        const historyRef = getCollectionRef(historyPath);\n        const historySnapshot = await getDocs(historyRef);\n        const deleteHistoryPromises = historySnapshot.docs.map(doc => deleteDoc(doc.ref));\n        await Promise.all(deleteHistoryPromises);\n\n        // 4. Delete Video Document\n        await deleteDocument(\n            getVideosPath(userId, channelId),\n            videoId\n        );\n\n        // 5. CLEANUP: Remove from videoOrder\n        try {\n            const { SettingsService } = await import('./settingsService');\n            const currentOrder = await SettingsService.fetchVideoOrder(userId, channelId);\n            if (currentOrder && currentOrder.includes(videoId)) {\n                const newOrder = currentOrder.filter(id => id !== videoId);\n                await SettingsService.updateVideoOrder(userId, channelId, newOrder);\n            }\n        } catch (error) {\n            console.error('Failed to cleanup videoOrder:', error);\n            // Don't throw - video is already deleted, this is just cleanup\n        }\n    },\n\n    // History Subcollection\n    fetchVideoHistory: async (\n        userId: string,\n        channelId: string,\n        videoId: string\n    ) => {\n        const historyPath = `${getVideosPath(userId, channelId)}/${videoId}/history`;\n        return fetchCollection<CoverVersion>(historyPath, [orderBy('timestamp', 'desc')]);\n    },\n\n    saveVideoHistory: async (\n        userId: string,\n        channelId: string,\n        videoId: string,\n        historyItem: HistoryItem\n    ) => {\n        const historyPath = `${getVideosPath(userId, channelId)}/${videoId}/history`;\n        const historyId = historyItem.timestamp.toString();\n        await setDocument(historyPath, historyId, historyItem);\n    },\n\n    deleteVideoHistoryItem: async (\n        userId: string,\n        channelId: string,\n        videoId: string,\n        historyId: string\n    ) => {\n        const historyPath = `${getVideosPath(userId, channelId)}/${videoId}/history`;\n        await deleteDocument(historyPath, historyId);\n    },\n\n    // Traffic Data Subcollection\n    saveTrafficData: async (\n        userId: string,\n        channelId: string,\n        videoId: string,\n        data: any // Using any to avoid circular dependency with types/traffic.ts if not imported yet, but better to import\n    ) => {\n        const trafficPath = `${getVideosPath(userId, channelId)}/${videoId}/traffic`;\n        await setDocument(trafficPath, 'main', data);\n    },\n\n    fetchTrafficData: async (\n        userId: string,\n        channelId: string,\n        videoId: string\n    ) => {\n        const trafficPath = `${getVideosPath(userId, channelId)}/${videoId}/traffic`;\n        const snapshot = await getDocs(getCollectionRef(trafficPath));\n        if (snapshot.empty) return null;\n        // Assuming only one document 'main' exists\n        const doc = snapshot.docs.find(d => d.id === 'main');\n        return doc ? doc.data() : null;\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/channelStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/filterStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[344,347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[344,347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\n\nexport type FilterOperator = 'contains' | 'equals' | 'gt' | 'lt' | 'gte' | 'lte' | 'between';\nexport type FilterType = 'channel' | 'playlist' | 'title' | 'duration' | 'date' | 'views' | 'videoType';\n\nexport interface FilterItem {\n    id: string;\n    type: FilterType;\n    operator: FilterOperator;\n    value: any; // string, number, [start, end], etc.\n    label?: string; // e.g. \"Views > 1000\" for display chip\n}\n\ninterface FilterState {\n    searchQuery: string;\n    selectedChannel: string | null; // Legacy simple filter (can be kept for backward compat or migrated)\n    homeSortBy: 'default' | 'views' | 'date' | 'recently_added';\n\n    activeFilters: FilterItem[];\n    channelFilters: Record<string, FilterItem[]>;\n    currentChannelId: string | null;\n\n    // Actions\n    setSearchQuery: (query: string) => void;\n    setSelectedChannel: (channel: string | null) => void;\n    setHomeSortBy: (sort: 'default' | 'views' | 'date' | 'recently_added') => void;\n\n    addFilter: (filter: Omit<FilterItem, 'id'>) => void;\n    removeFilter: (id: string) => void;\n    updateFilter: (id: string, updates: Partial<FilterItem>) => void;\n    clearFilters: () => void;\n\n    // New action to handle channel switching\n    // New action to handle channel switching\n    switchChannel: (channelId: string | null) => void;\n\n    // Auth State\n    userId: string | null;\n    setUserId: (id: string | null) => void;\n}\n\nimport { persist } from 'zustand/middleware';\n\nexport const useFilterStore = create<FilterState>()(\n    persist(\n        (set) => ({\n            searchQuery: '',\n            selectedChannel: null,\n            homeSortBy: 'default',\n            activeFilters: [],\n            channelFilters: {},\n            currentChannelId: null,\n            userId: null,\n\n            setUserId: (id) => set((state) => {\n                if (state.userId === id) return {};\n\n                // User changed! Reset ALL filters\n                return {\n                    userId: id,\n                    activeFilters: [],\n                    channelFilters: {}, // Clear all channel presets\n                    currentChannelId: null,\n                    selectedChannel: null,\n                    searchQuery: ''\n                };\n            }),\n\n            setSearchQuery: (query) => set({ searchQuery: query }),\n            setSelectedChannel: (channel) => set({ selectedChannel: channel }),\n            setHomeSortBy: (sort) => set({ homeSortBy: sort }),\n\n            addFilter: (filter) => {\n                const newFilter = { ...filter, id: crypto.randomUUID() };\n                set((state) => {\n                    const newFilters = [...state.activeFilters, newFilter];\n                    // Also update the stored filters for current channel immediately\n                    const newChannelFilters = state.currentChannelId\n                        ? { ...state.channelFilters, [state.currentChannelId]: newFilters }\n                        : state.channelFilters;\n\n                    return {\n                        activeFilters: newFilters,\n                        channelFilters: newChannelFilters\n                    };\n                });\n            },\n            removeFilter: (id) => set((state) => {\n                const newFilters = state.activeFilters.filter((f) => f.id !== id);\n                const newChannelFilters = state.currentChannelId\n                    ? { ...state.channelFilters, [state.currentChannelId]: newFilters }\n                    : state.channelFilters;\n                return {\n                    activeFilters: newFilters,\n                    channelFilters: newChannelFilters\n                };\n            }),\n            updateFilter: (id, updates) => set((state) => {\n                const newFilters = state.activeFilters.map((f) => f.id === id ? { ...f, ...updates } : f);\n                const newChannelFilters = state.currentChannelId\n                    ? { ...state.channelFilters, [state.currentChannelId]: newFilters }\n                    : state.channelFilters;\n                return {\n                    activeFilters: newFilters,\n                    channelFilters: newChannelFilters\n                };\n            }),\n            clearFilters: () => set((state) => {\n                const newChannelFilters = state.currentChannelId\n                    ? { ...state.channelFilters, [state.currentChannelId]: [] }\n                    : state.channelFilters;\n                return {\n                    activeFilters: [],\n                    channelFilters: newChannelFilters\n                };\n            }),\n\n            switchChannel: (channelId) => set((state) => {\n                // If we are already on this channel, do nothing\n                if (state.currentChannelId === channelId) {\n                    return {};\n                }\n\n                // Save current filters to the old channel ID if it exists AND we have filters\n                const updatedChannelFilters = { ...state.channelFilters };\n                if (state.currentChannelId && state.activeFilters.length > 0) {\n                    updatedChannelFilters[state.currentChannelId] = state.activeFilters;\n                }\n\n                // Load filters for the new channel\n                const newFilters = (channelId && updatedChannelFilters[channelId]) || [];\n\n                return {\n                    currentChannelId: channelId,\n                    channelFilters: updatedChannelFilters,\n                    activeFilters: newFilters,\n                    // Reset legacy selectedChannel filter when switching app channels\n                    selectedChannel: null\n                };\n            })\n        }),\n        {\n            name: 'filter-storage',\n            partialize: (state) => ({\n                homeSortBy: state.homeSortBy,\n                activeFilters: state.activeFilters, // Persist current active filters too\n                channelFilters: state.channelFilters, // Persist all channel filters\n                selectedChannel: state.selectedChannel,\n                currentChannelId: state.currentChannelId,\n                userId: state.userId\n            })\n        }\n    )\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/notificationStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/trafficFilterStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/trendStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[537,540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[537,540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport type { TrendChannel, TrendNiche, TimelineConfig, TrendVideo } from '../types/trends';\nimport type { FilterOperator } from './filterStore';\nimport { TrendService } from '../services/trendService';\nimport { useChannelStore } from './channelStore';\n\n// Trends-specific filter item (date, views, percentile)\nexport interface TrendsFilterItem {\n    id: string;\n    type: 'date' | 'views' | 'percentile' | 'niche';\n    operator: FilterOperator;\n    value: any;\n    label: string;\n}\n\n// Available percentile groups\nexport const PERCENTILE_GROUPS = [\n    'Top 1%',\n    'Top 5%',\n    'Top 20%',\n    'Middle 60%',\n    'Bottom 20%'\n] as const;\n\nexport type PercentileGroup = typeof PERCENTILE_GROUPS[number];\n\nconst DEFAULT_TIMELINE_CONFIG: TimelineConfig = {\n    zoomLevel: 1,\n    offsetX: 0,\n    offsetY: 0,\n    startDate: Date.now() - 30 * 24 * 60 * 60 * 1000, // Default last 30 days\n    endDate: Date.now(),\n    viewMode: 'per-channel',\n    scalingMode: 'log',\n    verticalSpread: 1.0, // Default 1.0 (Fit), range 0.0 to 1.0\n    timeLinearity: 1.0, // Default 1.0 (Compact)\n    showAverageBaseline: false, // Default off\n    baselineMode: 'dynamic', // Default to dynamic\n    baselineWindowSize: 30, // Default to 30 days\n};\n\nexport interface HiddenVideo {\n    id: string;\n    channelId: string;\n    hiddenAt: number;\n}\n\ninterface TrendStore {\n    // Data\n    userId: string | null;\n    videos: TrendVideo[];\n    channels: TrendChannel[];\n    niches: TrendNiche[];\n    videoNicheAssignments: Record<string, { nicheId: string; addedAt: number }[]>; // videoId -> array of niche assignments with timestamps\n    /**\n     * FILTER STORAGE ARCHITECTURE:\n     * \n     * channelRootFilters[channelId]:\n     *   Contains ROOT state (empty filters or UNASSIGNED filter).\n     *   Auto-synced when modifying filters while in ROOT/UNASSIGNED mode.\n     *   Used when clicking channel name to return to ROOT.\n     * \n     * nicheFilters[nicheId]:\n     *   Contains per-niche state (including TRASH at nicheFilters['TRASH']).\n     *   Manually saved when switching between niches.\n     *   TRASH is ONLY accessible via clicking \"Untracked\" niche.\n     */\n    channelRootFilters: Record<string, TrendsFilterItem[]>;\n    nicheFilters: Record<string, TrendsFilterItem[]>;\n    hiddenVideos: HiddenVideo[]; // Videos moved to trash\n\n    // UI State\n    timelineConfig: TimelineConfig;\n    filterMode: 'global' | 'filtered';\n    savedConfigs: Record<string, TimelineConfig>; // Keyed by channelId or 'global'\n    selectedChannelId: string | null; // null = Trends Overview, else = Single Channel View\n    selectedVideo: TrendVideo | null; // For floating bar\n    hoveredVideo: TrendVideo | null; // For tooltip\n    isAddChannelModalOpen: boolean;\n    isLoadingChannels: boolean; // Loading state for channels list\n    trendsFilters: TrendsFilterItem[]; // Filters for trends page\n    isDragging: boolean;\n    visualScale: number;\n    draggedBaseSize: number | null;\n    brokenAvatarChannelIds: Set<string>; // Track channels with broken avatars for sync refresh\n\n    // Actions\n    setUserId: (id: string | null) => void;\n    setVideos: (videos: TrendVideo[]) => void;\n    setChannels: (channels: TrendChannel[]) => void;\n    updateChannel: (id: string, updates: Partial<TrendChannel>) => void;\n    setNiches: (niches: TrendNiche[]) => void;\n    setVideoNicheAssignments: (assignments: Record<string, { nicheId: string; addedAt: number }[]>) => void;\n    setTimelineConfig: (config: Partial<TimelineConfig>) => void;\n    setHiddenVideos: (hidden: HiddenVideo[]) => void;\n    setSelectedChannelId: (id: string | null) => void;\n    setSelectedVideo: (video: TrendVideo | null) => void;\n    setHoveredVideo: (video: TrendVideo | null) => void;\n    setAddChannelModalOpen: (isOpen: boolean) => void;\n    setIsLoadingChannels: (isLoading: boolean) => void;\n    setFilterMode: (mode: 'global' | 'filtered') => void;\n\n    // Trends filter actions\n    addTrendsFilter: (filter: Omit<TrendsFilterItem, 'id'>) => void;\n    removeTrendsFilter: (id: string) => void;\n    clearTrendsFilters: () => void;\n    setTrendsFilters: (filters: TrendsFilterItem[]) => void;\n    setChannelRootFilters: (channelId: string, filters: TrendsFilterItem[]) => void;\n    setNicheFilters: (nicheId: string, filters: TrendsFilterItem[]) => void;\n    setIsDragging: (isDragging: boolean) => void;\n    setVisualScale: (scale: number) => void;\n    setDraggedBaseSize: (size: number | null) => void;\n    saveConfigForHash: (hash: string, config: Partial<TimelineConfig>) => void;\n    markAvatarBroken: (channelId: string) => void;\n    clearBrokenAvatar: (channelId: string) => void;\n\n    // Niche Actions\n    addNiche: (niche: Omit<TrendNiche, 'createdAt' | 'viewCount'>) => Promise<void>;\n    updateNiche: (id: string, updates: Partial<TrendNiche>) => Promise<void>;\n    deleteNiche: (id: string) => Promise<void>;\n    assignVideoToNiche: (videoId: string, nicheId: string, viewCount: number) => Promise<void>;\n    removeVideoFromNiche: (videoId: string, nicheId: string, viewCount: number) => Promise<void>;\n\n    // Niche Split/Merge Actions\n    splitNicheToLocal: (nicheId: string, channelDataMap: Map<string, { channelTitle: string; videoCount: number }>) => Promise<void>;\n    mergeNichesToGlobal: (sourceNicheIds: string[], targetNicheId: string) => Promise<void>;\n    removeVideosFromOtherChannels: (nicheId: string, keepChannelId: string) => Promise<void>;\n\n    // Hidden Videos Actions\n    hideVideos: (videos: { id: string; channelId: string }[]) => void;\n    restoreVideos: (ids: string[]) => void;\n\n    // Target Niche Actions (saves to currentChannel from channelStore)\n    setTargetNiche: (nicheId: string) => Promise<void>;\n    removeTargetNiche: (nicheId: string) => Promise<void>;\n\n    // Helpers\n    toggleChannelVisibility: (id: string) => void;\n}\n\nexport const useTrendStore = create<TrendStore>()(\n    persist(\n        (set, get) => ({\n            userId: null,\n            videos: [],\n            channels: [],\n            niches: [],\n            videoNicheAssignments: {},\n            channelRootFilters: {},\n            nicheFilters: {},\n            hiddenVideos: [],\n\n            timelineConfig: { ...DEFAULT_TIMELINE_CONFIG },\n            filterMode: 'global', // Default to global Scaling\n            savedConfigs: {},\n\n            selectedChannelId: null,\n            selectedVideo: null,\n            hoveredVideo: null,\n            isAddChannelModalOpen: false,\n            isLoadingChannels: true, // Start as loading\n            trendsFilters: [],\n            isDragging: false,\n            visualScale: 1,\n            draggedBaseSize: null,\n            brokenAvatarChannelIds: new Set(),\n\n            setUserId: (id) => set((state) => {\n                if (state.userId === id) return {};\n\n                // User changed! Reset sensitive state to default\n                return {\n                    userId: id,\n                    trendsFilters: [],\n                    channelRootFilters: {},\n                    nicheFilters: {},\n                    hiddenVideos: [], // Reset hidden videos too\n                    filterMode: 'global',\n                    savedConfigs: {},\n                    selectedChannelId: null,\n                    timelineConfig: { ...DEFAULT_TIMELINE_CONFIG }\n                };\n            }),\n\n            setVideos: (videos) => set({ videos }),\n\n            setChannels: (channels) => set({ channels }),\n\n            updateChannel: (id, updates) => set((state) => ({\n                channels: state.channels.map(c => c.id === id ? { ...c, ...updates } : c)\n            })),\n\n            setNiches: (niches) => set({ niches }),\n\n            setVideoNicheAssignments: (videoNicheAssignments) => set({ videoNicheAssignments }),\n\n            setTimelineConfig: (config) => set((state) => ({\n                timelineConfig: { ...state.timelineConfig, ...config }\n            })),\n\n            setHiddenVideos: (hiddenVideos) => set({ hiddenVideos }),\n\n            // Miro-like: viewport save/restore handled by useTimelineTransform via contentHash\n            // This action only updates the selected channel, filters are set by handleChannelClick\n            setSelectedChannelId: (id) => set({ selectedChannelId: id }),\n\n            setSelectedVideo: (video) => set({ selectedVideo: video }),\n\n            setHoveredVideo: (video) => set({ hoveredVideo: video }),\n\n            setAddChannelModalOpen: (isOpen) => set({ isAddChannelModalOpen: isOpen }),\n\n            setIsLoadingChannels: (isLoading) => set({ isLoadingChannels: isLoading }),\n            setFilterMode: (mode) => set({ filterMode: mode }),\n\n            /**\n             * Add a filter to trendsFilters.\n             * \n             * AUTO-SYNC RULE: If on a channel and NOT in a real niche, \n             * automatically save to channelRootFilters.\n             * - UNASSIGNED counts as ROOT (syncs)\n             * - TRASH and real niches do NOT sync (have their own storage)\n             */\n            addTrendsFilter: (filter) => set((state) => {\n                const newFilters = [...state.trendsFilters, { ...filter, id: crypto.randomUUID() }];\n\n                let newRootFilters = state.channelRootFilters;\n                const nicheFilter = newFilters.find(f => f.type === 'niche');\n                const isRealNiche = nicheFilter && !(nicheFilter.value as string[]).includes('UNASSIGNED');\n\n                if (state.selectedChannelId && !isRealNiche) {\n                    newRootFilters = {\n                        ...state.channelRootFilters,\n                        [state.selectedChannelId]: newFilters\n                    };\n                }\n\n                return { trendsFilters: newFilters, channelRootFilters: newRootFilters };\n            }),\n\n            /**\n             * Remove a filter from trendsFilters by ID.\n             * AUTO-SYNC: Same rules as addTrendsFilter.\n             */\n            removeTrendsFilter: (id) => set((state) => {\n                const newFilters = state.trendsFilters.filter((f) => f.id !== id);\n\n                let newRootFilters = state.channelRootFilters;\n                const nicheFilter = newFilters.find(f => f.type === 'niche');\n                const isRealNiche = nicheFilter && !(nicheFilter.value as string[]).includes('UNASSIGNED');\n\n                if (state.selectedChannelId && !isRealNiche) {\n                    newRootFilters = {\n                        ...state.channelRootFilters,\n                        [state.selectedChannelId]: newFilters\n                    };\n                }\n\n                return { trendsFilters: newFilters, channelRootFilters: newRootFilters };\n            }),\n\n            /**\n             * Clear all trendsFilters.\n             * Always syncs to channelRootFilters (empty = no niche = ROOT state).\n             */\n            clearTrendsFilters: () => set((state) => {\n                let newRootFilters = state.channelRootFilters;\n                if (state.selectedChannelId) {\n                    newRootFilters = {\n                        ...state.channelRootFilters,\n                        [state.selectedChannelId]: []\n                    };\n                }\n                return { trendsFilters: [], channelRootFilters: newRootFilters };\n            }),\n\n            /**\n             * Replace all trendsFilters atomically.\n             * AUTO-SYNC: Same rules as addTrendsFilter.\n             */\n            setTrendsFilters: (filters) => set((state) => {\n                let newRootFilters = state.channelRootFilters;\n                const nicheFilter = filters.find(f => f.type === 'niche');\n                const isRealNiche = nicheFilter && !(nicheFilter.value as string[]).includes('UNASSIGNED');\n\n                if (state.selectedChannelId && !isRealNiche) {\n                    newRootFilters = {\n                        ...state.channelRootFilters,\n                        [state.selectedChannelId]: filters\n                    };\n                }\n\n                return { trendsFilters: filters, channelRootFilters: newRootFilters };\n            }),\n\n            /**\n             * Manually save ROOT filters for a specific channel.\n             * Used when navigating away from a channel to preserve its ROOT state.\n             */\n            setChannelRootFilters: (channelId, filters) => set((state) => ({\n                channelRootFilters: {\n                    ...state.channelRootFilters,\n                    [channelId]: filters\n                }\n            })),\n\n            /**\n             * Manually save filters for a specific niche.\n             * Used when navigating away from a niche to preserve its state.\n             */\n            setNicheFilters: (nicheId, filters) => set((state) => ({\n                nicheFilters: {\n                    ...state.nicheFilters,\n                    [nicheId]: filters\n                }\n            })),\n            setIsDragging: (isDragging) => set({ isDragging }),\n            setVisualScale: (visualScale) => set({ visualScale }),\n            setDraggedBaseSize: (draggedBaseSize) => set({ draggedBaseSize }),\n\n            saveConfigForHash: (hash, config) => set((state) => ({\n                savedConfigs: {\n                    ...state.savedConfigs,\n                    [hash]: { ...state.savedConfigs[hash], ...config }\n                }\n            })),\n\n            markAvatarBroken: (channelId) => set((state) => {\n                const newSet = new Set(state.brokenAvatarChannelIds);\n                newSet.add(channelId);\n                return { brokenAvatarChannelIds: newSet };\n            }),\n\n            clearBrokenAvatar: (channelId) => set((state) => {\n                const newSet = new Set(state.brokenAvatarChannelIds);\n                newSet.delete(channelId);\n                return { brokenAvatarChannelIds: newSet };\n            }),\n\n            toggleChannelVisibility: (id) => set((state) => ({\n                channels: state.channels.map(c =>\n                    c.id === id ? { ...c, isVisible: !c.isVisible } : c\n                )\n            })),\n\n            // Niche Actions (now with optimistic updates)\n            addNiche: async (niche) => {\n                const { userId, niches } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n\n                // Optimistic Update\n                const fullNiche: TrendNiche = {\n                    ...niche,\n                    id: niche.id || crypto.randomUUID(),\n                    viewCount: 0,\n                    createdAt: Date.now()\n                };\n                set({ niches: [...niches, fullNiche] });\n\n                await TrendService.addNiche(userId, userChannelId, niche);\n            },\n\n            updateNiche: async (id, updates) => {\n                const { userId, niches } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n\n                // Optimistic Update\n                set({\n                    niches: niches.map(n => n.id === id ? { ...n, ...updates } : n)\n                });\n\n                await TrendService.updateNiche(userId, userChannelId, id, updates);\n            },\n\n            deleteNiche: async (id) => {\n                const { userId, niches } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n\n                // Optimistic Update\n                set({\n                    niches: niches.filter(n => n.id !== id)\n                });\n\n                await TrendService.deleteNiche(userId, userChannelId, id);\n            },\n\n            assignVideoToNiche: async (videoId, nicheId, viewCount) => {\n                const { userId, videoNicheAssignments } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n\n                // Optimistic Update\n                const current = videoNicheAssignments[videoId] || [];\n                if (!current.some(a => a.nicheId === nicheId)) {\n                    set({\n                        videoNicheAssignments: {\n                            ...videoNicheAssignments,\n                            [videoId]: [...current, { nicheId, addedAt: Date.now() }]\n                        }\n                    });\n                }\n\n                await TrendService.assignVideoToNiche(userId, userChannelId, videoId, nicheId, viewCount);\n            },\n\n            removeVideoFromNiche: async (videoId, nicheId, viewCount) => {\n                const { userId, videoNicheAssignments } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n\n                // Optimistic Update\n                const current = videoNicheAssignments[videoId] || [];\n                const filtered = current.filter(a => a.nicheId !== nicheId);\n\n                set({\n                    videoNicheAssignments: {\n                        ...videoNicheAssignments,\n                        [videoId]: filtered\n                    }\n                });\n\n                await TrendService.removeVideoFromNiche(userId, userChannelId, videoId, nicheId, viewCount);\n            },\n\n            // Niche Split/Merge Actions\n\n            /**\n             * Split a global niche into multiple local niches, one per channel.\n             * Creates new local niches for each channel that has videos in the original niche.\n             */\n            splitNicheToLocal: async (nicheId, channelDataMap) => {\n                const { userId, niches, videos } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n\n                const originalNiche = niches.find(n => n.id === nicheId);\n                if (!originalNiche) return;\n\n                // Create new local niches for each channel\n                const newNiches: TrendNiche[] = [];\n                channelDataMap.forEach((data, channelId) => {\n                    if (data.videoCount > 0) {\n                        newNiches.push({\n                            id: crypto.randomUUID(),\n                            name: originalNiche.name,\n                            color: originalNiche.color,\n                            type: 'local',\n                            channelId: channelId,\n                            viewCount: 0, // Will be updated by reassignVideosByChannel\n                            createdAt: Date.now()\n                        });\n                    }\n                });\n\n                // Optimistic update: add new niches, remove original\n                set({\n                    niches: [...niches.filter(n => n.id !== nicheId), ...newNiches]\n                });\n\n                // Backend operations\n                await TrendService.batchAddNiches(userId, userChannelId, newNiches);\n\n                // Reassign videos to new local niches\n                for (const newNiche of newNiches) {\n                    await TrendService.reassignVideosByChannel(\n                        userId,\n                        userChannelId,\n                        nicheId,\n                        newNiche.id,\n                        newNiche.channelId!,\n                        videos\n                    );\n                }\n\n                // Delete the original global niche\n                await TrendService.deleteNiche(userId, userChannelId, nicheId);\n            },\n\n            /**\n             * Merge multiple local niches (with same name) into a single global niche.\n             * Migrates all video assignments to the target niche and deletes source niches.\n             */\n            mergeNichesToGlobal: async (sourceNicheIds, targetNicheId) => {\n                const { userId, niches } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n\n                // Filter out target from sources (it stays, just becomes global)\n                const nichesToMerge = sourceNicheIds.filter(id => id !== targetNicheId);\n\n                // Optimistic update: remove source niches, update target to global\n                set({\n                    niches: niches\n                        .filter(n => !nichesToMerge.includes(n.id))\n                        .map(n => n.id === targetNicheId ? { ...n, type: 'global' as const } : n)\n                });\n\n                // Migrate assignments from each source niche to target\n                for (const sourceId of nichesToMerge) {\n                    await TrendService.migrateNicheAssignments(userId, userChannelId, sourceId, targetNicheId);\n                }\n\n                // Update target niche to global\n                await TrendService.updateNiche(userId, userChannelId, targetNicheId, { type: 'global' });\n\n                // Delete source niches\n                await TrendService.batchDeleteNiches(userId, userChannelId, nichesToMerge);\n            },\n\n            /**\n             * Remove video assignments from channels other than keepChannelId,\n             * then convert the niche to local.\n             */\n            removeVideosFromOtherChannels: async (nicheId, keepChannelId) => {\n                const { userId, niches, videos } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n\n                // Optimistic update: convert to local immediately\n                set({\n                    niches: niches.map(n =>\n                        n.id === nicheId\n                            ? { ...n, type: 'local' as const, channelId: keepChannelId }\n                            : n\n                    )\n                });\n\n                // Remove assignments for non-keepChannel videos\n                await TrendService.removeNonChannelAssignments(userId, userChannelId, nicheId, keepChannelId, videos);\n\n                // Update niche to local\n                await TrendService.updateNiche(userId, userChannelId, nicheId, {\n                    type: 'local',\n                    channelId: keepChannelId\n                });\n            },\n\n            // Hidden Videos Actions\n            hideVideos: async (videos) => {\n                const { userId } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n                await TrendService.hideVideos(userId, userChannelId, videos);\n            },\n\n            restoreVideos: async (ids) => {\n                const { userId } = get();\n                const userChannelId = useChannelStore.getState().currentChannel?.id;\n                if (!userId || !userChannelId) return;\n                await TrendService.restoreVideos(userId, userChannelId, ids);\n            },\n\n            // Target Niche Actions\n            /**\n             * Set a niche as a target for the current user channel (max 2 targets).\n             * Used to remind users which niches they want to focus on for their channel.\n             * NOTE: This saves to the USER's channel (from ChannelDropdown), not to TrendChannel.\n             */\n            setTargetNiche: async (nicheId) => {\n                const { userId, niches } = get();\n                const currentChannel = useChannelStore.getState().currentChannel;\n                if (!userId || !currentChannel) return;\n\n                const currentTargets = currentChannel.targetNicheIds || [];\n\n                // Already targeted or max 2 reached\n                if (currentTargets.includes(nicheId) || currentTargets.length >= 2) return;\n\n                const niche = niches.find(n => n.id === nicheId);\n                if (!niche) return;\n\n                const newTargetIds = [...currentTargets, nicheId];\n                const currentNames = currentChannel.targetNicheNames || [];\n                const newTargetNames = [...currentNames, niche.name];\n\n                // Update via channelStore (which persists to Firestore)\n                await useChannelStore.getState().updateChannel(userId, currentChannel.id, {\n                    targetNicheIds: newTargetIds,\n                    targetNicheNames: newTargetNames\n                });\n\n                // Also update the current channel in memory\n                useChannelStore.getState().setCurrentChannel({\n                    ...currentChannel,\n                    targetNicheIds: newTargetIds,\n                    targetNicheNames: newTargetNames\n                });\n            },\n\n            /**\n             * Remove a niche from the current user channel's targets.\n             */\n            removeTargetNiche: async (nicheId) => {\n                const { userId, niches } = get();\n                const currentChannel = useChannelStore.getState().currentChannel;\n                if (!userId || !currentChannel) return;\n\n                const currentTargetIds = currentChannel.targetNicheIds || [];\n                const indexToRemove = currentTargetIds.indexOf(nicheId);\n                if (indexToRemove === -1) return;\n\n                const newTargetIds = currentTargetIds.filter(id => id !== nicheId);\n\n                // Rebuild names from remaining IDs (in case names array was out of sync)\n                const newTargetNames = newTargetIds.map(id => {\n                    const niche = niches.find(n => n.id === id);\n                    return niche?.name || '';\n                }).filter(Boolean);\n\n                // Update via channelStore (which persists to Firestore)\n                await useChannelStore.getState().updateChannel(userId, currentChannel.id, {\n                    targetNicheIds: newTargetIds,\n                    targetNicheNames: newTargetNames\n                });\n\n                // Also update the current channel in memory\n                useChannelStore.getState().setCurrentChannel({\n                    ...currentChannel,\n                    targetNicheIds: newTargetIds,\n                    targetNicheNames: newTargetNames\n                });\n            },\n        }),\n        {\n            name: 'trend-store',\n            partialize: (state) => ({\n                timelineConfig: state.timelineConfig,\n                savedConfigs: state.savedConfigs,\n                selectedChannelId: state.selectedChannelId,\n                channelRootFilters: state.channelRootFilters,\n                nicheFilters: state.nicheFilters,\n                trendsFilters: state.trendsFilters,\n                // hiddenVideos: state.hiddenVideos, // Moved to Firestore\n                filterMode: state.filterMode,\n                userId: state.userId\n            }),\n        }\n    )\n);\n\n// Manual Palette for user selection (10 distinct colors)\nexport const MANUAL_NICHE_PALETTE = [\n    // Slate\n    '#64748b', '#475569',\n    // Gray\n    '#6b7280', '#4b5563',\n    // Zinc\n    '#71717a', '#52525b',\n    // Neutral\n    '#737373', '#525252',\n    // Stone\n    '#78716c', '#57534e',\n    // Red\n    '#ef4444', '#dc2626',\n    // Orange\n    '#f97316', '#ea580c',\n    // Amber\n    '#f59e0b', '#d97706',\n    // Yellow\n    '#eab308', '#ca8a04',\n    // Lime\n    '#84cc16', '#65a30d',\n    // Green\n    '#22c55e', '#16a34a',\n    // Emerald\n    '#10b981', '#059669',\n    // Teal\n    '#14b8a6', '#0d9488',\n    // Cyan\n    '#06b6d4', '#0891b2',\n    // Sky\n    '#0ea5e9', '#0284c7',\n    // Blue\n    '#3b82f6', '#2563eb',\n    // Indigo\n    '#6366f1', '#4f46e5',\n    // Violet\n    '#8b5cf6', '#7c3aed',\n    // Purple\n    '#a855f7', '#9333ea',\n    // Fuchsia\n    '#d946ef', '#c026d3',\n    // Pink\n    '#ec4899', '#db2777',\n    // Rose\n    '#f43f5e', '#e11d48',\n];\n\n// Auto Palette\nconst AUTO_NICHE_PALETTE = [\n    '#F87171', '#FB923C', '#FBBF24', '#A3E635', '#34D399', '#22D3EE', '#60A5FA', '#818CF8', '#A78BFA', '#F472B6',\n    '#B91C1C', '#C2410C', '#B45309', '#4D7C0F', '#047857', '#0E7490', '#1D4ED8', '#4338CA', '#5B21B6', '#BE185D',\n    '#991B1B', '#9A3412', '#92400E', '#3F6212', '#065F46', '#155E75', '#1E40AF', '#3730A3', '#4C1D95', '#9D174D',\n];\n\n// Helper to generate premium colors\nexport const generateNicheColor = (existingColors: string[]): string => {\n    const available = AUTO_NICHE_PALETTE.filter(c => !existingColors.includes(c));\n\n    if (available.length > 0) {\n        return available[Math.floor(Math.random() * available.length)];\n    }\n\n    const recent = new Set(existingColors.slice(-5));\n    const candidates = AUTO_NICHE_PALETTE.filter(c => !recent.has(c));\n\n    if (candidates.length > 0) {\n        return candidates[Math.floor(Math.random() * candidates.length)];\n    }\n\n    return AUTO_NICHE_PALETTE[Math.floor(Math.random() * AUTO_NICHE_PALETTE.length)];\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/uiStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/useTrafficNicheStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/useTrafficTypeStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/stores/useViewerTypeStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/types/suggestedTrafficNiches.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/types/traffic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/types/trends.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/types/versioning.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1190,1193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1190,1193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { VideoLocalization } from '../utils/youtubeApi';\n\n/**\n * Active Period  .\n *   ,    .\n */\nexport interface ActivePeriod {\n    startDate: number;\n    endDate: number | null;\n    closingSnapshotId: string | null;\n}\n\n/**\n * Packaging Snapshot.\n *       .\n */\nexport interface PackagingSnapshot {\n    title: string;\n    description: string;\n    tags: string[];\n    coverImage: string | null;\n    abTestTitles?: string[];\n    abTestThumbnails?: string[];\n    abTestResults?: {\n        titles: number[];\n        thumbnails: number[];\n    };\n    abTestVariants?: string[];\n    localizations?: Record<string, VideoLocalization>;\n    originalName?: string;\n}\n\n/**\n * Packaging Version.\n *       .\n */\nexport interface PackagingVersion {\n    versionNumber: number;\n    startDate: number;\n    endDate: number | null;\n    configurationSnapshot: PackagingSnapshot | null;\n    activePeriods?: ActivePeriod[];\n    revision: number; // NEW:  tracking stale state  race conditions\n    cloneOf?: number; // Alias support\n    checkins?: any[]; // Legacy or specific checkin data\n    restoredAt?: number;\n}\n\n/**\n * Traffic Snapshot (Base).\n * Core fields for traffic snapshot identification and storage.\n * Extended in traffic.ts with additional metadata fields.\n */\nexport interface TrafficSnapshotBase {\n    id: string;\n    version: number;\n    timestamp: number;\n    createdAt: string;\n    storagePath: string; // REQUIRED:   CSV  Cloud Storage (no legacy support)\n    summary: {\n        totalViews: number;\n        totalWatchTime: number;\n        sourcesCount: number;\n        topSource?: string;\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/types/videoTrafficType.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/types/viewerType.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/contextUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/deepEqual.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[337,340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[337,340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[345,348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[345,348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performs a deep comparison between two values to determine if they are equivalent.\n * Optimized for JSON-like objects (primitives, arrays, plain objects).\n * \n * @param a - First value to compare\n * @param b - Second value to compare\n * @returns true if the values are equivalent, false otherwise\n */\nexport function deepEqual(a: any, b: any): boolean {\n    if (a === b) return true;\n\n    if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') {\n        return false;\n    }\n\n    if (Array.isArray(a) !== Array.isArray(b)) {\n        return false;\n    }\n\n    if (Array.isArray(a)) {\n        if (a.length !== b.length) return false;\n        for (let i = 0; i < a.length; i++) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }\n        return true;\n    }\n\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    for (const key of keysA) {\n        if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n        if (!deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/dueDateUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/dueDateUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/filterUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[151,154],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[151,154],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FilterOperator } from '../stores/filterStore';\n\nexport const applyNumericFilter = (value: number, operator: FilterOperator, filterValue: any): boolean => {\n    switch (operator) {\n        case 'gte': return value >= filterValue;\n        case 'lte': return value <= filterValue;\n        case 'gt': return value > filterValue;\n        case 'lt': return value < filterValue;\n        case 'equals': return value === filterValue;\n        case 'between': {\n            const [min, max] = filterValue;\n            return value >= min && value <= max;\n        }\n        default: return true;\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/formatUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/formatUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/imageUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[487,490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[487,490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Structured Logger Utility\n * \n * Provides consistent logging across the application with:\n * - Log levels (debug, info, warn, error)\n * - Contextual metadata (userId, videoId, version)\n * - Environment-aware formatting (pretty in dev, JSON in prod)\n */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nexport interface LogContext {\n    userId?: string;\n    channelId?: string;\n    videoId?: string;\n    version?: number | 'draft';\n    component?: string;\n    [key: string]: any;\n}\n\nclass Logger {\n    private isDevelopment = import.meta.env.DEV;\n\n    private log(level: LogLevel, message: string, context?: LogContext) {\n        // Skip debug logs in production\n        if (level === 'debug' && !this.isDevelopment) {\n            return;\n        }\n\n        const timestamp = new Date().toISOString();\n        const logEntry = {\n            timestamp,\n            level,\n            message,\n            ...context\n        };\n\n        // In development: pretty print with colors\n        if (this.isDevelopment) {\n            const colorMap: Record<LogLevel, string> = {\n                debug: '\\x1b[36m', // Cyan\n                info: '\\x1b[32m',  // Green\n                warn: '\\x1b[33m',  // Yellow\n                error: '\\x1b[31m'  // Red\n            };\n\n            const color = colorMap[level];\n            const reset = '\\x1b[0m';\n            const componentTag = context?.component ? `[${context.component}]` : '';\n\n            console.log(`${color}[${level.toUpperCase()}]${reset} ${componentTag} ${message}`, context || '');\n        } else {\n            // In production: structured JSON for log aggregation\n            console.log(JSON.stringify(logEntry));\n        }\n    }\n\n    debug(message: string, context?: LogContext) {\n        this.log('debug', message, context);\n    }\n\n    info(message: string, context?: LogContext) {\n        this.log('info', message, context);\n    }\n\n    warn(message: string, context?: LogContext) {\n        this.log('warn', message, context);\n    }\n\n    error(message: string, context?: LogContext) {\n        this.log('error', message, context);\n    }\n\n    /**\n     * Create a scoped logger with pre-filled context\n     * Useful for components that always log with the same context\n     */\n    scope(defaultContext: LogContext) {\n        return new ScopedLogger(this, defaultContext);\n    }\n}\n\n/**\n * Scoped Logger - pre-fills context for a specific component/module\n */\nclass ScopedLogger {\n    private logger: Logger;\n    private defaultContext: LogContext;\n\n    constructor(logger: Logger, defaultContext: LogContext) {\n        this.logger = logger;\n        this.defaultContext = defaultContext;\n    }\n\n    debug(message: string, additionalContext?: LogContext) {\n        this.logger.debug(message, { ...this.defaultContext, ...additionalContext });\n    }\n\n    info(message: string, additionalContext?: LogContext) {\n        this.logger.info(message, { ...this.defaultContext, ...additionalContext });\n    }\n\n    warn(message: string, additionalContext?: LogContext) {\n        this.logger.warn(message, { ...this.defaultContext, ...additionalContext });\n    }\n\n    error(message: string, additionalContext?: LogContext) {\n        this.logger.error(message, { ...this.defaultContext, ...additionalContext });\n    }\n}\n\n// Export singleton instance\nexport const logger = new Logger();\n\n// Domain-Scoped Loggers for centralized control\nexport const trafficLogger = logger.scope({ component: 'Traffic' });\nexport const assistantLogger = logger.scope({ component: 'SmartAssistant' });\nexport const snapshotLogger = logger.scope({ component: 'TrafficSnapshot' });\nexport const csvLogger = logger.scope({ component: 'CsvProcessing' });\nexport const storageLogger = logger.scope({ component: 'Storage' });\nexport const youtubeLogger = logger.scope({ component: 'YouTubeAPI' });\n\n// Legacy/Compatibility exports if needed\nexport default logger;\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/migration/suggestedVideosMigration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/snapshotUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/trendStyles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/videoAdapters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/core/utils/youtubeApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Notifications/NotificationDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Notifications/NotificationItem.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useMemo has unnecessary dependencies: 'notification.internalId' and 'packagingSettings.checkinRules'. Either exclude them or remove the dependency array.","line":21,"column":8,"nodeType":"ArrayExpression","endLine":21,"endColumn":110,"suggestions":[{"desc":"Update the dependencies array to be: [notification.customColor, notification.type]","fix":{"range":[882,984],"text":"[notification.customColor, notification.type]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Trash2, Info, AlertCircle, CheckCircle } from 'lucide-react';\nimport { useNotificationStore, type Notification } from '../../core/stores/notificationStore';\nimport { formatDistanceToNow } from 'date-fns';\n\ninterface NotificationItemProps {\n    notification: Notification;\n    onAction?: (notification: Notification) => void;\n}\n\nimport { useSettings } from '../../core/hooks/useSettings';\n\nexport const NotificationItem: React.FC<NotificationItemProps> = ({ notification, onAction }) => {\n    const { markAsRead, removeNotification } = useNotificationStore();\n    const { packagingSettings } = useSettings();\n\n    const effectiveColor = React.useMemo(() => {\n        if (notification.type === 'success') return '#22c55e'; // green-500\n        return notification.customColor;\n    }, [notification.internalId, notification.customColor, notification.type, packagingSettings.checkinRules]);\n\n    const getIcon = (size: number = 20) => {\n        switch (notification.type) {\n            case 'error': return <AlertCircle size={size} className=\"text-red-500\" />;\n            case 'warning': return <AlertCircle size={size} className=\"text-yellow-500\" />;\n            case 'success': return <CheckCircle size={size} className=\"text-green-500\" />;\n            default: return <Info size={size} className={effectiveColor ? '' : \"text-blue-500\"} style={{ color: effectiveColor }} />;\n        }\n    };\n\n    const handleClick = () => {\n        if (!notification.isRead) {\n            markAsRead(notification.id);\n        }\n        onAction?.(notification);\n    };\n\n    const [showTooltip, setShowTooltip] = useState(false);\n    const [tooltipPos, setTooltipPos] = useState({ top: 0, left: 0 });\n    const badgeRef = useRef<HTMLDivElement>(null);\n\n    const handleMouseEnter = () => {\n        if (badgeRef.current) {\n            const rect = badgeRef.current.getBoundingClientRect();\n            setTooltipPos({\n                top: rect.bottom + window.scrollY + 5,\n                left: rect.left + window.scrollX\n            });\n            setShowTooltip(true);\n        }\n    };\n\n    const handleMouseLeave = () => {\n        setShowTooltip(false);\n    };\n\n    return (\n        <div\n            onClick={handleClick}\n            className={`p-4 transition-colors flex gap-3 group relative cursor-pointer items-center\n                hover:bg-hover-bg\n            `}\n            style={{\n                backgroundColor: !notification.isRead\n                    ? (effectiveColor ? `${effectiveColor}08` : 'rgba(59, 130, 246, 0.05)')\n                    : undefined\n            }}\n        >\n            {/* Unread Indicator */}\n            {!notification.isRead && (\n                <div\n                    className=\"absolute left-0 top-1/2 -translate-y-1/2 w-1 h-12 rounded-r-full\"\n                    style={{ backgroundColor: effectiveColor || '#3b82f6' }}\n                />\n            )}\n\n            {/* Icon / Thumbnail Section */}\n            <div className=\"flex-shrink-0\">\n                {notification.thumbnail ? (\n                    <div className=\"relative group/image\">\n                        <div\n                            className=\"w-24 aspect-video rounded-md overflow-hidden bg-bg-secondary shadow-sm border transition-colors\"\n                            style={{\n                                borderColor: effectiveColor ? `${effectiveColor}80` : 'rgba(var(--border), 0.5)'\n                            }}\n                        >\n                            <img\n                                src={notification.thumbnail}\n                                alt=\"\"\n                                className=\"w-full h-full object-cover\"\n                            />\n                        </div>\n                        {/* Icon Badge Overlay */}\n                        <div\n                            className=\"absolute -bottom-1 -right-1 w-6 h-6 rounded-full bg-bg-primary flex items-center justify-center shadow-sm border border-border\"\n                            style={effectiveColor ? {\n                                color: effectiveColor,\n                                borderColor: `${effectiveColor}30`\n                            } : undefined}\n                        >\n                            {getIcon(14)}\n                        </div>\n                    </div>\n                ) : (\n                    <div\n                        className=\"w-10 h-10 rounded-full bg-bg-secondary flex items-center justify-center border border-border overflow-hidden\"\n                        style={effectiveColor ? {\n                            backgroundColor: `${effectiveColor}15`,\n                            borderColor: `${effectiveColor}30`,\n                            color: effectiveColor\n                        } : undefined}\n                    >\n                        {notification.avatarUrl ? (\n                            <img src={notification.avatarUrl} alt=\"\" className=\"w-full h-full object-cover\" />\n                        ) : (\n                            getIcon()\n                        )}\n                    </div>\n                )}\n            </div>\n\n            <div className=\"flex-1 min-w-0\">\n                <p className=\"text-sm font-medium text-text-primary leading-tight mb-1\">\n                    {notification.title}\n                </p>\n                <p className=\"text-sm text-text-secondary line-clamp-2 mb-1\">\n                    {notification.message}\n                </p>\n                <p className=\"text-xs text-text-secondary\">\n                    {formatDistanceToNow(notification.timestamp, { addSuffix: true })}\n                </p>\n                {notification.meta && (\n                    <div className=\"flex items-center gap-1.5 mt-2 relative group/quota\">\n                        <span className=\"text-[10px] font-bold tracking-wider text-text-tertiary uppercase opacity-50\">\n                            Quota used:\n                        </span>\n                        <div\n                            ref={badgeRef}\n                            onMouseEnter={handleMouseEnter}\n                            onMouseLeave={handleMouseLeave}\n                            className=\"px-1.5 py-0.5 rounded border border-green-500/20 bg-green-500/10 cursor-help transition-colors hover:bg-green-500/20\"\n                        >\n                            <p className=\"text-[10px] text-green-400 font-mono\">\n                                {notification.meta} units\n                            </p>\n                        </div>\n\n                        {/* Quota Breakdown Tooltip - Portal */}\n                        {notification.quotaBreakdown && showTooltip && createPortal(\n                            <div\n                                className=\"fixed z-[9999] p-2 bg-[#1a1a1a] border border-white/10 rounded-md shadow-xl pointer-events-none min-w-[120px] animate-in fade-in zoom-in-95 duration-100\"\n                                style={{\n                                    top: tooltipPos.top,\n                                    left: tooltipPos.left,\n                                }}\n                            >\n                                <div className=\"space-y-1\">\n                                    {notification.quotaBreakdown.search && (\n                                        <div className=\"flex justify-between items-center gap-4\">\n                                            <span className=\"text-[10px] text-text-tertiary\">Search:</span>\n                                            <span className=\"text-[10px] text-white font-mono\">{notification.quotaBreakdown.search}</span>\n                                        </div>\n                                    )}\n                                    {notification.quotaBreakdown.list && (\n                                        <div className=\"flex justify-between items-center gap-4\">\n                                            <span className=\"text-[10px] text-text-tertiary\">Video List:</span>\n                                            <span className=\"text-[10px] text-white font-mono\">{notification.quotaBreakdown.list}</span>\n                                        </div>\n                                    )}\n                                    {notification.quotaBreakdown.details && (\n                                        <div className=\"flex justify-between items-center gap-4\">\n                                            <span className=\"text-[10px] text-text-tertiary\">Video Details:</span>\n                                            <span className=\"text-[10px] text-white font-mono\">{notification.quotaBreakdown.details}</span>\n                                        </div>\n                                    )}\n                                </div>\n                            </div>,\n                            document.body\n                        )}\n                    </div>\n                )}\n            </div>\n\n            <div className=\"flex-shrink-0\">\n                {!notification.isPersistent && (\n                    <button\n                        onClick={(e) => {\n                            e.stopPropagation();\n                            removeNotification(notification.id);\n                        }}\n                        className=\"p-2 rounded-full hover:bg-hover-bg text-text-secondary hover:text-red-500 opacity-0 group-hover:opacity-100 transition-all\"\n                        title=\"Delete\"\n                    >\n                        <Trash2 size={18} />\n                    </button>\n                )}\n            </div>\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Playlist/AddToPlaylistModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Playlist/CreatePlaylistModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Playlist/PlaylistCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Playlist/PlaylistDetailPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Playlist/PlaylistEditModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Playlist/PlaylistMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Playlist/PlaylistsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Playlist/PlaylistsPageSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Profile/ChannelDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Profile/ChannelSelectorModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Profile/CreateChannelModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Profile/EditChannelModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Profile/ProfileModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/ApiSyncSettings.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/features/Settings/ApiSyncSettings.tsx:55:9\n  53 |     useEffect(() => {\n  54 |         // Sync local unit state if settings change externally\n> 55 |         setCurrentUnit(getUnit(syncSettings.frequencyHours));\n     |         ^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  56 |     }, [syncSettings.frequencyHours]);\n  57 |\n  58 |     const updateFrequency = (val: number, unit: string) => {","line":55,"column":9,"nodeType":null,"endLine":55,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { ChevronDown, Eye, EyeOff, RefreshCw } from 'lucide-react';\nimport { Dropdown } from '../../components/Shared/Dropdown';\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\nimport { useVideoSync } from '../../core/hooks/useVideoSync';\n\nimport type { GeneralSettings, SyncSettings } from '../../core/services/settingsService';\n\ninterface ThemeProps {\n    isDark: boolean;\n    textSecondary: string;\n    hoverBg?: string;\n    activeItemBg?: string;\n    activeItemText?: string;\n    borderColor?: string;\n    bgMain?: string;\n    textPrimary?: string;\n}\n\ninterface ApiSyncSettingsProps {\n    generalSettings: GeneralSettings;\n    syncSettings: SyncSettings;\n    onGeneralChange: (s: GeneralSettings) => void;\n    onSyncChange: (s: SyncSettings) => void;\n    theme: ThemeProps;\n}\n\nexport const ApiSyncSettings: React.FC<ApiSyncSettingsProps> = ({ generalSettings, syncSettings, onGeneralChange, onSyncChange, theme }) => {\n    const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null);\n    const [showApiKey, setShowApiKey] = useState(true); // Default to visible\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { syncAllVideos, isSyncing } = useVideoSync(user?.uid || '', currentChannel?.id || '');\n\n    const getUnit = (hours: number) => {\n        if (hours % 168 === 0 && hours >= 168) return 'Weeks';\n        if (hours % 24 === 0 && hours >= 24) return 'Days';\n        if (hours >= 1 && Number.isInteger(hours)) return 'Hours';\n        return 'Minutes';\n    };\n\n    const getValue = (hours: number, unit: string) => {\n        if (unit === 'Weeks') return hours / 168;\n        if (unit === 'Days') return hours / 24;\n        if (unit === 'Minutes') return Math.round(hours * 60);\n        return hours;\n    };\n\n    // State for the currently selected unit\n    const [currentUnit, setCurrentUnit] = useState(() => getUnit(syncSettings.frequencyHours));\n\n    useEffect(() => {\n        // Sync local unit state if settings change externally\n        setCurrentUnit(getUnit(syncSettings.frequencyHours));\n    }, [syncSettings.frequencyHours]);\n\n    const updateFrequency = (val: number, unit: string) => {\n        let newHours = val;\n        if (unit === 'Weeks') newHours = val * 168;\n        else if (unit === 'Days') newHours = val * 24;\n        else if (unit === 'Minutes') newHours = val / 60;\n\n        onSyncChange({ ...syncSettings, frequencyHours: Math.max(0.01, newHours) });\n        setCurrentUnit(unit);\n    };\n\n    const currentValue = getValue(syncSettings.frequencyHours, currentUnit);\n\n    // Updated input styles to use CSS variables\n    const inputBg = 'bg-[var(--settings-input-bg)]';\n    const inputBorder = 'border-border';\n    const focusBorder = 'focus:border-text-primary';\n    // Dropdown specific styles using CSS variables\n    const dropdownBg = 'bg-[var(--settings-dropdown-bg)]';\n    const dropdownHover = 'hover:bg-[var(--settings-dropdown-hover)]';\n\n    return (\n        <div className=\"space-y-8 animate-fade-in max-w-[600px]\">\n            {/* API Key Section */}\n            <section className=\"space-y-4\">\n                <h3 className=\"text-base font-medium\">API Configuration</h3>\n                <div className=\"space-y-2\">\n                    <label className={`text-sm ${theme.textSecondary}`}>YouTube API Key</label>\n                    <div className=\"relative\">\n                        <input\n                            type={showApiKey ? \"text\" : \"password\"}\n                            value={generalSettings.apiKey || ''}\n                            onChange={(e) => onGeneralChange({ ...generalSettings, apiKey: e.target.value })}\n                            placeholder=\"Enter your API key\"\n                            className={`w-full ${inputBg} border ${inputBorder} rounded-md pl-3 pr-10 py-2 focus:outline-none ${focusBorder} transition-colors placeholder-text-secondary`}\n                        />\n                        <button\n                            onClick={() => setShowApiKey(!showApiKey)}\n                            className=\"absolute right-3 top-1/2 -translate-y-1/2 text-text-secondary hover:text-text-primary transition-colors\"\n                        >\n                            {showApiKey ? <EyeOff size={16} /> : <Eye size={16} />}\n                        </button>\n                    </div>\n                    <p className={`text-xs ${theme.textSecondary}`}>\n                        Required for fetching video details and channel information.\n                    </p>\n                </div>\n            </section>\n\n            <div className={`border-t ${theme.borderColor}`} />\n\n            {/* Sync Section */}\n            <section className=\"space-y-6\">\n                <div className=\"space-y-1\">\n                    <div className=\"flex items-center gap-2\">\n                        <h3 className=\"text-base font-medium\">Sync Configuration</h3>\n                    </div>\n                    <p className={`text-sm ${theme.textSecondary}`}>\n                        Control automatic data updates and synchronization.\n                    </p>\n                </div>\n\n                {/* Auto Sync Frequency */}\n                <div className={`border ${theme.borderColor} rounded-md p-4`}>\n                    <label className={`block text-xs ${theme.textSecondary} mb-2`}>Update Frequency</label>\n                    <div className=\"flex items-center gap-4\">\n                        <div className=\"w-24 relative\">\n                            <input\n                                type=\"text\"\n                                value={currentValue}\n                                onChange={(e) => {\n                                    const val = parseFloat(e.target.value) || 0;\n                                    updateFrequency(val, currentUnit);\n                                }}\n                                className={`w-full ${inputBg} border ${inputBorder} rounded-md px-3 py-2 focus:outline-none ${focusBorder} transition-colors no-spinner`}\n                            />\n                        </div>\n\n                        <div className=\"relative w-32\">\n                            <button\n                                onClick={(e) => setAnchorEl(e.currentTarget)}\n                                className={`w-full flex items-center justify-between ${inputBg} border ${inputBorder} rounded-md px-3 py-2 hover:border-gray-400 transition-colors`}\n                            >\n                                <span className=\"text-sm\">{currentUnit}</span>\n                                <ChevronDown size={16} className={`${theme.textSecondary} transition-transform ${anchorEl ? 'rotate-180' : ''}`} />\n                            </button>\n\n                            <Dropdown\n                                isOpen={Boolean(anchorEl)}\n                                anchorEl={anchorEl}\n                                onClose={() => setAnchorEl(null)}\n                                width={128}\n                                className={`${dropdownBg} border-none z-[10000]`}\n                            >\n                                {['Minutes', 'Hours', 'Days', 'Weeks'].map((unit) => (\n                                    <div\n                                        key={unit}\n                                        className={`px-4 py-2.5 text-sm cursor-pointer ${dropdownHover} transition-colors`}\n                                        onClick={() => {\n                                            updateFrequency(currentValue, unit);\n                                            setAnchorEl(null);\n                                        }}\n                                    >\n                                        {unit}\n                                    </div>\n                                ))}\n                            </Dropdown>\n                        </div>\n                    </div>\n                </div>\n            </section>\n\n            <div className={`border-t ${theme.borderColor}`} />\n\n            {/* Manual Sync Section */}\n            <section className=\"space-y-4\">\n                <div className=\"space-y-1\">\n                    <h3 className=\"text-base font-medium\">Manual Sync</h3>\n                    <p className={`text-sm ${theme.textSecondary}`}>\n                        Force an immediate update of all tracked metrics.\n                    </p>\n                </div>\n\n                <button\n                    onClick={() => {\n                        if (user && currentChannel && generalSettings.apiKey) {\n                            syncAllVideos(generalSettings.apiKey);\n                        } else if (!generalSettings.apiKey) {\n                            // Ideally show a toast here, but alert is a quick fallback if no toast hook available in this file context yet\n                            // Actually we can just rely on the button incorrectly not disabling for now or just generic alert\n                            alert(\"Please set API Key first\");\n                        }\n                    }}\n                    disabled={isSyncing || !generalSettings.apiKey}\n                    className={`w-full py-2 rounded-md font-medium text-sm flex items-center justify-center gap-2 transition-colors ${isSyncing || !generalSettings.apiKey ? `${theme.activeItemBg} ${theme.textSecondary} cursor-not-allowed` : 'bg-blue-600 text-white hover:bg-blue-700 cursor-pointer'}`}\n                >\n                    <RefreshCw size={16} className={isSyncing ? 'animate-spin' : ''} />\n                    {isSyncing ? 'Syncing...' : 'Sync Now'}\n                </button>\n            </section>\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/CloneSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/PackagingSettingsView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/SettingsDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/SettingsMenuApiKey.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/SettingsMenuAppearance.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/SettingsMenuClone.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/SettingsMenuMain.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/SettingsMenuSync.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/SettingsModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3879,3882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3879,3882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4337,4340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4337,4340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4585,4588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4585,4588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4668,4671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4668,4671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4731,4734],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4731,4734],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":146,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6569,6572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6569,6572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6653,6656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6653,6656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'cloneSettings', 'generalSettings', 'packagingSettings', 'syncSettings', and 'uploadDefaults'. Either include them or remove the dependency array.","line":65,"column":8,"nodeType":"ArrayExpression","endLine":65,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [cloneSettings, generalSettings, isOpen, packagingSettings, syncSettings, uploadDefaults]","fix":{"range":[2955,2963],"text":"[cloneSettings, generalSettings, isOpen, packagingSettings, syncSettings, uploadDefaults]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { useSettings } from '../../core/hooks/useSettings';\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\nimport { useVideos } from '../../core/hooks/useVideos';\nimport { VideoService } from '../../core/services/videoService';\nimport { NotificationService } from '../../core/services/notificationService';\nimport type { GeneralSettings, SyncSettings, CloneSettings as CloneSettingsType, PackagingSettings, UploadDefaults } from '../../core/services/settingsService';\n\nimport { SettingsSidebar } from './SettingsSidebar';\nimport { ApiSyncSettings } from './ApiSyncSettings';\nimport { CloneSettings } from './CloneSettings';\nimport { PackagingSettingsView } from './PackagingSettingsView';\nimport { UploadDefaultsSettings } from './UploadDefaultsSettings';\n\ninterface SettingsModalProps {\n    isOpen: boolean;\n    onClose: () => void;\n}\n\ntype Category = 'api_sync' | 'clone' | 'packaging' | 'upload_defaults';\n\nexport const SettingsModal: React.FC<SettingsModalProps> = ({ isOpen, onClose }) => {\n    const {\n        generalSettings, updateGeneralSettings,\n        syncSettings, updateSyncSettings,\n        cloneSettings, updateCloneSettings,\n        packagingSettings, updatePackagingSettings,\n        uploadDefaults, updateUploadDefaults\n    } = useSettings();\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    useVideos(user?.uid || '', currentChannel?.id || '');\n\n    const [activeCategory, setActiveCategory] = useState<Category>('api_sync');\n    const [isClosing, setIsClosing] = useState(false);\n    const [isSaving, setIsSaving] = useState(false);\n\n    // Local state for \"Save\" functionality\n    const [localGeneral, setLocalGeneral] = useState<GeneralSettings>(generalSettings);\n    const [localSync, setLocalSync] = useState<SyncSettings>(syncSettings);\n    const [localClone, setLocalClone] = useState<CloneSettingsType>(cloneSettings);\n    const [localPackaging, setLocalPackaging] = useState<PackagingSettings>(packagingSettings);\n    const [localUploadDefaults, setLocalUploadDefaults] = useState<UploadDefaults>(uploadDefaults);\n\n    // Force remount of children when modal opens to reset their internal state\n    const [mountKey, setMountKey] = useState(0);\n\n    // Reset local state when modal opens\n    useEffect(() => {\n        if (isOpen) {\n            setLocalGeneral(generalSettings);\n            setLocalSync(syncSettings);\n            setLocalClone(cloneSettings);\n            setLocalPackaging(packagingSettings);\n            setLocalUploadDefaults(uploadDefaults);\n            setMountKey(prev => prev + 1);\n            document.body.style.overflow = 'hidden';\n        }\n        return () => {\n            document.body.style.overflow = 'unset';\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [isOpen]);\n\n    const handleClose = () => {\n        setIsClosing(true);\n        setTimeout(() => {\n            onClose();\n            setIsClosing(false);\n        }, 200);\n    };\n\n    // Extracted cleanup logic re-used by Save and Manual Cleanup\n    const cleanOrphanedCheckins = async (validRuleIds: Set<string>, silent = false) => {\n        if (!user || !currentChannel) return;\n\n        // Force fetch fresh data. \n        // We MUST do this because local 'videos' might be stale (e.g. if a check-in was just created by scheduler in background).\n        // Without this, we might write back a 'clean' history that unknowingly overwrites/ignores the new check-in, or fails to see it to remove it.\n        if (!silent && !user?.uid) return;\n\n        const freshVideos = await VideoService.fetchVideos(user.uid, currentChannel.id);\n\n        // Helper to check if a check-in is empty\n        const isCheckinEmpty = (checkin: any) => {\n            const m = checkin.metrics;\n            if (!m) return true;\n            return (m.impressions === null || m.impressions === undefined) &&\n                (m.ctr === null || m.ctr === undefined) &&\n                (m.views === null || m.views === undefined) &&\n                (m.avdSeconds === null || m.avdSeconds === undefined);\n        };\n\n        const notificationIdsToDelete: string[] = [];\n        const cleanupPromises: Promise<any>[] = [];\n\n        for (const video of freshVideos) {\n            if (!video.packagingHistory || video.packagingHistory.length === 0) continue;\n\n            // 1. Identify Duplicates across ALL versions\n            const allCheckins: { checkin: any, versionIndex: number }[] = [];\n            video.packagingHistory.forEach((v: any, vIdx: number) => {\n                v.checkins.forEach((c: any) => allCheckins.push({ checkin: c, versionIndex: vIdx }));\n            });\n\n            const checkinIdsToDelete = new Set<string>();\n\n            // Group by RuleId\n            const rulesMap = new Map<string, typeof allCheckins>();\n            allCheckins.forEach(item => {\n                if (!item.checkin.ruleId) return;\n                if (!rulesMap.has(item.checkin.ruleId)) rulesMap.set(item.checkin.ruleId, []);\n                rulesMap.get(item.checkin.ruleId)?.push(item);\n            });\n\n            // Resolve Duplicates\n            for (const [ruleId, items] of rulesMap) {\n                if (items.length > 1) {\n                    // Find best: has metrics?\n                    const withMetrics = items.filter(i => !isCheckinEmpty(i.checkin));\n\n                    let survivor;\n                    if (withMetrics.length > 0) {\n                        // Keep earliest with metrics\n                        withMetrics.sort((a, b) => a.checkin.date - b.checkin.date);\n                        survivor = withMetrics[0];\n                    } else {\n                        // Keep earliest overall\n                        items.sort((a, b) => a.checkin.date - b.checkin.date);\n                        survivor = items[0];\n                    }\n\n                    // Mark others for deletion\n                    items.forEach(i => {\n                        if (i.checkin.id !== survivor.checkin.id) {\n                            checkinIdsToDelete.add(i.checkin.id);\n                            if (!silent) console.log(`[Cleanup] Marking duplicate checkin for deletion: Video ${video.id}, Rule ${ruleId}, ID ${i.checkin.id}`);\n                        }\n                    });\n                }\n            }\n\n            let hasChanges = false;\n            const newHistory = video.packagingHistory.map((version: any) => {\n                const cleanedCheckins = version.checkins.filter((checkin: any) => {\n                    // If marked as duplicate, remove\n                    if (checkinIdsToDelete.has(checkin.id)) {\n                        hasChanges = true;\n                        return false;\n                    }\n\n                    // Manual check-ins (no ruleId) are always kept\n                    if (!checkin.ruleId) return true;\n\n                    // If rule exists in settings, keep it\n                    if (validRuleIds.has(checkin.ruleId)) return true;\n\n                    // Rule is MISSING from settings. Check if it's empty.\n                    const empty = isCheckinEmpty(checkin);\n\n                    // If it has data, keep it (safety)\n                    if (!empty) return true;\n\n                    // It is Orphaned AND Empty -> REMOVE\n                    if (checkin.ruleId) {\n                        notificationIdsToDelete.push(`checkin-due-${video.id}-${checkin.ruleId}`);\n                    }\n                    hasChanges = true;\n                    return false;\n                });\n                return { ...version, checkins: cleanedCheckins };\n            });\n\n            if (hasChanges) {\n                if (!silent) console.log('[Cleanup] Updating video history:', video.id);\n                // Use VideoService directly to update\n                cleanupPromises.push(\n                    VideoService.updateVideo(user.uid, currentChannel.id, video.id, { packagingHistory: newHistory })\n                        .then(() => {\n                            // Check updated\n                        })\n                );\n            }\n        }\n\n        await Promise.all(cleanupPromises);\n\n        if (notificationIdsToDelete.length > 0) {\n            try {\n                await NotificationService.removeNotifications(user.uid, currentChannel.id, notificationIdsToDelete);\n                if (!silent) console.log('[Cleanup] Removed notifications:', notificationIdsToDelete);\n            } catch (error) {\n                console.error('[Cleanup] Failed to remove notifications:', error);\n            }\n        }\n    };\n\n    // Cleanup when closing the modal (unmounting)\n    useEffect(() => {\n        return () => {\n            // We can't easily auto-run cleanup on unmount because we need 'validRuleIds' \n            // and we don't know if the user saved or cancelled.\n            // But the user asked for \"cleanup ... when closing\".\n            // If they saved, handleSave runs it.\n            // If they cancel, they might have added duplicates temporarily? No, those aren't saved.\n            // So implicit cleanup on unmount is only safe if we assume CURRENT settings are valid.\n            // But if they cancelled changes, current settings might NOT be what they wanted?\n            // ACTUALLY: The request \"cleanup when closing\" likely refers to ensuring no trash is left behind.\n            // Since we persist on Save, HandleSave is the right place. \n            // The user's issue was likely that it didn't run effectively.\n        };\n    }, []);\n\n    const handleManualCleanup = async () => {\n        if (!user || !currentChannel) return;\n        setIsSaving(true);\n        try {\n            // Use current LOCAL settings for validation\n            const validRuleIds = new Set(localPackaging.checkinRules.map(r => r.id));\n            await cleanOrphanedCheckins(validRuleIds, false);\n            alert('Cleanup process completed. Check console for details.');\n        } catch (error) {\n            console.error(\"Cleanup failed:\", error);\n            alert('Cleanup failed. See console.');\n        } finally {\n            setIsSaving(false);\n        }\n    };\n\n    const handleSave = async () => {\n        if (!user || !currentChannel) return;\n\n        setIsSaving(true);\n        try {\n            // Get the set of valid rule IDs that will exist after save\n            const validRuleIds = new Set(localPackaging.checkinRules.map(r => r.id));\n\n            // First update settings to ensure system state is consistent\n            await Promise.all([\n                updateGeneralSettings(user.uid, currentChannel.id, localGeneral),\n                updateSyncSettings(user.uid, currentChannel.id, localSync),\n                updateCloneSettings(user.uid, currentChannel.id, localClone),\n                updatePackagingSettings(user.uid, currentChannel.id, localPackaging),\n                updateUploadDefaults(user.uid, currentChannel.id, localUploadDefaults)\n            ]);\n\n            // Run cleanup AFTER saving settings to ensure no race conditions\n            // (e.g. scheduler seeing old rules while we clean up)\n            await cleanOrphanedCheckins(validRuleIds, true); // Silent mode for auto-save\n            handleClose();\n        } catch (error) {\n            console.error(\"Failed to save settings:\", error);\n        } finally {\n            setIsSaving(false);\n        }\n    };\n\n    // Validation for Packaging Rules\n    const hasPackagingDuplicates = (() => {\n        const hoursSeen = new Set<number>();\n        for (const rule of localPackaging.checkinRules) {\n            if (hoursSeen.has(rule.hoursAfterPublish)) return true;\n            hoursSeen.add(rule.hoursAfterPublish);\n        }\n        return false;\n    })();\n\n    const isDirty =\n        JSON.stringify(localGeneral) !== JSON.stringify(generalSettings) ||\n        JSON.stringify(localSync) !== JSON.stringify(syncSettings) ||\n        JSON.stringify(localClone) !== JSON.stringify(cloneSettings) ||\n        JSON.stringify(localClone) !== JSON.stringify(cloneSettings) ||\n        JSON.stringify(localPackaging) !== JSON.stringify(packagingSettings) ||\n        JSON.stringify(localUploadDefaults) !== JSON.stringify(uploadDefaults);\n\n    // Theme styles - Correctly detect dark mode including 'device' setting\n    const [isDark, setIsDark] = useState(false);\n\n    useEffect(() => {\n        const checkTheme = () => {\n            if (localGeneral.theme === 'device') {\n                setIsDark(window.matchMedia('(prefers-color-scheme: dark)').matches);\n            } else {\n                setIsDark(localGeneral.theme === 'dark');\n            }\n        };\n        checkTheme();\n        // Listen for system changes if in device mode\n        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n        const listener = () => {\n            if (localGeneral.theme === 'device') checkTheme();\n        };\n        mediaQuery.addEventListener('change', listener);\n        return () => mediaQuery.removeEventListener('change', listener);\n    }, [localGeneral.theme]);\n\n    const bgMain = 'bg-bg-secondary'; // Use theme variables\n    const textPrimary = 'text-text-primary';\n    const textSecondary = 'text-text-secondary';\n    const borderColor = 'border-border';\n\n    // Sidebar styles using new CSS variables\n    const hoverBg = 'hover:bg-[var(--settings-menu-hover)]';\n    const activeItemBg = 'bg-[var(--settings-menu-active)]';\n    const activeItemText = 'text-text-primary';\n\n    if (!isOpen && !isClosing) return null;\n\n    return createPortal(\n        <div\n            className={`fixed inset-0 z-[9999] flex items-center justify-center p-4 backdrop-blur-sm ${isClosing ? 'animate-fade-out' : 'animate-fade-in'}`}\n            style={{ backgroundColor: 'var(--modal-overlay)' }}\n            onClick={handleClose}\n        >\n            <div\n                className={`relative w-full max-w-[960px] h-[618px] ${bgMain} rounded-xl shadow-2xl flex flex-col overflow-hidden ${isClosing ? 'animate-scale-out' : 'animate-scale-in'} transition-colors duration-200`}\n                onClick={e => e.stopPropagation()}\n            >\n                {/* Header */}\n                <div className={`px-6 h-[63px] flex items-center border-b ${borderColor}`}>\n                    <h2 className={`text-xl font-medium ${textPrimary}`}>Settings</h2>\n                </div>\n\n                {/* Body */}\n                <div className=\"flex-1 flex min-h-0 h-[488px]\">\n                    {/* Sidebar */}\n                    <SettingsSidebar\n                        activeCategory={activeCategory}\n                        onCategoryChange={(c) => setActiveCategory(c as Category)}\n                        theme={{ isDark, textSecondary, hoverBg, activeItemBg, activeItemText, borderColor, bgMain }}\n                    />\n\n                    {/* Content */}\n                    <div className={`flex-1 overflow-y-auto p-6 ${textPrimary}`}>\n                        {activeCategory === 'api_sync' && (\n                            <ApiSyncSettings\n                                key={mountKey}\n                                generalSettings={localGeneral}\n                                syncSettings={localSync}\n                                onGeneralChange={setLocalGeneral}\n                                onSyncChange={setLocalSync}\n                                theme={{ isDark, borderColor, textSecondary, bgMain, textPrimary }}\n                            />\n                        )}\n                        {activeCategory === 'clone' && (\n                            <CloneSettings\n                                key={mountKey}\n                                settings={localClone}\n                                onChange={setLocalClone}\n                                theme={{ isDark, borderColor, textSecondary, bgMain, textPrimary }}\n                            />\n                        )}\n                        {activeCategory === 'packaging' && (\n                            <PackagingSettingsView\n                                key={mountKey}\n                                settings={localPackaging}\n                                onChange={setLocalPackaging}\n                                onCleanup={handleManualCleanup}\n                            />\n                        )}\n                        {activeCategory === 'upload_defaults' && (\n                            <UploadDefaultsSettings\n                                key={mountKey}\n                                settings={localUploadDefaults}\n                                onChange={setLocalUploadDefaults}\n                            />\n                        )}\n                    </div>\n                </div>\n\n                {/* Footer */}\n                <div className={`px-4 h-[67px] border-t ${borderColor} flex items-center justify-end gap-2 ${bgMain}`}>\n                    <button\n                        onClick={handleClose}\n                        className={`px-4 py-2 rounded-2xl text-sm font-medium ${textPrimary} ${hoverBg} transition-colors cursor-pointer`}\n                    >\n                        Close\n                    </button>\n                    <button\n                        onClick={handleSave}\n                        disabled={!isDirty || isSaving || hasPackagingDuplicates}\n                        className={`px-6 py-2 rounded-2xl text-sm font-medium transition-all relative overflow-hidden\n                            ${(isDirty && !hasPackagingDuplicates)\n                                ? 'bg-[var(--primary-button-bg)] text-[var(--primary-button-text)] hover:bg-[var(--primary-button-hover)] cursor-pointer'\n                                : 'bg-bg-primary text-text-secondary cursor-default opacity-50'\n                            }\n                            ${isSaving ? 'cursor-wait' : ''}`}\n                    >\n                        {isSaving && isDirty && (\n                            <div className=\"absolute inset-0 bg-gradient-to-r from-transparent via-black/10 to-transparent animate-shimmer bg-[length:200%_100%]\"></div>\n                        )}\n                        <span className=\"relative z-10\">Save</span>\n                    </button>\n                </div>\n            </div>\n        </div>,\n        document.body\n    );\n};\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/SettingsSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Settings/UploadDefaultsSettings.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[454,457],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[454,457],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport type { UploadDefaults } from '../../core/services/settingsService';\nimport { TagsInput } from '../../components/ui/TagsInput';\n\ninterface UploadDefaultsSettingsProps {\n    settings: UploadDefaults;\n    onChange: (settings: UploadDefaults) => void;\n}\n\nexport const UploadDefaultsSettings: React.FC<UploadDefaultsSettingsProps> = ({ settings, onChange }) => {\n    const handleChange = (field: keyof UploadDefaults, value: any) => {\n        onChange({\n            ...settings,\n            [field]: value\n        });\n    };\n\n    const handleTagsChange = (newTags: string[]) => {\n        handleChange('tags', newTags);\n    };\n\n    return (\n        <div className=\"space-y-6\">\n            <div>\n                <h3 className=\"text-lg font-medium mb-1\">Upload Defaults</h3>\n                <p className=\"text-sm text-text-secondary mb-4\">\n                    These settings will be applied to all new custom videos you create.\n                </p>\n            </div>\n\n            <div className=\"space-y-4\">\n                {/* Title */}\n                <div>\n                    <label className=\"block text-sm font-medium text-text-secondary mb-1\">\n                        Default Title\n                    </label>\n                    <input\n                        type=\"text\"\n                        value={settings.title || ''}\n                        onChange={(e) => handleChange('title', e.target.value)}\n                        placeholder=\"Enter default title...\"\n                        className=\"w-full px-3 py-2 bg-bg-secondary border border-border rounded-lg text-text-primary focus:outline-none focus:border-blue-500 transition-colors\"\n                    />\n                </div>\n\n                {/* Description */}\n                <div>\n                    <label className=\"block text-sm font-medium text-text-secondary mb-1\">\n                        Default Description\n                    </label>\n                    <textarea\n                        value={settings.description || ''}\n                        onChange={(e) => handleChange('description', e.target.value)}\n                        placeholder=\"Enter default description...\"\n                        rows={4}\n                        className=\"w-full px-3 py-2 bg-bg-secondary border border-border rounded-lg text-text-primary focus:outline-none focus:border-blue-500 transition-colors resize-none\"\n                    />\n                </div>\n\n                {/* Tags */}\n                <div>\n                    <TagsInput\n                        tags={settings.tags || []}\n                        onChange={handleTagsChange}\n                    />\n                </div>\n            </div>\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/CategoryBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/ClonedVideoTooltipContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/FilterDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/LanguageTabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/Modals/AddCustomVideo/AddCustomVideoModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/Modals/AddCustomVideo/components/SaveMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/Modals/AddCustomVideo/components/VideoForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/Modals/AddCustomVideo/hooks/useAddCustomVideo.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'setAbTestVariants' and 'setCoverImage'. Either include them or remove the dependency array.","line":152,"column":8,"nodeType":"ArrayExpression","endLine":152,"endColumn":24,"suggestions":[{"desc":"Update the dependencies array to be: [abTestVariants, setAbTestVariants, setCoverImage]","fix":{"range":[5188,5204],"text":"[abTestVariants, setAbTestVariants, setCoverImage]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setDuration'. Either include it or remove the dependency array.","line":163,"column":8,"nodeType":"ArrayExpression","endLine":163,"endColumn":59,"suggestions":[{"desc":"Update the dependencies array to be: [publishedUrl, isPublished, generalSettings.apiKey, setDuration]","fix":{"range":[5608,5659],"text":"[publishedUrl, isPublished, generalSettings.apiKey, setDuration]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setIsDraft'. Either include it or remove the dependency array.","line":224,"column":8,"nodeType":"ArrayExpression","endLine":227,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [isOpen, packagingHistory, title, description, tags, coverImage, abTestVariants, localizations, isDraft, activeLanguage, defaultData, setIsDraft]","fix":{"range":[8209,8364],"text":"[isOpen, packagingHistory, title, description, tags, coverImage, abTestVariants, localizations, isDraft, activeLanguage, defaultData, setIsDraft]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":359,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":359,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":547,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":547,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23672,23675],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23672,23675],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef } from 'react';\nimport { useAuth } from '../../../../../core/hooks/useAuth';\nimport { useChannelStore } from '../../../../../core/stores/channelStore';\nimport { useSettings } from '../../../../../core/hooks/useSettings';\nimport { useVideos } from '../../../../../core/hooks/useVideos';\nimport { useVideoForm } from '../../../../../core/hooks/useVideoForm';\nimport { uploadImageToStorage, uploadBase64ToStorage } from '../../../../../core/services/storageService';\nimport { resizeImageToBlob } from '../../../../../core/utils/imageUtils';\nimport {\n    type VideoDetails,\n    type CoverVersion,\n    type PackagingVersion,\n    type HistoryItem,\n    fetchVideoDetails,\n    extractVideoId\n} from '../../../../../core/utils/youtubeApi';\nimport { useABTesting, type ABTestingSaveData } from '../../../../../components/Shared/ABTesting';\n\nexport interface UseAddCustomVideoProps {\n    isOpen: boolean;\n    onClose: () => void;\n    onSave: (videoData: Omit<VideoDetails, 'id'>, shouldClose?: boolean, expectedRevision?: number) => Promise<string | void>;\n    onClone?: (originalVideo: VideoDetails, version: CoverVersion) => Promise<void>;\n    initialData?: VideoDetails;\n    initialTab?: 'details';\n}\n\nexport function useAddCustomVideo({\n    isOpen,\n    onClose,\n    onSave,\n    onClone,\n    initialData,\n    initialTab = 'details'\n}: UseAddCustomVideoProps) {\n    const { user } = useAuth();\n    const { currentChannel, updateChannel } = useChannelStore();\n    const { generalSettings } = useSettings();\n    const { saveVideoHistory, deleteVideoHistoryItem } = useVideos(user?.uid || '', currentChannel?.id || '');\n\n    const modalRef = useRef<HTMLDivElement>(null);\n    const lastUploadTimeRef = useRef<number>(0);\n    const activeUploadPromiseRef = useRef<Promise<string | void> | null>(null);\n\n    // Draft State\n    const [draftId] = useState(() => initialData?.id || `custom-${Date.now()}`);\n\n    // UI State\n    const [activeTab, setActiveTab] = useState<'details'>(initialTab || 'details');\n    const [isStatsExpanded, setIsStatsExpanded] = useState(false);\n    const [isSaving, setIsSaving] = useState(false);\n    const [cloningVersion, setCloningVersion] = useState<number | null>(null);\n\n    // Delete Confirmation\n    const [deleteConfirmation, setDeleteConfirmation] = useState<{ isOpen: boolean; versionNumber: number | null }>({\n        isOpen: false,\n        versionNumber: null\n    });\n\n    // Toast State\n    const [toastMessage, setToastMessage] = useState('');\n    const [showToast, setShowToast] = useState(false);\n    const [toastType, setToastType] = useState<'success' | 'error'>('success');\n    const [toastPosition, setToastPosition] = useState<'top' | 'bottom'>('bottom');\n\n    // Form State (from useVideoForm)\n    const videoForm = useVideoForm(initialData, isOpen);\n    const {\n        title,\n        description,\n        tags,\n        viewCount,\n        duration, setDuration,\n        coverImage, setCoverImage,\n        currentVersion, setCurrentVersion,\n        highestVersion, setHighestVersion,\n        currentOriginalName, setCurrentOriginalName,\n        fileVersionMap, setFileVersionMap,\n        coverHistory, setCoverHistory,\n        deletedHistoryIds, setDeletedHistoryIds,\n        isPackagingDirty,\n        isDraft, setIsDraft,\n        isPublished,\n        publishedUrl,\n        activeLanguage,\n        localizations,\n        addLanguage,\n        defaultData,\n        getFullPayload,\n        abTestVariants,\n        setAbTestVariants,\n        abTestTitles,\n        setAbTestTitles,\n        currentPackagingVersion,\n        setCurrentPackagingVersion,\n        packagingHistory,\n        setPackagingHistory\n    } = videoForm;\n\n    // A/B Testing\n    const {\n        isOpen: isABModalOpen,\n        openModal: openABModal,\n        closeModal: closeABModal,\n        handleSave: handleABTestSaveInternal,\n        activeMode: activeABTab\n    } = useABTesting({\n        mode: 'both', // Initial dummy mode\n        titles: abTestTitles,\n        thumbnails: abTestVariants,\n        currentTitle: title, // Use form title as base\n        currentThumbnail: coverImage || '',\n        onSave: (data) => {\n            // Update local state\n            setAbTestTitles(data.titles);\n            setAbTestVariants(data.thumbnails);\n        },\n        onResultsSave: async () => {\n            // No-op for now in creation flow\n        }\n    });\n\n    const handleOpenTitleABTest = () => {\n        openABModal('title');\n    };\n\n    const handleOpenThumbnailABTest = () => {\n        openABModal('thumbnail');\n    };\n\n    const handleABTestSave = (data: ABTestingSaveData) => {\n        handleABTestSaveInternal(data);\n        closeABModal();\n    };\n\n    // Derived dirty state for SaveMenu\n    const isEffectivePackagingDirty = isPackagingDirty && isDraft;\n\n    // Reset state on initialTab change\n    useEffect(() => {\n        // Logic from original component if needed, formerly empty\n    }, [initialTab]);\n\n    // Pending Restore Effect (Removed)\n\n    // Sole Survivor Logic\n    useEffect(() => {\n        if (abTestVariants.length === 1) {\n            setCoverImage(abTestVariants[0]);\n            setAbTestVariants([]);\n        }\n    }, [abTestVariants]);\n\n    // Auto-sync Duration\n    useEffect(() => {\n        if (!isPublished) return;\n        const videoId = extractVideoId(publishedUrl);\n        if (videoId && generalSettings.apiKey) {\n            fetchVideoDetails(videoId, generalSettings.apiKey).then(details => {\n                if (details && details.duration) setDuration(details.duration);\n            }).catch(console.error);\n        }\n    }, [publishedUrl, isPublished, generalSettings.apiKey]);\n\n    // Strict Sync Logic (Simplified - removed tab switching)\n    useEffect(() => {\n        if (!isOpen) return;\n\n        if (packagingHistory.length === 0) {\n            if (!isDraft) setIsDraft(true);\n            return;\n        }\n\n        const maxVersion = Math.max(...packagingHistory.map(v => v.versionNumber));\n        const latestVersion = packagingHistory.find(v => v.versionNumber === maxVersion);\n\n        if (!latestVersion) return;\n\n        const snapshot = latestVersion.configurationSnapshot;\n\n        let effectiveDefaultTitle = title;\n        let effectiveDefaultDescription = description;\n        let effectiveDefaultTags = tags;\n        const effectiveLocalizations = { ...localizations };\n\n        if (activeLanguage !== 'default') {\n            effectiveDefaultTitle = defaultData.title;\n            effectiveDefaultDescription = defaultData.description;\n            effectiveDefaultTags = defaultData.tags;\n            effectiveLocalizations[activeLanguage] = {\n                languageCode: activeLanguage,\n                title: title,\n                description: description,\n                tags: tags\n            };\n        }\n\n        const isContentIdentical = (() => {\n            if (!snapshot) return false;\n            if (effectiveDefaultTitle !== snapshot.title) return false;\n            if ((effectiveDefaultDescription || '') !== (snapshot.description || '')) return false;\n            if (JSON.stringify(effectiveDefaultTags || []) !== JSON.stringify(snapshot.tags || [])) return false;\n            if ((coverImage || '') !== (snapshot.coverImage || '')) return false;\n            if (JSON.stringify(abTestVariants || []) !== JSON.stringify(snapshot.abTestVariants || [])) return false;\n\n            const snapLocs = snapshot.localizations || {};\n            const allLocKeys = new Set([...Object.keys(effectiveLocalizations), ...Object.keys(snapLocs)]);\n            for (const key of allLocKeys) {\n                const currentLoc = effectiveLocalizations[key];\n                const snapLoc = snapLocs[key];\n                if (!currentLoc || !snapLoc) return false;\n                if (currentLoc.title !== snapLoc.title ||\n                    currentLoc.description !== snapLoc.description ||\n                    JSON.stringify(currentLoc.tags) !== JSON.stringify(snapLoc.tags)) return false;\n            }\n            return true;\n        })();\n\n        if (isContentIdentical) {\n            if (isDraft) setIsDraft(false);\n        } else {\n            if (!isDraft) setIsDraft(true);\n        }\n    }, [\n        isOpen, packagingHistory, title, description, tags, coverImage,\n        abTestVariants, localizations, isDraft, activeLanguage, defaultData\n    ]);\n\n    // Body Overflow Effect\n    useEffect(() => {\n        if (isOpen) {\n            document.body.style.overflow = 'hidden';\n        } else {\n            document.body.style.overflow = 'unset';\n        }\n        return () => {\n            document.body.style.overflow = 'unset';\n        };\n    }, [isOpen]);\n\n    // Handlers\n    const handleBackdropClick = (e: React.MouseEvent) => {\n        if (modalRef.current && !modalRef.current.contains(e.target as Node)) {\n            handleClose();\n        }\n    };\n\n    const handleAddLanguage = async (code: string, customName?: string, customFlag?: string) => {\n        addLanguage(code, customName, customFlag);\n        if (customName && customFlag && currentChannel && user) {\n            const existingLanguages = currentChannel.customLanguages || [];\n            const exists = existingLanguages.some(l => l.code === code);\n            if (!exists) {\n                const newLang = { code, name: customName, flag: customFlag };\n                try {\n                    await updateChannel(user.uid, currentChannel.id, {\n                        customLanguages: [...existingLanguages, newLang]\n                    });\n                } catch (error) {\n                    console.error('Failed to save custom language to channel:', error);\n                }\n            }\n        }\n    };\n\n    const handleDeleteCustomLanguage = async (code: string) => {\n        if (currentChannel && user) {\n            const existingLanguages = currentChannel.customLanguages || [];\n            const updatedLanguages = existingLanguages.filter(l => l.code !== code);\n            try {\n                await updateChannel(user.uid, currentChannel.id, {\n                    customLanguages: updatedLanguages\n                });\n            } catch (error) {\n                console.error('Failed to remove custom language from channel:', error);\n            }\n        }\n    };\n\n    const handleImageUpload = async (file: File) => {\n        if (!file.type.startsWith('image/')) {\n            throw new Error('Invalid file type');\n        }\n\n        const currentUploadTime = Date.now();\n        lastUploadTimeRef.current = currentUploadTime;\n\n        const performUpload = async () => {\n            try {\n                const userId = user?.uid || 'anonymous';\n                const videoId = initialData?.id || draftId;\n\n                const fileKey = `${file.name.replace(/\\./g, '_')} -${file.size} `;\n                let newVersion: number;\n                if (fileVersionMap[fileKey]) {\n                    newVersion = fileVersionMap[fileKey];\n                } else {\n                    newVersion = highestVersion + 1;\n                    setFileVersionMap(prev => ({ ...prev, [fileKey]: newVersion }));\n                    setHighestVersion(newVersion);\n                }\n                setCurrentVersion(newVersion);\n                setCurrentOriginalName(file.name);\n\n                setToastMessage('Uploading image...');\n                setToastType('success');\n                setShowToast(true);\n\n                const blob = await resizeImageToBlob(file, 1280, 0.7);\n                const timestamp = Date.now();\n                const path = `users/${userId}/channels/${currentChannel?.id}/videos/${videoId}/${timestamp}_${file.name}`;\n                const downloadURL = await uploadImageToStorage(blob, path);\n\n                if (lastUploadTimeRef.current === currentUploadTime) {\n                    setCoverImage(downloadURL);\n                    setToastType('success');\n                    setToastMessage('Image uploaded successfully!');\n                    setTimeout(() => setShowToast(false), 2000);\n                }\n                return downloadURL;\n            } catch (error) {\n                console.error('Error uploading image:', error);\n                setToastMessage('Failed to upload image');\n                setToastType('error');\n                setShowToast(true);\n                throw error;\n            } finally {\n                if (lastUploadTimeRef.current === currentUploadTime) {\n                    activeUploadPromiseRef.current = null;\n                }\n            }\n        };\n\n        const uploadPromise = performUpload();\n        activeUploadPromiseRef.current = uploadPromise;\n        return uploadPromise as Promise<string>;\n    };\n\n    const handleDeleteHistoryItem = async (timestamp: number) => {\n        setCoverHistory(prev => prev.filter(h => h.timestamp !== timestamp));\n        setDeletedHistoryIds(prev => new Set(prev).add(timestamp));\n    };\n\n    const handleSave = async (shouldClose = true, overrideIsDraft?: boolean, overrides?: { overridePackagingVersion?: number, overridePackagingHistory?: PackagingVersion[] }): Promise<string | undefined> => {\n        if (!coverImage) {\n            alert(\"Please upload a cover image\");\n            return undefined;\n        }\n\n        let effectiveCoverImage = coverImage;\n\n        if (activeUploadPromiseRef.current) {\n            setIsSaving(true);\n            try {\n                const uploadedUrl = await activeUploadPromiseRef.current;\n                if (uploadedUrl && typeof uploadedUrl === 'string') {\n                    effectiveCoverImage = uploadedUrl;\n                }\n            } catch (e) {\n                setIsSaving(false);\n                return undefined;\n            }\n        } else if (coverImage.startsWith('blob:')) {\n            setToastMessage(\"Please wait for image upload to complete\");\n            setToastType('error');\n            setShowToast(true);\n            return undefined;\n        } else if (coverImage.startsWith('data:image')) {\n            try {\n                const userId = user?.uid || 'anonymous';\n                const uploadedUrl = await uploadBase64ToStorage(coverImage, userId);\n                effectiveCoverImage = uploadedUrl;\n                setCoverImage(uploadedUrl);\n            } catch (e) {\n                console.error(\"Failed to upload base64 cover image:\", e);\n                setToastMessage(\"Failed to save cover image.\");\n                setToastType('error');\n                setShowToast(true);\n                setIsSaving(false);\n                return undefined;\n            }\n        }\n\n        setIsSaving(true);\n\n        try {\n            // 1. Migrate Legacy Base64 Images in History\n            const updatedCoverHistory = [...coverHistory];\n            let hasHistoryUpdates = false;\n\n            const coverHistoryPromises = updatedCoverHistory.map(async (item, index) => {\n                if (item.url.startsWith('data:image')) {\n                    const newUrl = await uploadBase64ToStorage(item.url, user?.uid || 'anonymous');\n                    updatedCoverHistory[index] = { ...item, url: newUrl };\n                    hasHistoryUpdates = true;\n                }\n            });\n            await Promise.all(coverHistoryPromises);\n            if (hasHistoryUpdates) setCoverHistory(updatedCoverHistory);\n\n            // 2. Migrate Legacy Base64 Images in Packaging History & Upload new A/B variants\n            let effectivePackagingHistory = overrides?.overridePackagingHistory ?? packagingHistory;\n            const effectiveOverriddenHistory = overrides?.overridePackagingHistory; // Keep ref to verify if used\n            let hasPackagingUpdates = false;\n            effectivePackagingHistory = JSON.parse(JSON.stringify(effectivePackagingHistory));\n\n            const packagingPromises = effectivePackagingHistory.map(async (version, index) => {\n                if (!version.configurationSnapshot) return;\n\n                // Upload cover image if base64\n                if (version.configurationSnapshot.coverImage?.startsWith('data:image')) {\n                    const newUrl = await uploadBase64ToStorage(version.configurationSnapshot.coverImage, user?.uid || 'anonymous');\n                    if (effectivePackagingHistory[index]?.configurationSnapshot) {\n                        effectivePackagingHistory[index].configurationSnapshot!.coverImage = newUrl;\n                    }\n                    hasPackagingUpdates = true;\n                }\n\n                // Upload A/B test variants (blob: or data:image)\n                if (version.configurationSnapshot.abTestVariants?.some(v => v.startsWith('blob:') || v.startsWith('data:image'))) {\n                    const variantPromises = (version.configurationSnapshot.abTestVariants || []).map(async (variant) => {\n                        if (variant) {\n                            if (variant.startsWith('blob:')) {\n                                try {\n                                    const blob = await fetch(variant).then(r => r.blob());\n                                    const timestamp = Date.now();\n                                    const randomId = Math.random().toString(36).substring(7);\n                                    const path = `covers/${user?.uid || 'anonymous'}/abtest_${timestamp}_${randomId}.jpg`;\n                                    return await uploadImageToStorage(blob, path);\n                                } catch (e) {\n                                    console.error('Failed to upload blob variant:', e);\n                                    return variant;\n                                }\n                            } else if (variant.startsWith('data:image')) {\n                                return await uploadBase64ToStorage(variant, user?.uid || 'anonymous');\n                            }\n                        }\n                        return variant;\n                    });\n                    const newVariants = await Promise.all(variantPromises);\n                    if (effectivePackagingHistory[index]?.configurationSnapshot) {\n                        effectivePackagingHistory[index].configurationSnapshot.abTestVariants = newVariants;\n                    }\n                    hasPackagingUpdates = true;\n                }\n            });\n            await Promise.all(packagingPromises);\n\n            if (hasPackagingUpdates && !effectiveOverriddenHistory) {\n                setPackagingHistory(effectivePackagingHistory);\n            }\n\n            // 3. Upload current A/B test variants (blob: or data:image)\n            let effectiveAbTestVariants = [...abTestVariants];\n            if (effectiveAbTestVariants.some(v => v.startsWith('blob:') || v.startsWith('data:image'))) {\n                const variantPromises = effectiveAbTestVariants.map(async (variant) => {\n                    if (variant) {\n                        if (variant.startsWith('blob:')) {\n                            try {\n                                const blob = await fetch(variant).then(r => r.blob());\n                                const timestamp = Date.now();\n                                const randomId = Math.random().toString(36).substring(7);\n                                const path = `covers/${user?.uid || 'anonymous'}/abtest_${timestamp}_${randomId}.jpg`;\n                                return await uploadImageToStorage(blob, path);\n                            } catch (e) {\n                                console.error('Failed to upload blob variant:', e);\n                                return variant;\n                            }\n                        } else if (variant.startsWith('data:image')) {\n                            return await uploadBase64ToStorage(variant, user?.uid || 'anonymous');\n                        }\n                    }\n                    return variant;\n                });\n                effectiveAbTestVariants = await Promise.all(variantPromises);\n                setAbTestVariants(effectiveAbTestVariants);\n            }\n\n            const finalData = getFullPayload();\n            const finalTitle = finalData.title.trim() || \"Your Next Viral Music Playlist\";\n            const effectivePackagingVersion = overrides?.overridePackagingVersion ?? currentPackagingVersion;\n\n            const videoData: Omit<VideoDetails, 'id'> & { id?: string } = {\n                id: initialData?.id,\n                title: finalTitle.trim(),\n                description: finalData.description || '',\n                tags: finalData.tags || [],\n                thumbnail: effectiveCoverImage,\n                channelId: currentChannel?.id || '',\n                channelTitle: currentChannel?.name || 'My Channel',\n                channelAvatar: currentChannel?.avatar || '',\n                publishedAt: (initialData && initialData.publishedAt) ? initialData.publishedAt : new Date().toISOString(),\n                viewCount: finalData.viewCount,\n                duration: finalData.duration || '1:02:11',\n                isCustom: true,\n                customImage: effectiveCoverImage,\n                createdAt: initialData?.createdAt,\n                coverHistory: updatedCoverHistory,\n                customImageName: currentOriginalName || undefined,\n                customImageVersion: currentVersion,\n                highestVersion: highestVersion,\n                fileVersionMap: fileVersionMap,\n                historyCount: updatedCoverHistory.length,\n                publishedVideoId: finalData.publishedVideoId,\n                videoRender: finalData.videoRender,\n                audioRender: finalData.audioRender,\n                isDraft: overrideIsDraft !== undefined ? overrideIsDraft : (shouldClose ? isDraft : true),\n                currentPackagingVersion: effectivePackagingVersion,\n                packagingHistory: effectivePackagingHistory,\n                // Set activeVersion based on whether we're saving as a version or draft\n                activeVersion: (overrideIsDraft === false && effectivePackagingHistory.length > 0)\n                    ? effectivePackagingHistory[effectivePackagingHistory.length - 1].versionNumber\n                    : 'draft',\n                abTestTitles: abTestTitles,\n                abTestThumbnails: effectiveAbTestVariants,\n                abTestResults: { titles: [], thumbnails: [] } // Initialize empty results for new tests\n            };\n\n            console.log('[useAddCustomVideo] Preparing videoData:', {\n                title: videoData.title,\n                isDraft: videoData.isDraft,\n                activeVersion: videoData.activeVersion,\n                historyCount: videoData.packagingHistory?.length,\n                overrideIsDraft,\n                shouldClose\n            });\n\n            const expectedRevision = initialData?.packagingRevision;\n            const newId = await onSave(videoData, shouldClose, expectedRevision);\n            const targetId = (typeof newId === 'string' ? newId : initialData?.id);\n\n            if (targetId && user && currentChannel) {\n                const deletePromises = Array.from(deletedHistoryIds).map(timestamp =>\n                    deleteVideoHistoryItem({ videoId: targetId, historyId: timestamp.toString() })\n                );\n                await Promise.all(deletePromises);\n                const savePromises = updatedCoverHistory.map(item => saveVideoHistory({ videoId: targetId, historyItem: item as unknown as HistoryItem }));\n                await Promise.all(savePromises);\n            }\n\n            if (shouldClose) {\n                onClose();\n            } else {\n                setIsDraft(true);\n            }\n            return targetId;\n        } catch (error: any) {\n            console.error(\"Failed to save video:\", error);\n            if (error.message && error.message.includes('exceeds the maximum allowed size')) {\n                setToastMessage(\"File too large! The cover image is too big for the database. Please try a smaller image.\");\n            } else {\n                setToastMessage(\"Failed to save video.\");\n            }\n            setToastType('error');\n            setShowToast(true);\n            return undefined;\n        } finally {\n            setIsSaving(false);\n        }\n    };\n\n    const handleClose = async () => {\n        onClose();\n    };\n\n    const handleCloneWithSave = async (version: CoverVersion) => {\n        if (!onClone) return;\n        setCloningVersion(version.version);\n        try {\n            const savedId = await handleSave(false);\n            if (!savedId) {\n                console.error(\"Failed to save video before cloning\");\n                return;\n            }\n            const videoToClone: VideoDetails = initialData ? { ...initialData, id: savedId } : {\n                id: savedId,\n                title: title,\n                description: description,\n                tags: tags,\n                publishedAt: new Date().toISOString(),\n                createdAt: Date.now(),\n                channelId: currentChannel?.id || '',\n                channelTitle: currentChannel?.name || '',\n                channelAvatar: currentChannel?.avatar || '',\n                viewCount: viewCount,\n                duration: duration,\n                isCustom: true,\n                thumbnail: coverImage || '',\n                customImage: coverImage || '',\n                customImageVersion: currentVersion,\n                historyCount: coverHistory.length,\n                coverHistory: coverHistory\n            };\n            await onClone(videoToClone, version);\n            onClose();\n        } finally {\n            setCloningVersion(null);\n        }\n    };\n\n    const handleSaveAsVersion = () => {\n        const finalData = getFullPayload();\n        let snapshotTitle = finalData.title.trim() || \"Your Next Viral Music Playlist\";\n        let snapshotDescription = finalData.description || '';\n        let snapshotTags = finalData.tags || [];\n\n        if (activeLanguage !== 'default') {\n            // If we're on a localization, we still want to save the snapshot\n            // but we need to decide what goes into the \"main\" config snapshot.\n            // Usually, main snapshot refers to the default language.\n            snapshotTitle = defaultData.title.trim() || \"Your Next Viral Music Playlist\";\n            snapshotDescription = defaultData.description || '';\n            snapshotTags = defaultData.tags || [];\n        }\n\n        console.log('[useAddCustomVideo] handleSaveAsVersion called', {\n            currentPackagingVersion,\n            packagingHistoryCount: packagingHistory.length,\n            activeLanguage,\n            snapshotTitle\n        });\n\n        const newHistoryItem: PackagingVersion = {\n            versionNumber: currentPackagingVersion,\n            startDate: Date.now(),\n            endDate: null,\n            checkins: [],\n            configurationSnapshot: {\n                title: snapshotTitle,\n                description: snapshotDescription,\n                tags: snapshotTags,\n                coverImage: coverImage || '',\n                abTestTitles: abTestTitles,\n                abTestThumbnails: abTestVariants,\n                abTestVariants: abTestVariants, // Backward compatibility\n                localizations: localizations\n            },\n            revision: 1\n        };\n\n        const newHistory = [...packagingHistory, newHistoryItem];\n        const newVersion = currentPackagingVersion + 1;\n\n        console.log('[useAddCustomVideo] New history created:', {\n            newHistoryCount: newHistory.length,\n            newVersion\n        });\n\n        setPackagingHistory(newHistory);\n        setCurrentPackagingVersion(newVersion);\n        setIsDraft(false);\n\n        handleSave(true, false, {\n            overridePackagingVersion: newVersion,\n            overridePackagingHistory: newHistory\n        });\n    };\n\n    return {\n        // State\n        modalRef,\n        activeTab, setActiveTab,\n        isStatsExpanded, setIsStatsExpanded,\n        isSaving,\n        cloningVersion,\n        deleteConfirmation,\n        toastMessage, showToast, setShowToast, toastType, toastPosition,\n        draftId,\n        isEffectivePackagingDirty,\n        currentChannel, // Exported for language list\n\n        // Form State & Setters (Spread from useVideoForm)\n        ...videoForm,\n\n        // Handlers\n        handleBackdropClick,\n        handleClose,\n        handleSave,\n        handleImageUpload,\n        handleDeleteHistoryItem,\n        handleCloneWithSave,\n        handleSaveAsVersion,\n        setToastMessage, setToastType, setToastPosition,\n        setDeleteConfirmation, // Used by confirmation modal state if needed, though simpler now\n\n        // A/B Test Exports\n        abTestVariants,\n        abTestTitles,\n        isABModalOpen,\n        handleCloseABModal: closeABModal,\n        handleOpenTitleABTest,\n        handleOpenThumbnailABTest,\n        handleABTestSave,\n        activeABTab,\n        abTestResults: undefined, // Or pass from initialData if available for edit mode\n\n        // Custom Language Handlers\n        handleAddLanguage,\n        handleDeleteCustomLanguage\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/Modals/AddYouTubeVideoModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/SortableVideoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/VideoCard.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[552,555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[552,555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1990,1993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1990,1993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { render, screen, fireEvent } from '@testing-library/react';\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { VideoCard } from './VideoCard';\nimport { BrowserRouter } from 'react-router-dom';\n\n// 1.   ,   VideoCard\n//  ,     -   (API, Auth, Stores)\nvi.mock('../../core/hooks/useAuth', () => ({\n    useAuth: () => ({ user: { uid: 'test-user' } })\n}));\n\nvi.mock('../../core/stores/channelStore', () => ({\n    useChannelStore: (selector: any) => selector({ currentChannel: { id: 'test-channel' } })\n}));\n\nvi.mock('../../core/stores/uiStore', () => ({\n    useUIStore: () => ({\n        videoViewModes: {},\n        setVideoViewMode: vi.fn(),\n        setSettingsOpen: vi.fn()\n    })\n}));\n\nvi.mock('../../core/hooks/useSettings', () => ({\n    useSettings: () => ({ generalSettings: { apiKey: 'test-api-key' } })\n}));\n\n//    ,       \nvi.mock('../../core/hooks/useVideoSync', () => ({ useVideoSync: () => ({ syncVideo: vi.fn() }) }));\nvi.mock('../../core/hooks/usePlaylists', () => ({ usePlaylists: () => ({ removeVideosFromPlaylist: vi.fn() }) }));\nvi.mock('../../core/hooks/useThumbnailActions', () => ({ useThumbnailActions: () => ({ handleLikeThumbnail: vi.fn(), handleRemoveThumbnail: vi.fn() }) }));\n\ndescribe('VideoCard', () => {\n    const mockVideo = {\n        id: 'video-123',\n        title: ' ',\n        thumbnail: 'test.jpg',\n        channelId: 'ch1',\n        channelTitle: 'Test Channel',\n        channelAvatar: 'avatar.jpg',\n        publishedAt: new Date().toISOString(),\n        viewCount: '1000'\n    };\n\n    const mockOnRemove = vi.fn();\n\n    beforeEach(() => {\n        vi.clearAllMocks();\n    });\n\n    it('  onRemove     ', async () => {\n        //   \n        render(\n            <BrowserRouter>\n                <VideoCard video={mockVideo as any} onRemove={mockOnRemove} />\n            </BrowserRouter>\n        );\n\n        // 1.   \" \" (More)    \n        //       MoreVertical\n        const moreButton = screen.getByRole('button', { name: '' }); //  \n        fireEvent.click(moreButton);\n\n        // 2.   \"Delete\"     \n        const deleteOption = screen.getByText('Delete');\n        fireEvent.click(deleteOption);\n\n        // 3.     \n        expect(screen.getByText('Are you sure you want to delete this video?')).toBeInTheDocument();\n\n        // 4.   \"Confirm\"    \n        const confirmButton = screen.getByText('Confirm');\n        fireEvent.click(confirmButton);\n\n        // 5. ,        ID \n        expect(mockOnRemove).toHaveBeenCalledWith('video-123');\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/VideoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/VideoCardMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/VideoGrid.tsx","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output.\n\n/Users/muramets/Documents/youtube-interface/src/features/Video/VideoGrid.tsx:175:26\n  173 |   const videoViewModes = useUIStore(state => state.videoViewModes);\n  174 |\n> 175 |   const filteredVideos = React.useMemo(() => {\n      |                          ^^^^^^^^^^^^^^^^^^^^^\n> 176 |     // 1. Start with source videos\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 177 |     let result = propVideos || sourceVideos;\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 347 |     return result;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 348 |   }, [sourceVideos, selectedChannel, searchQuery, disableChannelFilter, propVideos, playlists, hiddenPlaylistIds, activeFilters, homeSortBy, videoViewModes]);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Could not preserve existing memoization\n  349 |\n  350 |\n  351 |","line":175,"column":26,"nodeType":null,"endLine":348,"endColumn":158},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useMemo has a missing dependency: 'playlistId'. Either include it or remove the dependency array.","line":348,"column":6,"nodeType":"ArrayExpression","endLine":348,"endColumn":157,"suggestions":[{"desc":"Update the dependencies array to be: [propVideos, sourceVideos, playlistId, activeFilters, homeSortBy, playlists, hiddenPlaylistIds, disableChannelFilter, selectedChannel, searchQuery, videoViewModes]","fix":{"range":[14095,14246],"text":"[propVideos, sourceVideos, playlistId, activeFilters, homeSortBy, playlists, hiddenPlaylistIds, disableChannelFilter, selectedChannel, searchQuery, videoViewModes]"}}]},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly.\n\n/Users/muramets/Documents/youtube-interface/src/features/Video/VideoGrid.tsx:348:130\n  346 |\n  347 |     return result;\n> 348 |   }, [sourceVideos, selectedChannel, searchQuery, disableChannelFilter, propVideos, playlists, hiddenPlaylistIds, activeFilters, homeSortBy, videoViewModes]);\n      |                                                                                                                                  ^^^^^^^^^^ This dependency may be modified later\n  349 |\n  350 |\n  351 |","line":348,"column":130,"nodeType":null,"endLine":348,"endColumn":140}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\nimport type { VideoDetails } from '../../core/utils/youtubeApi';\nimport { useVideos } from '../../core/hooks/useVideos';\n\nimport { useFilterStore } from '../../core/stores/filterStore';\nimport { usePlaylists } from '../../core/hooks/usePlaylists';\nimport { useSettings } from '../../core/hooks/useSettings';\nimport { VideoCardSkeleton } from '../../components/Shared/VideoCardSkeleton';\nimport { VirtualVideoGrid } from './VirtualVideoGrid';\nimport { VideoGridContainer } from './VideoGridContainer';\nimport { GRID_LAYOUT } from './layout';\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\nimport { useUIStore } from '../../core/stores/uiStore';\n\ninterface VideoGridProps {\n  videos?: VideoDetails[];\n  disableChannelFilter?: boolean;\n  playlistId?: string;\n  isLoading?: boolean;\n  onVideoMove?: (movedVideoId: string, targetVideoId: string) => void;\n}\n\nconst parseViewCount = (viewCount: string | number | undefined): number => {\n  if (viewCount === undefined || viewCount === null || viewCount === '') return 0;\n  if (typeof viewCount === 'number') return viewCount;\n\n  const clean = String(viewCount).toUpperCase().replace(/,/g, '').trim();\n  const multipliers: { [key: string]: number } = { 'K': 1e3, 'M': 1e6, 'B': 1e9 };\n\n  // Check for suffix\n  const suffix = Object.keys(multipliers).find(s => clean.endsWith(s));\n\n  if (suffix) {\n    const numStr = clean.slice(0, -suffix.length);\n    const num = parseFloat(numStr);\n    return isNaN(num) ? 0 : num * multipliers[suffix];\n  }\n\n  const num = parseFloat(clean);\n  return isNaN(num) ? 0 : num;\n};\n\nexport const VideoGrid: React.FC<VideoGridProps> = ({\n  videos: propVideos,\n  disableChannelFilter = false,\n  playlistId,\n  isLoading: propIsLoading = false,\n  onVideoMove\n}) => {\n  const { user, isLoading: authLoading } = useAuth();\n  const currentChannel = useChannelStore(state => state.currentChannel);\n\n  const { videos: contextVideos, isLoading: contextIsLoading, removeVideo } = useVideos(user?.uid || '', currentChannel?.id || '');\n\n  const selectedChannel = useFilterStore(state => state.selectedChannel);\n  const searchQuery = useFilterStore(state => state.searchQuery);\n\n  const { playlists } = usePlaylists(user?.uid || '', currentChannel?.id || '');\n\n  const { generalSettings, videoOrder, updateVideoOrder } = useSettings();\n  const cardsPerRow = generalSettings.cardsPerRow;\n  const hiddenPlaylistIds = generalSettings.hiddenPlaylistIds || [];\n\n  // Local state for immediate optimistic updates\n  const [localVideoOrder, setLocalVideoOrder] = React.useState<string[]>([]);\n\n  React.useEffect(() => {\n    if (videoOrder) {\n      setLocalVideoOrder(prev => {\n        if (JSON.stringify(prev) !== JSON.stringify(videoOrder)) {\n          return videoOrder;\n        }\n        return prev;\n      });\n    }\n  }, [videoOrder]);\n\n  const isLoading = propIsLoading || (propVideos ? false : contextIsLoading) || authLoading || (!propVideos && !currentChannel);\n\n  const sourceVideos = React.useMemo(() => {\n    if (propVideos) return propVideos;\n\n    // CRITICAL: Filter out isPlaylistOnly videos FIRST\n    // They should NEVER be in Home Page order\n    const homePageVideos = playlistId\n      ? contextVideos // In playlist view, show all videos\n      : contextVideos.filter(v => !v.isPlaylistOnly); // On Home, exclude playlist-only\n\n    // Use localVideoOrder instead of videoOrder for immediate feedback\n    // If no saved order, use current videos order\n    if (localVideoOrder.length === 0) {\n      return homePageVideos;\n    }\n\n    const videoMap = new Map(homePageVideos.map(v => [v.id, v]));\n    const sorted = localVideoOrder.map(id => videoMap.get(id)).filter((v): v is VideoDetails => !!v);\n\n    // Add any new videos that are not in localVideoOrder yet (PREPEND to beginning)\n    const orderedSet = new Set(localVideoOrder);\n    const newVideos = homePageVideos.filter(v => !orderedSet.has(v.id));\n\n    // PREPEND new videos to the beginning (so they appear first)\n    const result = [...newVideos, ...sorted];\n\n    return result;\n  }, [propVideos, contextVideos, localVideoOrder, playlistId]);\n\n  const handleLocalVideoMove = (movedVideoId: string, targetVideoId: string) => {\n\n    // Auto-switch to Manual mode when dragging in any sorted mode\n    if (homeSortBy !== 'default') {\n      // Capture current visual order BEFORE switching\n      const currentVisualOrder = filteredVideos.map(v => v.id);\n\n      // Switch to Manual mode\n      setHomeSortBy('default');\n\n      // Initialize videoOrder with current visual state\n      setLocalVideoOrder(currentVisualOrder);\n\n      // Update server immediately\n      if (user && currentChannel) {\n        updateVideoOrder(user.uid, currentChannel.id, currentVisualOrder);\n      }\n\n      // After switching, we need to re-calculate indices based on NEW visual order\n      // Since we just set localVideoOrder to currentVisualOrder, use it\n      const oldIndex = currentVisualOrder.indexOf(movedVideoId);\n      const newIndex = currentVisualOrder.indexOf(targetVideoId);\n\n      if (oldIndex !== -1 && newIndex !== -1) {\n        const newOrder = [...currentVisualOrder];\n        const [movedId] = newOrder.splice(oldIndex, 1);\n        newOrder.splice(newIndex, 0, movedId);\n\n        setLocalVideoOrder(newOrder);\n\n        // Update server directly\n        if (user && currentChannel) {\n          updateVideoOrder(user.uid, currentChannel.id, newOrder);\n        }\n      }\n      return; // Exit early after auto-switch\n    }\n\n    // Manual mode: Calculate drag indices from FILTERED videos (what user sees)\n    // Only save order for visible videos - isPlaylistOnly videos don't need Home Page order\n    const filteredOrder = filteredVideos.map(v => v.id);\n\n    const oldIndex = filteredOrder.indexOf(movedVideoId);\n    const newIndex = filteredOrder.indexOf(targetVideoId);\n\n    if (oldIndex !== -1 && newIndex !== -1) {\n      // Reorder the filtered list\n      const newOrder = [...filteredOrder];\n      const [movedId] = newOrder.splice(oldIndex, 1);\n      newOrder.splice(newIndex, 0, movedId);\n\n      setLocalVideoOrder(newOrder);\n\n      // Update server directly\n      if (user && currentChannel) {\n        updateVideoOrder(user.uid, currentChannel.id, newOrder);\n      }\n    }\n  };\n\n  const activeFilters = useFilterStore(state => state.activeFilters);\n  const homeSortBy = useFilterStore(state => state.homeSortBy);\n  const setHomeSortBy = useFilterStore(state => state.setHomeSortBy);\n  const videoViewModes = useUIStore(state => state.videoViewModes);\n\n  const filteredVideos = React.useMemo(() => {\n    // 1. Start with source videos\n    let result = propVideos || sourceVideos;\n\n    // 2. Filter out hidden videos from Settings (Global hide) AND playlist-only videos\n    const hiddenVideoIds = new Set<string>();\n    if (!playlistId) { // Only apply hidden playlist logic on Home/Global views, not inside a specific playlist\n      // Filter out global hidden playlists\n      playlists.forEach(playlist => {\n        if (hiddenPlaylistIds.includes(playlist.id)) {\n          playlist.videoIds.forEach(id => hiddenVideoIds.add(id));\n        }\n      });\n\n      // Also filter out playlist-only videos from Home Page\n      result = result.filter(video => !video.isPlaylistOnly);\n    }\n\n    if (hiddenVideoIds.size > 0) {\n      result = result.filter(video => !hiddenVideoIds.has(video.id));\n    }\n\n    // 3. Apply Legacy Channel & Search Filters\n    result = result.filter(video => {\n      const matchesChannel = disableChannelFilter || !selectedChannel || selectedChannel === 'All' || video.channelTitle === selectedChannel;\n      const matchesSearch = video.title.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        video.channelTitle.toLowerCase().includes(searchQuery.toLowerCase());\n      return matchesChannel && matchesSearch;\n    });\n\n    // 4. Apply Advanced Filters\n    if (activeFilters.length > 0) {\n      result = result.filter(video => {\n        return activeFilters.every(filter => {\n          switch (filter.type) {\n            case 'title':\n              return video.title.toLowerCase().includes(String(filter.value).toLowerCase());\n\n            case 'channel': {\n              const channels = Array.isArray(filter.value) ? filter.value : [filter.value];\n              return channels.includes(video.channelTitle);\n            }\n\n            case 'playlist': {\n              const playlistIds = Array.isArray(filter.value) ? filter.value : [filter.value];\n              return playlistIds.some(id => {\n                const pl = playlists.find(p => p.id === id);\n                return pl ? pl.videoIds.includes(video.id) : false;\n              });\n            }\n\n            case 'videoType': {\n              const types = Array.isArray(filter.value) ? filter.value : [filter.value];\n              return types.some(type => {\n                if (type === 'custom_video') return video.isCustom;\n                if (type === 'published_custom_video') return video.isCustom && video.publishedVideoId;\n                if (type === 'other_youtube') return !video.isCustom;\n                return true;\n              });\n            }\n\n            case 'views': {\n              const views = parseViewCount(video.viewCount);\n              const [min, max] = Array.isArray(filter.value) ? filter.value : [filter.value, undefined];\n\n              switch (filter.operator) {\n                case 'gt': return views > min;\n                case 'lt': return views < min;\n                case 'gte': return views >= min;\n                case 'lte': return views <= min;\n                case 'equals': return views === min;\n                case 'between': return views >= min && (max !== undefined ? views <= max : true);\n                default: return true;\n              }\n            }\n\n            case 'duration': {\n              // Duration is ISO 8601 (PT1H2M10S) or custom formatted string.\n              // Helper to parse duration string to SECONDS.\n              const parseDuration = (duration: string | number) => {\n                if (typeof duration === 'number') return duration; // Already seconds?\n                if (!duration) return 0;\n\n                // Check ISO 8601\n                const isoMatch = duration.match(/PT(\\d+H)?(\\d+M)?(\\d+S)?/);\n                if (isoMatch) {\n                  const hours = parseInt(isoMatch[1] || '0') || 0;\n                  const minutes = parseInt(isoMatch[2] || '0') || 0;\n                  const seconds = parseInt(isoMatch[3] || '0') || 0;\n                  return (hours * 3600) + (minutes * 60) + seconds;\n                }\n\n                // Check HH:MM:SS or MM:SS format (Custom Video Manual Entry)\n                if (duration.includes(':')) {\n                  const parts = duration.split(':').map(Number).reverse();\n                  let seconds = 0;\n                  if (parts[0]) seconds += parts[0]; // S\n                  if (parts[1]) seconds += parts[1] * 60; // M\n                  if (parts[2]) seconds += parts[2] * 3600; // H\n                  return seconds;\n                }\n\n                return parseInt(duration) || 0;\n              };\n\n              const videoSeconds = parseDuration(video.duration || '');\n              const [min, max] = Array.isArray(filter.value) ? filter.value : [filter.value, undefined];\n\n              // Filter values are now passed in SECONDS from SmartDurationInput\n\n              switch (filter.operator) {\n                case 'gt': return videoSeconds > min;\n                case 'lt': return videoSeconds < min;\n                case 'gte': return videoSeconds >= min;\n                case 'lte': return videoSeconds <= min;\n                case 'equals': return Math.abs(videoSeconds - min) < 5; // Allow 5 second buffer for exact match?\n                case 'between': return videoSeconds >= min && (max !== undefined ? videoSeconds <= max : true);\n                default: return true;\n              }\n            }\n\n            case 'date': {\n              const videoDate = new Date(video.publishedAt).getTime();\n              const [start, end] = Array.isArray(filter.value) ? filter.value : [filter.value, undefined];\n              switch (filter.operator) {\n                case 'between': return videoDate >= start && (end !== undefined ? videoDate <= end : true);\n                default: return true;\n              }\n            }\n\n            default:\n              return true;\n          }\n        });\n      });\n    }\n\n    // 5. Apply Sorting (Home Sort) - overrides default order\n    if (homeSortBy !== 'default') {\n      const sorted = [...result];\n      sorted.sort((a, b) => {\n        if (homeSortBy === 'views') {\n          // Priority: Pure View Count (Descending)\n          const modeA = videoViewModes[a.id] || (a.publishedVideoId ? 'youtube' : 'custom');\n          const modeB = videoViewModes[b.id] || (b.publishedVideoId ? 'youtube' : 'custom');\n\n          const getEffectiveViews = (v: VideoDetails, mode: 'custom' | 'youtube') => {\n            // If it's a Custom Video in Custom Mode, use its specific viewCount input\n            if (v.isCustom && mode === 'custom') {\n              return parseViewCount(v.viewCount);\n            }\n            // Otherwise use the Merged (Live) stats if available, fall back to base viewCount\n            return parseViewCount(v.mergedVideoData?.viewCount || v.viewCount);\n          };\n\n          const viewsA = getEffectiveViews(a, modeA);\n          const viewsB = getEffectiveViews(b, modeB);\n\n          return viewsB - viewsA; // Descending\n        } else if (homeSortBy === 'date') {\n          return new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime();\n        } else if (homeSortBy === 'recently_added') {\n          // Sort by addedToHomeAt, fallback to createdAt for backward compatibility\n          const timeA = a.addedToHomeAt || a.createdAt || 0;\n          const timeB = b.addedToHomeAt || b.createdAt || 0;\n          return timeB - timeA; // Newest first\n        }\n        return 0;\n      });\n      return sorted;\n    }\n\n    return result;\n  }, [sourceVideos, selectedChannel, searchQuery, disableChannelFilter, propVideos, playlists, hiddenPlaylistIds, activeFilters, homeSortBy, videoViewModes]);\n\n\n\n\n\n  if (isLoading) {\n    return (\n      <VideoGridContainer>\n        <div\n          className={`grid w-full h-full overflow-y-auto overflow-x-hidden`}\n          style={{\n            gap: GRID_LAYOUT.GAP,\n            paddingTop: GRID_LAYOUT.PADDING.TOP,\n            paddingRight: GRID_LAYOUT.PADDING.RIGHT,\n            paddingBottom: GRID_LAYOUT.PADDING.BOTTOM,\n            paddingLeft: GRID_LAYOUT.PADDING.LEFT,\n            gridTemplateColumns: `repeat(${cardsPerRow}, minmax(0, 1fr))`\n          }}\n        >\n          {Array.from({ length: cardsPerRow * 3 }).map((_, i) => (\n            <div key={i} className=\"min-w-0\">\n              <VideoCardSkeleton />\n            </div>\n          ))}\n        </div>\n      </VideoGridContainer >\n    );\n  }\n\n  if (filteredVideos.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center w-full h-[50vh] text-text-secondary\">\n        <p className=\"text-xl font-medium\">No videos found</p>\n        <p className=\"text-sm mt-2\">Try adjusting your filters or add new videos.</p>\n      </div>\n    );\n  }\n\n  return (\n    <VideoGridContainer>\n      <VirtualVideoGrid\n        videos={filteredVideos}\n        playlistId={playlistId}\n        onRemove={(videoId) => {\n          if (user && currentChannel) {\n            removeVideo(videoId);\n          }\n        }}\n        onVideoMove={onVideoMove || (homeSortBy === 'default' ? handleLocalVideoMove : undefined)}\n      />\n    </VideoGridContainer>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/VideoGridContainer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/VirtualVideoGrid.tsx","messages":[{"ruleId":"react-hooks/incompatible-library","severity":1,"message":"Compilation Skipped: Use of incompatible library\n\nThis API returns functions which cannot be memoized without leading to stale UI. To prevent this, by default React Compiler will skip memoizing this component/hook. However, you may see issues if values from this API are passed to other components/hooks that are memoized.\n\n/Users/muramets/Documents/youtube-interface/src/features/Video/VirtualVideoGrid.tsx:79:25\n  77 |     const rowCount = Math.ceil(videos.length / columnCount);\n  78 |\n> 79 |     const virtualizer = useVirtualizer({\n     |                         ^^^^^^^^^^^^^^ TanStack Virtual's `useVirtualizer()` API returns functions that cannot be memoized safely\n  80 |         count: rowCount,\n  81 |         getScrollElement: () => scrollElement,\n  82 |         estimateSize: () => rowHeight,","line":79,"column":25,"nodeType":null,"endLine":79,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_event' is defined but never used.","line":119,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3965,3968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3965,3968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/features/Video/VirtualVideoGrid.tsx:281:36\n  279 |                     key={`grid-${containerSize.width}-${generalSettings.cardsPerRow}`}\n  280 |                     containerWidth={containerSize.width}\n> 281 |                     scrollElement={parentRef.current}\n      |                                    ^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  282 |                 />\n  283 |             )}\n  284 |         </div>","line":281,"column":36,"nodeType":null,"endLine":281,"endColumn":53}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useState, useEffect, useLayoutEffect } from 'react';\nimport { useVirtualizer } from '@tanstack/react-virtual';\nimport { VideoCard } from './VideoCard';\nimport { SortableVideoCard } from './SortableVideoCard';\nimport type { VideoDetails } from '../../core/utils/youtubeApi';\nimport { useSettings } from '../../core/hooks/useSettings';\nimport { GRID_LAYOUT } from './layout';\nimport {\n    DndContext,\n    closestCenter,\n    KeyboardSensor,\n    PointerSensor,\n    useSensor,\n    useSensors,\n    DragOverlay,\n    type DragEndEvent,\n    type DragStartEvent,\n} from '@dnd-kit/core';\nimport {\n    SortableContext,\n    sortableKeyboardCoordinates,\n    rectSortingStrategy,\n} from '@dnd-kit/sortable';\n\ninterface VirtualVideoGridProps {\n    videos: VideoDetails[];\n    playlistId?: string;\n    onRemove?: (id: string) => void;\n    onVideoMove?: (movedVideoId: string, targetVideoId: string) => void;\n}\n\ninterface InnerGridProps extends VirtualVideoGridProps {\n    containerWidth: number;\n    scrollElement: HTMLElement | null;\n}\n\nconst InnerGrid: React.FC<InnerGridProps> = ({\n    videos,\n    playlistId,\n    onRemove,\n    onVideoMove,\n    containerWidth,\n    scrollElement\n}) => {\n    const { generalSettings } = useSettings();\n    const cardsPerRow = generalSettings.cardsPerRow;\n\n    // Track when videos array changes\n    React.useEffect(() => {\n        // videos changed\n    }, [videos]);\n\n    // Memoize layout calculations\n    const { columnCount, safeCardWidth, rowHeight } = React.useMemo(() => {\n        const columnCount = cardsPerRow;\n        const availableWidth = containerWidth - GRID_LAYOUT.PADDING.LEFT - GRID_LAYOUT.PADDING.RIGHT - (GRID_LAYOUT.GAP * (columnCount - 1));\n        const cardWidth = Math.floor(availableWidth / columnCount);\n\n        // Safety check\n        const safeCardWidth = Math.max(0, cardWidth);\n        const thumbnailHeight = safeCardWidth * (9 / 16);\n\n        // Dynamic content height based on density to handle text wrapping\n        const getCardContentHeight = (cols: number) => {\n            if (cols >= 6) return 150; // High density: More text wrapping needs more space\n            if (cols <= 3) return 96;  // Low density: Less wrapping needs less space\n            return 108;                // Medium density: Default\n        };\n\n        const contentHeight = getCardContentHeight(columnCount);\n        const cardHeight = thumbnailHeight + contentHeight;\n        const rowHeight = cardHeight + GRID_LAYOUT.GAP; // Total vertical space matches grid gap\n\n        return { columnCount, safeCardWidth, rowHeight };\n    }, [containerWidth, cardsPerRow]);\n\n    const rowCount = Math.ceil(videos.length / columnCount);\n\n    const virtualizer = useVirtualizer({\n        count: rowCount,\n        getScrollElement: () => scrollElement,\n        estimateSize: () => rowHeight,\n        overscan: 5,\n    });\n\n    // Recalculate virtualizer measurements when rowHeight changes\n    // Removed virtualizer.measure() here as we use a dynamic key on the container \n    // to force a full reset when the layout (columnCount/rowHeight) changes.\n\n    const isDraggable = !!onVideoMove;\n    const [activeVideo, setActiveVideo] = React.useState<VideoDetails | null>(null);\n\n    const sensors = useSensors(\n        useSensor(PointerSensor, {\n            activationConstraint: {\n                distance: 8,\n            },\n        }),\n        useSensor(KeyboardSensor, {\n            coordinateGetter: sortableKeyboardCoordinates,\n        })\n    );\n\n    const handleDragStart = (event: DragStartEvent) => {\n        const video = videos.find(v => v.id === event.active.id);\n        setActiveVideo(video || null);\n    };\n\n    const handleDragEnd = (event: DragEndEvent) => {\n        const { active, over } = event;\n\n        setActiveVideo(null);\n\n        if (over && active.id !== over.id && onVideoMove) {\n            onVideoMove(active.id as string, over.id as string);\n        }\n    };\n\n    const handleDragOver = (_event: any) => {\n        // Handle drag over if needed\n    };\n\n    const handleDragCancel = () => {\n        setActiveVideo(null);\n    };\n\n    const items = virtualizer.getVirtualItems();\n\n    const gridContent = (\n        <div\n            style={{\n                height: `${virtualizer.getTotalSize()}px`,\n                width: '100%',\n                position: 'relative',\n            }}\n        >\n            {items.map((virtualRow) => {\n                const index = virtualRow.index;\n                const rowVideos = [];\n                for (let i = 0; i < columnCount; i++) {\n                    const videoIndex = index * columnCount + i;\n                    if (videoIndex < videos.length) {\n                        rowVideos.push(videos[videoIndex]);\n                    }\n                }\n\n                return (\n                    <div\n                        key={virtualRow.key}\n                        data-index={virtualRow.index}\n                        style={{\n                            position: 'absolute',\n                            top: 0,\n                            left: 0,\n                            width: '100%',\n                            height: `${virtualRow.size}px`,\n                            transform: `translateY(${virtualRow.start}px)`,\n                            display: 'flex',\n                            gap: GRID_LAYOUT.GAP,\n                            paddingLeft: GRID_LAYOUT.PADDING.LEFT,\n                            paddingRight: GRID_LAYOUT.PADDING.RIGHT,\n                        }}\n                    >\n                        {rowVideos.map((video) => (\n                            <div key={video.id} style={{ width: safeCardWidth, height: virtualRow.size - GRID_LAYOUT.GAP }}>\n                                {isDraggable ? (\n                                    <SortableVideoCard\n                                        video={video}\n                                        playlistId={playlistId}\n                                        onRemove={onRemove}\n                                    />\n                                ) : (\n                                    <VideoCard\n                                        video={video}\n                                        playlistId={playlistId}\n                                        onRemove={onRemove || (() => { })}\n                                    />\n                                )}\n                            </div>\n                        ))}\n                    </div>\n                );\n            })}\n        </div>\n    );\n\n    if (isDraggable) {\n        return (\n            <DndContext\n                sensors={sensors}\n                collisionDetection={closestCenter}\n                onDragStart={handleDragStart}\n                onDragOver={handleDragOver}\n                onDragEnd={handleDragEnd}\n                onDragCancel={handleDragCancel}\n            >\n                <SortableContext\n                    items={videos.map(v => v.id)}\n                    strategy={rectSortingStrategy}\n                >\n                    {gridContent}\n                </SortableContext>\n                <DragOverlay dropAnimation={null}>\n                    {activeVideo ? (\n                        <div style={{ width: safeCardWidth, cursor: 'grabbing' }}>\n                            <VideoCard\n                                video={activeVideo}\n                                playlistId={playlistId}\n                                onRemove={onRemove || (() => { })}\n                                isOverlay\n                            />\n                        </div>\n                    ) : null}\n                </DragOverlay>\n            </DndContext>\n        );\n    }\n\n    return gridContent;\n};\n\nexport const VirtualVideoGrid: React.FC<VirtualVideoGridProps> = (props) => {\n    const { generalSettings } = useSettings();\n    const parentRef = useRef<HTMLDivElement>(null);\n\n    // Track container dimensions\n    const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });\n\n    // Use useLayoutEffect for synchronous initial measurement - runs before browser paint\n    // This prevents the \"empty frame\" where nothing renders while waiting for ResizeObserver\n    useLayoutEffect(() => {\n        if (parentRef.current) {\n            const rect = parentRef.current.getBoundingClientRect();\n            setContainerSize({ width: rect.width, height: rect.height });\n        }\n    }, []);\n\n    // ResizeObserver for subsequent size changes (window resize, etc.)\n    useEffect(() => {\n        if (!parentRef.current) return;\n\n        const resizeObserver = new ResizeObserver((entries) => {\n            for (const entry of entries) {\n                const width = entry.contentRect.width;\n                const height = entry.contentRect.height;\n\n                setContainerSize(prev => {\n                    if (prev.width === width && prev.height === height) {\n                        return prev;\n                    }\n                    return { width, height };\n                });\n            }\n        });\n\n        resizeObserver.observe(parentRef.current);\n        return () => resizeObserver.disconnect();\n    }, []);\n\n    return (\n        <div\n            ref={parentRef}\n            className=\"flex-1 w-full h-full overflow-y-auto\"\n            style={{\n                paddingTop: GRID_LAYOUT.PADDING.TOP,\n                paddingBottom: GRID_LAYOUT.PADDING.BOTTOM,\n                scrollbarGutter: 'stable',\n            }}\n        >\n            {/* \n              Wait for container width to be measured before mounting the grid.\n              By conditionally mounting InnerGrid only when width > 0, \n              we ensure useVirtualizer initializes with the correct dimensions immediately,\n              preventing the \"crooked\" layout glitch caused by starting with 0 width.\n            */}\n            {containerSize.width > 0 && (\n                <InnerGrid\n                    {...props}\n                    key={`grid-${containerSize.width}-${generalSettings.cardsPerRow}`}\n                    containerWidth={containerSize.width}\n                    scrollElement={parentRef.current}\n                />\n            )}\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/ZoomControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Video/layout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Watch/RecommendationCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Watch/SortableRecommendationCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Watch/WatchPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Watch/WatchPageFilterBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Watch/WatchPageNotes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Watch/WatchPageSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Watch/WatchPageVideoInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/features/Watch/WatchPageVideoPlayer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/DetailsLayout.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/DetailsLayout.tsx:202:17\n  200 |                     versions.switchToVersion(versions.activeVersion);\n  201 |                 }\n> 202 |                 setSelectedSnapshot(null);\n      |                 ^^^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  203 |             }\n  204 |         }\n  205 |","line":202,"column":17,"nodeType":null,"endLine":202,"endColumn":36},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'selectedSnapshot'. Either include it or remove the dependency array.","line":214,"column":8,"nodeType":"ArrayExpression","endLine":214,"endColumn":29,"suggestions":[{"desc":"Update the dependencies array to be: [activeTab, selectedSnapshot, versions]","fix":{"range":[8529,8550],"text":"[activeTab, selectedSnapshot, versions]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'id' is assigned a value but never used.","line":306,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":306,"endColumn":39}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo } from 'react';\nimport { type VideoDetails } from '../../core/utils/youtubeApi';\nimport { DetailsSidebar } from './Sidebar/DetailsSidebar';\nimport { PackagingTab } from './tabs/Packaging/PackagingTab';\nimport { TrafficTab } from './tabs/Traffic/TrafficTab';\nimport { usePackagingVersions } from './tabs/Packaging/hooks/usePackagingVersions';\nimport { useTrafficFilters } from './tabs/Traffic/hooks/useTrafficFilters';\nimport { useTrafficData } from './tabs/Traffic/hooks/useTrafficData';\nimport { useTrafficDataLoader } from './tabs/Traffic/hooks/useTrafficDataLoader';\nimport { type SortConfig } from './tabs/Traffic/components/TrafficTable';\n\n// ... existing imports ...\n\n\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\nimport { useVideos } from '../../core/hooks/useVideos';\nimport { useVersionManagement } from './hooks/useVersionManagement';\nimport { useSnapshotManagement } from './hooks/useSnapshotManagement';\nimport { useModalState } from './hooks/useModalState';\nimport { DetailsModals } from './components/DetailsModals';\nimport { useTrafficNicheStore } from '../../core/stores/useTrafficNicheStore';\n\ninterface DetailsLayoutProps {\n    video: VideoDetails;\n}\n\nexport const DetailsLayout: React.FC<DetailsLayoutProps> = ({ video }) => {\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { updateVideo } = useVideos(user?.uid || '', currentChannel?.id || '');\n\n    // Tab State\n    const [activeTab, setActiveTab] = useState<'packaging' | 'traffic'>('packaging');\n    const [isFormDirty, setIsFormDirty] = useState(false);\n    const [selectedSnapshot, setSelectedSnapshot] = useState<string | null>(null);\n\n    // Version management\n    const versions = usePackagingVersions({\n        initialHistory: video.packagingHistory || [],\n        initialCurrentVersion: video.currentPackagingVersion || 1,\n        // USER REQUIREMENT: Only show Draft in sidebar if explicitly saved/managed as draft\n        isDraft: !!video.isDraft,\n        initialActiveVersion: video.activeVersion\n    });\n\n    // Modal state management\n    const {\n        modalState,\n        openSwitchConfirm,\n        openDeleteConfirm,\n        openSnapshotRequest,\n        closeModal\n    } = useModalState();\n\n    // Traffic data\n    const trafficState = useTrafficData({\n        userId: user?.uid || '',\n        channelId: currentChannel?.id || '',\n        video\n    });\n\n    // Niche Data (Live from Store)\n    const { niches, assignments } = useTrafficNicheStore();\n\n    // Convert store data to TrafficGroup[] for Sidebar consumption\n    const groups = useMemo(() => {\n        return niches.map(niche => ({\n            id: niche.id,\n            name: niche.name,\n            color: niche.color,\n            property: niche.property,\n            videoIds: assignments\n                .filter(a => a.nicheId === niche.id)\n                .map(a => a.videoId)\n        }));\n    }, [niches, assignments]);\n\n    // OPTIMIZATION: Stabilize references to prevent useTrafficDataLoader effect re-runs.\n    // Defense-in-depth: useTrafficDataLoader also has skip logic, but stable references\n    // prevent the effect from running at all when parent re-renders due to useVideos.\n    const memoizedTrafficData = useMemo(() => trafficState.trafficData, [trafficState.trafficData]);\n    const memoizedPackagingHistory = useMemo(() => versions.packagingHistory, [versions.packagingHistory]);\n\n    // Traffic View Mode (Lifted State from TrafficTab)\n    const [trafficViewMode, setTrafficViewMode] = useState<'cumulative' | 'delta'>('delta');\n\n    // Sort State (Lifted)\n    const [sortConfig, setSortConfig] = useState<SortConfig | null>({ key: 'views', direction: 'desc' });\n\n    /**\n     * BUSINESS LOGIC: Filter Context Key\n     * Lifted from TrafficTab to share filter state between Tab and Sidebar.\n     */\n    const filterContextKey = useMemo(() => {\n        if (selectedSnapshot) {\n            return `snapshot-${selectedSnapshot}`;\n        }\n        return `version-${versions.viewingVersion}-period-${versions.viewingPeriodIndex}`;\n    }, [selectedSnapshot, versions.viewingVersion, versions.viewingPeriodIndex]);\n\n    // Filters Logic with Context-Aware Persistence\n    const { filters, addFilter, removeFilter, clearFilters, applyFilters } = useTrafficFilters({\n        contextKey: filterContextKey\n    });\n\n    // Determine Active Niche ID from filters (use LAST applied niche filter to reflect current navigation state)\n    const activeNicheId = useMemo(() => {\n        // Search in reverse to find the most recently added niche filter\n        // useful if user has 'Unassigned' (old) + 'Niche X' (new)\n        for (let i = filters.length - 1; i >= 0; i--) {\n            const f = filters[i];\n            if (f.type === 'niche' && Array.isArray(f.value) && f.value.length > 0) {\n                return f.value[0];\n            }\n        }\n        return null;\n    }, [filters]);\n\n    // Traffic Data Loader (Lifted to provide data to Sidebar)\n    const trafficLoader = useTrafficDataLoader({\n        trafficData: memoizedTrafficData,\n        viewingVersion: versions.viewingVersion,\n        viewingPeriodIndex: versions.viewingPeriodIndex,\n        activeVersion: typeof versions.activeVersion === 'number' ? versions.activeVersion : 0,\n        viewMode: trafficViewMode,\n        selectedSnapshot,\n        packagingHistory: memoizedPackagingHistory,\n        groups: groups\n    });\n\n    // Version management handlers\n    const versionMgmt = useVersionManagement({\n        versions,\n        isFormDirty,\n        video,\n        user,\n        currentChannel,\n        updateVideo,\n        showToast: (msg, type) => console.log(`[Toast] ${type}: ${msg}`), // TODO: use uiStore\n        setSelectedSnapshot,\n        activeTab,\n        selectedSnapshot,\n        trafficState,\n        onOpenSwitchConfirm: openSwitchConfirm,\n        onOpenDeleteConfirm: openDeleteConfirm,\n        onOpenSnapshotRequest: (params) => openSnapshotRequest(params)\n    });\n\n    // Snapshot management handlers\n    const snapshotMgmt = useSnapshotManagement({\n        video,\n        versions,\n        trafficState,\n        user,\n        currentChannel,\n        updateVideo,\n        showToast: (msg, type) => console.log(`[Toast] ${type}: ${msg}`), // TODO: use uiStore\n        setSelectedSnapshot,\n        setActiveTab,\n        selectedSnapshot,\n        snapshotRequest: modalState.type === 'SNAPSHOT_REQUEST' ? {\n            isForCreateVersion: modalState.isForCreateVersion,\n            versionToRestore: modalState.versionToRestore,\n            resolveCallback: modalState.resolveCallback,\n            versionNumber: modalState.versionNumber,\n            context: modalState.context\n        } : {\n            isForCreateVersion: false,\n            versionToRestore: null,\n            resolveCallback: null,\n            versionNumber: undefined,\n            context: undefined\n        },\n        onOpenSnapshotRequest: openSnapshotRequest,\n        closeSnapshotModal: closeModal\n    });\n\n    // Helper: Get display title (use first A/B title if available)\n    const getDisplayTitle = () => {\n        if (video.abTestTitles && video.abTestTitles.length > 0) {\n            return video.abTestTitles[0];\n        }\n        return video.title;\n    };\n\n    // Auto-switch to active version when switching tabs\n    const prevActiveTabRef = React.useRef(activeTab);\n    useEffect(() => {\n        const prevTab = prevActiveTabRef.current;\n\n        // When entering Traffic tab  switch to active version\n        // When entering Traffic tab  switch to active version\n        if (prevTab !== 'traffic' && activeTab === 'traffic') {\n            const isNotViewingActive = versions.viewingVersion !== versions.activeVersion;\n\n            // If not viewing active version OR handling a selected snapshot (stale from previous session)\n            if (isNotViewingActive || selectedSnapshot) {\n                if (isNotViewingActive) {\n                    versions.switchToVersion(versions.activeVersion);\n                }\n                setSelectedSnapshot(null);\n            }\n        }\n\n        // When entering Packaging tab  switch to active version\n        if (prevTab !== 'packaging' && activeTab === 'packaging') {\n            if (versions.viewingVersion !== versions.activeVersion) {\n                versions.switchToVersion(versions.activeVersion);\n            }\n        }\n\n        prevActiveTabRef.current = activeTab;\n    }, [activeTab, versions]);\n\n    // Handle draft deletion\n    const handleDeleteDraft = async () => {\n        if (!user?.uid || !currentChannel?.id || !video.id) return;\n\n        try {\n            // Find the last saved version to switch to\n            const lastVersion = versions.packagingHistory.length > 0\n                ? Math.max(...versions.packagingHistory.map(v => v.versionNumber))\n                : null;\n\n            // Update local state first for immediate UI feedback\n            versions.setHasDraft(false);\n            if (lastVersion) {\n                versions.setActiveVersion(lastVersion);\n                versions.switchToVersion(lastVersion);\n            }\n\n            // Save to Firestore\n            await updateVideo({\n                videoId: video.id,\n                updates: {\n                    isDraft: false,\n                    activeVersion: lastVersion || undefined\n                }\n            });\n\n            console.log('[Toast] success: Draft deleted');\n        } catch (error) {\n            console.error('Failed to delete draft:', error);\n            console.log('[Toast] error: Failed to delete draft');\n        }\n    };\n\n\n    // State to track the \"previous\" niche filter for restoration on \"Back\" navigation\n    const previousNicheFilterRef = React.useRef<import('../../core/types/traffic').TrafficFilter | null>(null);\n    const previousSortConfigRef = React.useRef<SortConfig | null>(null);\n\n    // Context-sensitive Add Filter for Sidebar\n    const handleSidebarAddFilter = React.useCallback((filter: Omit<import('../../core/types/traffic').TrafficFilter, 'id'>) => {\n        if (filter.type === 'niche') {\n            // If we are starting a navigation chain (ref is null), save the current state\n\n            // Save Sort Config if not already saved (first jump)\n            if (previousSortConfigRef.current === null) {\n                previousSortConfigRef.current = sortConfig;\n            }\n\n            if (previousNicheFilterRef.current === null) {\n                const activeNicheFilter = filters.find(f => f.type === 'niche');\n                if (activeNicheFilter) {\n                    previousNicheFilterRef.current = activeNicheFilter;\n                }\n            }\n        }\n        addFilter(filter);\n    }, [filters, addFilter, sortConfig]);\n\n    // Context-sensitive Remove Filter to clear restoration state\n    const handleRemoveFilter = React.useCallback((id: string) => {\n        // If user manually removes the active niche filter, we reset our \"Back\" restoration state\n        const removedFilter = filters.find(f => f.id === id);\n        if (removedFilter?.type === 'niche') {\n            previousNicheFilterRef.current = null;\n            previousSortConfigRef.current = null;\n        }\n        removeFilter(id);\n    }, [filters, removeFilter]);\n\n    return (\n        <div className=\"flex-1 flex overflow-hidden bg-video-edit-bg\">\n            {/* Left Sidebar */}\n            <DetailsSidebar\n                video={video}\n                versions={versions.navSortedVersions}\n                viewingVersion={versions.viewingVersion}\n                activeVersion={versions.activeVersion}\n                viewingPeriodIndex={versions.viewingPeriodIndex}\n                hasDraft={versions.hasDraft}\n                onVersionClick={versionMgmt.handleVersionClick}\n                onDeleteVersion={versionMgmt.handleDeleteVersion}\n                onDeleteDraft={handleDeleteDraft}\n                snapshots={trafficState.trafficData?.snapshots || []}\n                selectedSnapshot={selectedSnapshot}\n                onSnapshotClick={(snapshotId) => {\n                    // FIX: Return to previous niche state (e.g. Unassigned) if it existed, otherwise just clear current niche\n                    if (activeNicheId) {\n                        if (previousNicheFilterRef.current) {\n                            // Restore the saved \"Base\" filter (e.g. Unassigned)\n                            // We use addFilter which will replace the current Niche filter\n                            const { id, ...filterProps } = previousNicheFilterRef.current;\n                            addFilter(filterProps);\n                            previousNicheFilterRef.current = null; // Reset after restore\n                        } else {\n                            // No previous state saved, just clear current niche\n                            const nicheFilter = filters.find(f =>\n                                f.type === 'niche' &&\n                                Array.isArray(f.value) &&\n                                f.value.includes(activeNicheId)\n                            );\n                            if (nicheFilter) {\n                                removeFilter(nicheFilter.id);\n                            }\n                        }\n\n                        // Restore Sort\n                        if (previousSortConfigRef.current) {\n                            setSortConfig(previousSortConfigRef.current);\n                            previousSortConfigRef.current = null;\n                        }\n                    }\n                    snapshotMgmt.handleSnapshotClick(snapshotId);\n                }}\n                onDeleteSnapshot={snapshotMgmt.handleDeleteSnapshot}\n                activeTab={activeTab}\n                onTabChange={setActiveTab}\n                // NEW: Pass live calculated groups (niches)\n                groups={groups}\n                displayedSources={trafficLoader.displayedSources}\n                // Filter control for sidebar interactions\n                onAddFilter={handleSidebarAddFilter}\n                activeNicheId={activeNicheId}\n            />\n\n            {/* Main Content Area */}\n            <div className=\"flex-1 flex flex-col min-h-0 overflow-hidden\">\n                {activeTab === 'packaging' ? (\n                    <PackagingTab\n                        video={video}\n                        versionState={versions}\n                        onDirtyChange={(dirty) => {\n                            setIsFormDirty(dirty);\n                        }}\n                        onRestoreVersion={versionMgmt.handleRestoreVersion}\n                        onRequestSnapshot={snapshotMgmt.handleRequestSnapshot}\n                        trafficData={trafficState.trafficData}\n                    />\n                ) : (\n                    <TrafficTab\n                        video={video}\n                        activeVersion={typeof versions.activeVersion === 'number' ? versions.activeVersion : 0}\n                        viewingVersion={versions.viewingVersion}\n                        viewingPeriodIndex={versions.viewingPeriodIndex}\n                        selectedSnapshot={selectedSnapshot}\n                        trafficData={memoizedTrafficData}\n                        isLoadingData={trafficState.isLoading}\n                        isSaving={trafficState.isSaving}\n                        handleCsvUpload={trafficState.handleCsvUpload}\n                        onSnapshotClick={snapshotMgmt.handleSnapshotClick}\n                        packagingHistory={memoizedPackagingHistory}\n                        // Lifted props\n                        displayedSources={trafficLoader.displayedSources}\n                        viewMode={trafficViewMode}\n                        onViewModeChange={setTrafficViewMode}\n                        isLoadingSnapshot={trafficLoader.isLoadingSnapshot}\n                        error={trafficLoader.error}\n                        retry={trafficLoader.retry}\n                        actualTotalRow={trafficLoader.actualTotalRow}\n                        trashMetrics={trafficLoader.trashMetrics}\n                        deltaContext={trafficLoader.deltaContext}\n                        groups={groups}\n                        // Filter props\n                        filters={filters}\n                        onAddFilter={addFilter}\n\n                        onRemoveFilter={handleRemoveFilter}\n                        onClearFilters={clearFilters}\n                        applyFilters={applyFilters}\n                        sortConfig={sortConfig}\n                        onSort={(key) => setSortConfig(current => {\n                            if (current?.key === key) {\n                                return { key, direction: current.direction === 'asc' ? 'desc' : 'asc' };\n                            }\n                            return { key, direction: 'desc' };\n                        })}\n                    />\n                )}\n            </div>\n\n            {/* All Modals */}\n            <DetailsModals\n                modalState={modalState}\n                activeVersion={versions.activeVersion}\n                videoTitle={getDisplayTitle()}\n                onConfirmSwitch={versionMgmt.confirmSwitch}\n                onConfirmDelete={(versionNumber) => {\n                    versionMgmt.confirmDelete(versionNumber);\n                    closeModal();\n                }}\n                onSnapshotUpload={snapshotMgmt.handleSnapshotUpload}\n                onSkipSnapshot={snapshotMgmt.handleSkipSnapshot}\n                onClose={closeModal}\n            />\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/DetailsPage.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'channels' logical expression could make the dependencies of useEffect Hook (at line 41) change on every render. Move it inside the useEffect callback. Alternatively, wrap the initialization of 'channels' in its own useMemo() Hook.","line":27,"column":11,"nodeType":"VariableDeclarator","endLine":27,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DetailsPage - Entry point for video details/packaging page\n * \n * Supports full deep linking via URL parameters:\n *   /video/:channelId/:videoId/details\n * \n * This allows bookmarks and shared links to work on any device,\n * without relying on localStorage state.\n */\n\nimport React, { useEffect } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\nimport { useVideos } from '../../core/hooks/useVideos';\nimport { useChannels } from '../../core/hooks/useChannels';\nimport { DetailsLayout } from './DetailsLayout';\nimport { Loader2 } from 'lucide-react';\n\nexport const DetailsPage: React.FC = () => {\n    // Extract both channelId and videoId from URL for full deep linking support\n    const { channelId, videoId } = useParams<{ channelId: string; videoId: string }>();\n    const navigate = useNavigate();\n    const { user } = useAuth();\n    const { setCurrentChannel } = useChannelStore();\n    const channelsQuery = useChannels(user?.uid || '');\n    const channels = channelsQuery.data || [];\n\n    // Use channelId from URL for fetching videos (enables deep linking)\n    const { videos, isLoading } = useVideos(user?.uid || '', channelId || '');\n\n    // Auto-set currentChannel from URL if not already set or different\n    // This ensures sidebar and other components sync with the URL\n    useEffect(() => {\n        if (channelId && channels.length > 0) {\n            const urlChannel = channels.find((c: { id: string }) => c.id === channelId);\n            if (urlChannel) {\n                setCurrentChannel(urlChannel);\n            }\n        }\n    }, [channelId, channels, setCurrentChannel]);\n\n    const video = videos.find(v => v.id === videoId);\n\n    // Loading state\n    if (isLoading) {\n        return (\n            <div className=\"flex-1 flex items-center justify-center\">\n                <Loader2 className=\"w-8 h-8 animate-spin text-text-secondary\" />\n            </div>\n        );\n    }\n\n    // Video not found\n    if (!video) {\n        return (\n            <div className=\"flex-1 flex flex-col items-center justify-center gap-4\">\n                <h1 className=\"text-2xl font-semibold text-text-primary\">Video not found</h1>\n                <p className=\"text-text-secondary\">The video you're looking for doesn't exist.</p>\n                <button\n                    onClick={() => navigate('/')}\n                    className=\"px-4 py-2 bg-white text-black rounded-full font-medium hover:bg-gray-200 transition-colors\"\n                >\n                    Go Home\n                </button>\n            </div>\n        );\n    }\n\n    return <DetailsLayout video={video} />;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/DetailsSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Packaging/PackagingNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Packaging/SidebarVersionItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/SidebarNavHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/SidebarNavItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/SidebarVideoPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Traffic/SnapshotContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Traffic/TrafficNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Traffic/components/PackagingSnapshotTooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Traffic/components/SidebarSnapshotItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Traffic/components/TrafficSidebarNicheList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Traffic/hooks/useTrafficVersions.ts","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `getVirtualVersionSnapshots`, but the source dependencies were [versions, snapshots, activeVersion, isVideoPublished]. Inferred different dependency than source.\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/Traffic/hooks/useTrafficVersions.ts:52:36\n   50 |     };\n   51 |\n>  52 |     const sortedVersions = useMemo(() => {\n      |                                    ^^^^^^^\n>  53 |         const packagingVersionSet = new Set(versions.map(v => v.versionNumber));\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  54 |         const snapshotVersionSet = new Set(snapshots.map(s => s.version));\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 302 |         return sortedResults;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 303 |     }, [versions, snapshots, activeVersion, isVideoPublished]);\n      | ^^^^^^ Could not preserve existing manual memoization\n  304 |\n  305 |     return {\n  306 |         sortedVersions,","line":52,"column":36,"nodeType":null,"endLine":303,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3072,3075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3072,3075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8096,8099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8096,8099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'getVirtualVersionSnapshots'. Either include it or remove the dependency array.","line":303,"column":8,"nodeType":"ArrayExpression","endLine":303,"endColumn":62,"suggestions":[{"desc":"Update the dependencies array to be: [versions, snapshots, getVirtualVersionSnapshots, activeVersion]","fix":{"range":[14188,14242],"text":"[versions, snapshots, getVirtualVersionSnapshots, activeVersion]"}}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react';\nimport type { TrafficSnapshot } from '../../../../../core/types/traffic';\nimport type { PackagingVersion as PackagingVersionType } from '../../../../../core/types/versioning';\n\ninterface UseTrafficVersionsProps {\n    versions: PackagingVersionType[];\n    snapshots: TrafficSnapshot[];\n    activeVersion: number | 'draft';\n    isVideoPublished: boolean;\n}\n\nexport const useTrafficVersions = ({\n    versions,\n    snapshots,\n    activeVersion,\n    isVideoPublished\n}: UseTrafficVersionsProps) => {\n\n    // Helper: Get snapshots for a specific virtual period\n    const getVirtualVersionSnapshots = (version: number, start: number, end?: number | null): TrafficSnapshot[] => {\n        return snapshots.filter(s => {\n            if (s.version !== version) return false;\n            // Strict timestamp check: must be >= start AND (if end exists) <= end\n            // EXCEPTION: If end is null/undefined, we accept all future snapshots (e.g. for active version)\n            // BUT: For historical versions, we usually pass an 'end'.\n            // To support \"late-arriving\" snapshots for the LATEST period of a historical version,\n            // we should interpret the 'end' parameter carefully.\n            // If the caller passes 'end', we respect it. \n            // The Logic fix needs to be passed in from the caller (the loop below).\n\n            const matchesStart = s.timestamp >= (start - 5000);\n            const matchesEnd = end ? s.timestamp <= (end + 5000) : true;\n            return matchesStart && matchesEnd;\n        }).sort((a, b) => b.timestamp - a.timestamp); // Latest first\n    };\n\n    // Helper: Format date for tooltips\n    const formatSnapshotDate = (timestamp: number) => {\n        const date = new Date(timestamp);\n        const display = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n        const tooltip = date.toLocaleString('en-US', {\n            month: 'short',\n            day: 'numeric',\n            year: 'numeric',\n            hour: 'numeric',\n            minute: '2-digit',\n            hour12: true\n        });\n        return { display, tooltip };\n    };\n\n    const sortedVersions = useMemo(() => {\n        const packagingVersionSet = new Set(versions.map(v => v.versionNumber));\n        const snapshotVersionSet = new Set(snapshots.map(s => s.version));\n\n        // Find versions that exist in snapshots but NOT in packaging history (deleted versions)\n        const deletedVersionNumbers = [...snapshotVersionSet].filter(v => !packagingVersionSet.has(v));\n\n        // Create placeholders for deleted versions\n        const deletedVersions: PackagingVersionType[] = deletedVersionNumbers.map(vNum => ({\n            versionNumber: vNum,\n            startDate: 0,\n            endDate: null,\n            revision: 0,\n            checkins: [],\n            // Minimal mock of configurationSnapshot to satisfy type\n            configurationSnapshot: {\n                title: '',\n                description: '',\n                tags: [],\n                coverImage: null\n            } as any,\n            // We'll rely on snapshots[].packagingSnapshot for deleted versions' metadata\n            activePeriods: []\n        }));\n\n        // Combine all raw versions\n        const allVersions = [...versions, ...deletedVersions];\n\n        // Virtual Expansion Helper\n        const virtualList: Array<{\n            original: PackagingVersionType;\n            displayVersion: number;\n            effectiveDate: number;\n            periodStart: number;\n            periodEnd?: number | null;\n            isRestored: boolean;\n            restorationIndex?: number;\n            arrayIndex: number;\n            key: string;\n            tooltip: string;\n            isDeleted?: boolean;\n        }> = [];\n\n        // 0. Pre-calculate GLOBAL ACTIVE TIMELINE\n        // We need this to determine if a gap between two periods of Version X\n        // was filled by Version Y (Intervention) or was just empty (Draft).\n        const globalActivePeriods: Array<{\n            version: number;\n            start: number;\n            end: number | null;\n        }> = [];\n\n        allVersions.forEach(v => {\n            if (v.activePeriods && v.activePeriods.length > 0) {\n                v.activePeriods.forEach(p => globalActivePeriods.push({\n                    version: v.versionNumber,\n                    start: p.startDate,\n                    end: p.endDate\n                }));\n            } else if (v.startDate) {\n                globalActivePeriods.push({\n                    version: v.versionNumber,\n                    start: v.startDate,\n                    end: v.endDate || null\n                });\n            }\n        });\n\n        allVersions.forEach(v => {\n            const snapshotsForVersion = snapshots.filter(s => s.version === v.versionNumber);\n\n            if (v.activePeriods && v.activePeriods.length > 0) {\n                // COALESCE CONTIGUOUS PERIODS\n                // Logic: Gap between Period A (end T1) and Period B (start T2).\n                // If ANY OTHER version was active in [T1, T2], then we SPLIT.\n                // If NO other version was active (Draft mode), we MERGE.\n                const sortedPeriods = [...v.activePeriods].sort((a, b) => a.startDate - b.startDate);\n                const coalescedPeriods: { startDate: number; endDate: number | null }[] = [];\n\n                if (sortedPeriods.length > 0) {\n                    let current = { ...sortedPeriods[0] };\n\n                    for (let i = 1; i < sortedPeriods.length; i++) {\n                        const next = sortedPeriods[i];\n\n                        // Check if we should merge\n                        // Condition: current is closed (has endDate), and next follows it.\n                        if (current.endDate !== null) {\n                            const gapStart = current.endDate;\n                            const gapEnd = next.startDate;\n\n                            // Find INTERVENING version\n                            // A version V' (V' != V) is intervening if it has a period that OVERLAPS the gap.\n                            // Gap is [gapStart, gapEnd].\n                            // Intersection: Max(StartA, StartB) < Min(EndA, EndB)\n                            const isInterrupted = globalActivePeriods.some(other => {\n                                if (other.version === v.versionNumber) return false;\n\n                                const otherEnd = other.end || Date.now(); // Treat active as NOW\n                                // Check overlap with gap [gapStart, gapEnd]\n                                // Note: Gap might be 0 length or negative if data is weird, but usually positive.\n                                const overlapStart = Math.max(gapStart, other.start);\n                                const overlapEnd = Math.min(gapEnd, otherEnd);\n\n                                // Significant overlap (> 1 min) to avoid noise? \n                                // Or strict overlap? Let's use strict > 1000ms to be safe.\n                                return overlapEnd - overlapStart > 1000;\n                            });\n\n                            if (!isInterrupted) {\n                                // MERGE: No other version interrupted, so it was just \"Draft\" state.\n                                current.endDate = next.endDate;\n                            } else {\n                                // SPLIT: Another version was active in between.\n                                coalescedPeriods.push(current);\n                                current = { ...next };\n                            }\n                        } else {\n                            // Current is open-ended (should be last, but if list is weird)\n                            coalescedPeriods.push(current);\n                            current = { ...next };\n                        }\n                    }\n                    coalescedPeriods.push(current);\n                }\n\n                // Multiple periods (Restored or Coalesced)\n                coalescedPeriods.forEach((period: any, index: number) => {\n                    const versionSnapshots = getVirtualVersionSnapshots(v.versionNumber, period.startDate, period.endDate);\n                    const isActive = !period.endDate;\n\n                    // GHOST FILTER REFINED\n                    if (!isActive && versionSnapshots.length === 0) return;\n\n                    // Restoration count: newest is at index 0\n                    const rIndex = (v.activePeriods!.length - 1) - index; // This index might be approximated if we merged\n\n                    const startStr = formatSnapshotDate(period.startDate).display;\n                    const endStr = period.endDate ? formatSnapshotDate(period.endDate).display : null;\n                    const tooltip = endStr\n                        ? `Active: ${startStr}  ${endStr}`\n                        : `Active since ${startStr}`;\n\n                    // Respect true end date from data\n                    virtualList.push({\n                        original: v,\n                        displayVersion: v.versionNumber,\n                        effectiveDate: period.startDate as number,\n                        periodStart: period.startDate as number,\n                        periodEnd: period.endDate,\n                        isRestored: rIndex > 0, // Simplified: if we have multiple periods remaining, older ones are 'restored'\n                        restorationIndex: rIndex > 0 ? rIndex : undefined,\n                        arrayIndex: index,\n                        key: `${v.versionNumber}-${index}`,\n                        tooltip\n                    });\n                });\n            } else if (v.startDate !== 0) {\n                // Single period (standard) or legacy version without activePeriods\n                const versionSnapshots = getVirtualVersionSnapshots(v.versionNumber, v.startDate || 0, v.endDate);\n                const isActive = v.versionNumber === activeVersion;\n\n                // GHOST FILTER: Hide if inactive AND has no data\n                if (!isActive && versionSnapshots.length === 0) return;\n\n                // Generate Tooltip\n                const startStr = formatSnapshotDate(v.startDate || 0).display;\n                const endStr = v.endDate ? formatSnapshotDate(v.endDate).display : null;\n                const tooltip = endStr\n                    ? `Active: ${startStr}  ${endStr}`\n                    : `Active since ${startStr}`;\n\n                virtualList.push({\n                    original: v,\n                    displayVersion: v.versionNumber,\n                    effectiveDate: (v.startDate || 0) as number,\n                    periodStart: (v.startDate || 0) as number,\n                    periodEnd: v.endDate ?? null, // Was hardcoded to null\n                    isRestored: false,\n                    arrayIndex: 0,\n                    key: `${v.versionNumber}-0`,\n                    tooltip\n                });\n            } else if (snapshotsForVersion.length > 0) {\n                // DELETED VERSION LOGIC:\n                // Group snapshots based on their PRESERVED period metadata\n                const periodsMap = new Map<string, { start: number; end: number | null; snapshots: TrafficSnapshot[] }>();\n\n                snapshotsForVersion.forEach(s => {\n                    const groupKey = `${s.packagingSnapshot?.periodStart}-${s.packagingSnapshot?.periodEnd}`;\n                    if (!periodsMap.has(groupKey)) {\n                        periodsMap.set(groupKey, {\n                            start: s.packagingSnapshot?.periodStart || 0,\n                            end: s.packagingSnapshot?.periodEnd || null,\n                            snapshots: []\n                        });\n                    }\n                    periodsMap.get(groupKey)!.snapshots.push(s);\n                });\n\n\n                const sortedPeriods = [...periodsMap.values()].sort((a, b) => b.start - a.start);\n\n                sortedPeriods.forEach((period, index) => {\n                    const startStr = formatSnapshotDate(period.start).display;\n                    const endStr = period.end ? formatSnapshotDate(period.end).display : null;\n                    const tooltip = endStr\n                        ? `Active: ${startStr}  ${endStr}`\n                        : `Active since ${startStr}`;\n\n                    const isLatestCapturedPeriod = index === 0;\n\n                    virtualList.push({\n                        original: v,\n                        displayVersion: v.versionNumber,\n                        effectiveDate: period.start,\n                        periodStart: period.start,\n                        periodEnd: isLatestCapturedPeriod ? null : period.end,\n                        isRestored: sortedPeriods.length > 1 && index < sortedPeriods.length - 1,\n                        restorationIndex: sortedPeriods.length > 1 ? (sortedPeriods.length - 1 - index) : undefined,\n                        arrayIndex: index,\n                        key: `${v.versionNumber}-${index}-deleted`,\n                        tooltip,\n                        isDeleted: true // Explicitly track deleted state\n                    });\n                });\n            }\n        });\n\n        // 2. Count frequencies for conditional badge display\n        const versionCounts: Record<number, number> = {};\n        virtualList.forEach(item => {\n            versionCounts[item.displayVersion] = (versionCounts[item.displayVersion] || 0) + 1;\n        });\n\n        // 3. Final Sort & Decoration\n        const sortedResults = [...virtualList].sort((a, b) => {\n            // Priority 1: Check if this specific PERIOD is active\n            const isActiveA = a.displayVersion === activeVersion && !a.periodEnd;\n            const isActiveB = b.displayVersion === activeVersion && !b.periodEnd;\n\n            if (isActiveA && !isActiveB) return -1;\n            if (!isActiveA && isActiveB) return 1;\n\n            return b.effectiveDate - a.effectiveDate;\n        }).map(item => ({\n            ...item,\n            showRestored: versionCounts[item.displayVersion] > 1\n        }));\n\n        return sortedResults;\n    }, [versions, snapshots, activeVersion, isVideoPublished]);\n\n    return {\n        sortedVersions,\n        getVirtualVersionSnapshots,\n        formatSnapshotDate\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/Sidebar/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/components/DetailsModals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/hooks/useDraftDetection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/hooks/useModalState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/hooks/useSnapshotManagement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/hooks/useVersionManagement.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1548,1551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1548,1551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4285,4288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4285,4288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4751,4754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4751,4754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4759,4762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4759,4762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5146,5149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5146,5149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5355,5358],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5355,5358],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5363,5366],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5363,5366],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `queryClient`, but the source dependencies were [versions, video, user, currentChannel, updateVideo, showToast, trafficState]. Inferred different dependency than source.\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/hooks/useVersionManagement.ts:144:39\n  142 |      *     traffic snapshots  packaging   .\n  143 |      */\n> 144 |     const confirmDelete = useCallback(async (versionNumber: number) => {\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 145 |         // GROUP DELETION LOGIC:\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 146 |         // Find all versions that belong to the same \"visual group\" (same canonical ID)\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 272 |         }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 273 |     }, [versions, video, user, currentChannel, updateVideo, showToast, trafficState]);\n      | ^^^^^^ Could not preserve existing manual memoization\n  274 |\n  275 |     /**\n  276 |      *   ","line":144,"column":39,"nodeType":null,"endLine":273,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6204,6207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6204,6207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6490,6493],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6490,6493],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6624,6627],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6624,6627],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":167,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7148,7151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7148,7151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":171,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7350,7353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7350,7353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":174,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7532,7535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7532,7535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7751,7754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7751,7754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'queryClient'. Either include it or remove the dependency array.","line":273,"column":8,"nodeType":"ArrayExpression","endLine":273,"endColumn":85,"suggestions":[{"desc":"Update the dependencies array to be: [versions, user.uid, currentChannel.id, video.id, video.currentPackagingVersion, video.packagingRevision, trafficState, queryClient, showToast]","fix":{"range":[12269,12346],"text":"[versions, user.uid, currentChannel.id, video.id, video.currentPackagingVersion, video.packagingRevision, trafficState, queryClient, showToast]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":289,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12976,12979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12976,12979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":304,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":304,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13709,13712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13709,13712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":304,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":304,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13723,13726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13723,13726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":305,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13821,13824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13821,13824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":308,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14037,14040],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14037,14040],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14543,14546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14543,14546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":355,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16388,16391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16388,16391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport type { VideoDetails } from '../../../core/utils/youtubeApi';\nimport type { SnapshotRequestParams } from '../types/versionManagement';\nimport { VersionService } from '../services/VersionService';\nimport { TrafficDataService } from '../../../core/services/traffic/TrafficDataService';\nimport { VideoService } from '../../../core/services/videoService';\nimport type { TrafficData } from '../../../core/types/traffic';\nimport type { PackagingVersion } from '../../../core/types/versioning';\nimport { db } from '../../../config/firebase';\nimport { writeBatch } from 'firebase/firestore';\n\ninterface VersionsHookState {\n    packagingHistory: PackagingVersion[];\n    activeVersion: number | 'draft';\n    viewingVersion: number | 'draft';\n    viewingPeriodIndex?: number;\n    switchToVersion: (version: number | 'draft', periodIndex?: number) => void;\n    deleteVersion: (version: number) => void;\n    setActiveVersion: (version: number | 'draft') => void;\n    restoreVersion: (version: number, closingSnapshotId?: string | null) => void;\n    setHasDraft: (has: boolean) => void;\n}\n\ninterface TrafficHookState {\n    trafficData: TrafficData | null;\n    updateLocalData?: (data: TrafficData) => void;\n}\n\ninterface UseVersionManagementProps {\n    versions: VersionsHookState;\n    isFormDirty: boolean;\n    video: VideoDetails;\n    user: { uid: string } | null;\n    currentChannel: { id: string } | null;\n    updateVideo: (params: { videoId: string; updates: any }) => Promise<void>;\n    showToast: (message: string, type: 'success' | 'error') => void;\n    setSelectedSnapshot: (id: string | null) => void;\n    activeTab: 'packaging' | 'traffic';\n    selectedSnapshot: string | null;\n    trafficState: TrafficHookState;\n    onOpenSwitchConfirm: (targetVersion: number | 'draft') => void;\n    onOpenDeleteConfirm: (versionNumber: number, snapshotCount: number, totalViews: number, versionLabel?: string, isStacked?: boolean) => void;\n    onOpenSnapshotRequest: (params: SnapshotRequestParams) => void;\n}\n\n/**\n *     (, , ).\n *  -  DetailsLayout.\n */\nexport const useVersionManagement = ({\n    versions,\n    isFormDirty,\n    video,\n    user,\n    currentChannel,\n    updateVideo,\n    showToast,\n    setSelectedSnapshot,\n    activeTab,\n    selectedSnapshot,\n    trafficState,\n    onOpenSwitchConfirm,\n    onOpenDeleteConfirm,\n    onOpenSnapshotRequest\n}: UseVersionManagementProps) => {\n    // Initialize query client for cache invalidation\n    const queryClient = useQueryClient();\n\n\n    /**\n     *      sidebar\n     */\n    const handleVersionClick = useCallback((versionNumber: number | 'draft', periodIndex?: number) => {\n        //        selected snapshot\n        if (versionNumber === versions.viewingVersion && periodIndex === versions.viewingPeriodIndex) {\n            if (activeTab === 'traffic' && selectedSnapshot) {\n                setSelectedSnapshot(null);\n            }\n            return;\n        }\n\n        if (isFormDirty) {\n            //       confirmation\n            onOpenSwitchConfirm(versionNumber);\n        } else {\n            //  selected snapshot\n            setSelectedSnapshot(null);\n            //  \n            versions.switchToVersion(versionNumber, periodIndex);\n        }\n    }, [versions, isFormDirty, activeTab, selectedSnapshot, setSelectedSnapshot, onOpenSwitchConfirm]);\n\n    /**\n     *    ( discard changes)\n     */\n    const confirmSwitch = useCallback((targetVersion: number | 'draft') => {\n        setSelectedSnapshot(null);\n        versions.switchToVersion(targetVersion);\n    }, [versions, setSelectedSnapshot]);\n\n    /**\n     *   .\n     *   traffic snapshots    (   ).\n     */\n    const handleDeleteVersion = useCallback((versionNumber: number, versionLabel?: string) => {\n        // ,     \n        const relatedSnapshots = trafficState.trafficData?.snapshots?.filter(\n            (s: any) => s.version === versionNumber\n        ) || [];\n\n        // Legacy Stack Detection removed as we now do Group Deletion\n        // Calculate \"views generated by this version\"\n        // Logic: (Latest snapshot total views) - (Previous version's latest snapshot total views)\n        let totalViews = 0;\n\n        if (relatedSnapshots.length > 0) {\n            // Get latest snapshot for current version\n            const latestSnapshot = relatedSnapshots.sort((a: any, b: any) => b.timestamp - a.timestamp)[0];\n            const currentTotalViews = latestSnapshot.summary?.totalViews || 0;\n\n            // Get previous version's latest snapshot view count\n            // Find snapshots for version < versionNumber\n            const allSnapshots = trafficState.trafficData?.snapshots || [];\n            const previousVersionSnapshots = allSnapshots.filter((s: any) => s.version < versionNumber);\n\n            let previousTotalViews = 0;\n            if (previousVersionSnapshots.length > 0) {\n                const latestPrevSnapshot = previousVersionSnapshots.sort((a: any, b: any) => b.timestamp - a.timestamp)[0];\n                previousTotalViews = latestPrevSnapshot.summary?.totalViews || 0;\n            }\n\n            // Delta\n            totalViews = Math.max(0, currentTotalViews - previousTotalViews);\n        }\n\n        onOpenDeleteConfirm(versionNumber, relatedSnapshots.length, totalViews, versionLabel);\n    }, [trafficState, onOpenDeleteConfirm]);\n\n    /**\n     *   .\n     *     traffic snapshots  packaging   .\n     */\n    const confirmDelete = useCallback(async (versionNumber: number) => {\n        // GROUP DELETION LOGIC:\n        // Find all versions that belong to the same \"visual group\" (same canonical ID)\n        // and delete them all together.\n        const targetVersionData = versions.packagingHistory.find((v: any) => v.versionNumber === versionNumber);\n        let versionsToDelete = [versionNumber];\n\n        if (targetVersionData) {\n            const canonicalId = targetVersionData.cloneOf || targetVersionData.versionNumber;\n            const siblings = versions.packagingHistory.filter((v: any) =>\n                (v.cloneOf || v.versionNumber) === canonicalId\n            );\n            versionsToDelete = siblings.map((v: any) => v.versionNumber);\n        }\n\n        // ATOMIC ATTEMPT\n        if (user?.uid && currentChannel?.id && video.id) {\n            const batch = writeBatch(db);\n            const videoRef = VideoService.getVideoDocRef(user.uid, currentChannel.id, video.id);\n            const trafficRef = TrafficDataService.getMainDocRef(user.uid, currentChannel.id, video.id);\n\n            // 1. Prepare Traffic Updates if needed\n            const snapshotsForVersions = trafficState.trafficData?.snapshots?.filter(\n                (s: any) => versionsToDelete.includes(s.version)\n            ) || [];\n\n            if (snapshotsForVersions.length > 0) {\n                const updatedSnapshots = trafficState.trafficData.snapshots.map((s: any) => {\n                    if (versionsToDelete.includes(s.version)) {\n                        const versionData = versions.packagingHistory.find(\n                            (v: any) => v.versionNumber === s.version\n                        );\n\n                        // FIND THE SPECIFIC PERIOD this snapshot belongs to\n                        const period = versionData?.activePeriods?.find((p: any) =>\n                            s.timestamp >= (p.startDate - 5000) &&\n                            (!p.endDate || s.timestamp <= (p.endDate + 5000))\n                        );\n\n\n                        const packagingSnapshot = versionData?.configurationSnapshot;\n\n                        if (packagingSnapshot) {\n                            return {\n                                ...s,\n                                packagingSnapshot: {\n                                    title: packagingSnapshot.title,\n                                    description: packagingSnapshot.description,\n                                    tags: packagingSnapshot.tags,\n                                    coverImage: packagingSnapshot.coverImage,\n                                    abTestTitles: packagingSnapshot.abTestTitles,\n                                    abTestThumbnails: packagingSnapshot.abTestThumbnails,\n                                    abTestResults: packagingSnapshot.abTestResults,\n                                    localizations: packagingSnapshot.localizations,\n                                    cloneOf: versionData.cloneOf,\n                                    restoredAt: versionData.restoredAt,\n                                    // NEW: Preserve the specific period context\n                                    periodStart: period?.startDate || versionData.startDate,\n                                    periodEnd: period?.endDate || (versionData.endDate ?? null)\n                                },\n                                isPackagingDeleted: true\n                            };\n                        }\n                    }\n                    return s;\n                });\n\n                // Sanitize whole object before batching to ensure NO undefined values\n                const fullTrafficData = {\n                    ...(trafficState.trafficData || {}),\n                    snapshots: updatedSnapshots,\n                    lastUpdated: Date.now()\n                } as TrafficData;\n\n                const sanitizedTrafficData = TrafficDataService.sanitize(fullTrafficData);\n\n                batch.set(trafficRef, sanitizedTrafficData, { merge: true });\n\n\n                // OPTIMISTIC UPDATE:\n                // Update the local state immediately via the exposed method from useTrafficData.\n                // This ensures the UI reflects the added metadata (periodStart/End) before the \n                // next fetch cycle, preventing \"stale\" snapshots from being rendered incorrectly.\n                if (trafficState.updateLocalData) {\n                    trafficState.updateLocalData(sanitizedTrafficData);\n                }\n            }\n\n            // 2. Prepare Video Updates\n            const deleteData = VersionService.calculateDeleteVersionData(\n                versionsToDelete,\n                versions.packagingHistory,\n                typeof versions.activeVersion === 'number' ? versions.activeVersion : (video.currentPackagingVersion || 0)\n            );\n\n            batch.update(videoRef, {\n                ...deleteData.rollbackUpdates,\n                packagingHistory: deleteData.updatedHistory,\n                currentPackagingVersion: deleteData.newCurrentVersion,\n                isDraft: deleteData.willHaveDraft,\n                packagingRevision: (video.packagingRevision || 0) + 1\n            });\n\n            try {\n                // 3. Commit Batch\n                await batch.commit();\n\n                // 4. Update local state\n                versions.deleteVersion(versionNumber);\n                if (deleteData.newCurrentVersion) {\n                    versions.setActiveVersion(deleteData.newCurrentVersion);\n                }\n                if (deleteData.newActiveVersion !== undefined) {\n                    versions.setActiveVersion(deleteData.newActiveVersion);\n                    if (versionsToDelete.includes(versions.viewingVersion)) {\n                        versions.switchToVersion(deleteData.newActiveVersion);\n                    }\n                }\n\n                // 5. Invalidate Queries\n                queryClient.invalidateQueries({ queryKey: ['video', video.id] });\n                queryClient.invalidateQueries({ queryKey: ['traffic', video.id] });\n\n                showToast(`Version group deleted`, 'success');\n            } catch (error) {\n                console.error('Failed to commit atomic deletion batch:', error);\n                showToast('Failed to delete version', 'error');\n            }\n        }\n    }, [versions, video, user, currentChannel, updateVideo, showToast, trafficState]);\n\n    /**\n     *   \n     */\n    /**\n     *    (Immutable Data Pattern).\n     *    ()   .\n     */\n    const handleRestoreVersion = useCallback(async (versionToRestore: number) => {\n        // IMMUTABLE RESTORE LOGIC (Clone/Alias Strategy)\n        // We now always use cloning when restoring from history to maintain data integrity\n        // and separate traffic snapshots for each activation period.\n\n        // 1.    \n        const targetVersionData = versions.packagingHistory.find(\n            (v: any) => v.versionNumber === versionToRestore\n        );\n\n        if (!targetVersionData || !targetVersionData.configurationSnapshot) {\n            showToast('Version data not found', 'error');\n            return;\n        }\n\n        // STEP:     Snapshot Request\n        let activeVersionToSnapshot: number | null = null;\n        if (typeof versions.activeVersion === 'number') {\n            activeVersionToSnapshot = versions.activeVersion;\n        } else if (versions.activeVersion === 'draft') {\n            // Fallback logic SAME AS usePackagingActions to be consistent\n            if (versions.packagingHistory.length > 0) {\n                const latestByDate = versions.packagingHistory.reduce((best: any, current: any) => {\n                    const currentStart = current.activePeriods?.reduce((max: number, p: any) =>\n                        (p.startDate || 0) > (max || 0) ? (p.startDate || 0) : (max || 0)\n                        , 0) || 0;\n                    const bestStart = best?.activePeriods?.reduce((max: number, p: any) =>\n                        (p.startDate || 0) > (max || 0) ? (p.startDate || 0) : (max || 0)\n                        , 0) || 0;\n                    return currentStart > bestStart ? current : best;\n                }, null);\n\n                if (latestByDate && (latestByDate.activePeriods?.length || 0) > 0) {\n                    activeVersionToSnapshot = latestByDate.versionNumber;\n                } else {\n                    activeVersionToSnapshot = Math.max(...versions.packagingHistory.map((v: any) => v.versionNumber));\n                }\n            }\n        }\n\n        // 2.     \n        let closingSnapshotId: string | null | undefined = null;\n\n        //     (   ,   ),   \n        if (activeVersionToSnapshot && activeVersionToSnapshot !== versionToRestore && video.publishedVideoId) {\n            const result = await new Promise<string | null | undefined>((resolve) => {\n                onOpenSnapshotRequest({\n                    versionToRestore, // Pass for context if needed, though mostly for legacy logic\n                    isForCreateVersion: false, // It IS for restore, but we use 'false' to trigger restore callback flow? \n                    // ACTUALLY: The legacy hook logic is complex. \n                    // Let's keep it simple: We use a Promise here, same as createVersion.\n                    resolveCallback: (id) => resolve(id),\n                    versionNumber: activeVersionToSnapshot!,\n                    context: 'restore'\n                });\n            });\n\n            if (result === undefined) return; // Cancelled\n            closingSnapshotId = result;\n        }\n\n\n        // 3. Update Local State (adds new active period to existing version)\n        // Pass closingSnapshotId to close the PREVIOUS active period\n        versions.restoreVersion(versionToRestore, closingSnapshotId);\n\n        // ... (rest of the restore logic updates UI state)\n        versions.setActiveVersion(versionToRestore);\n        versions.setHasDraft(false);\n\n        // 4. Update Firestore\n        // We need to calculate the updated history with the new period added to the target version\n        // and the previous active version closed.\n        const updatedHistory = versions.packagingHistory.map((v: any) => {\n            if (v.versionNumber === versionToRestore) {\n                return VersionService.addNewActivePeriod(VersionService.closeAllPeriods(v, closingSnapshotId));\n            }\n            return VersionService.closeAllPeriods(v, closingSnapshotId);\n        });\n\n        // 5.   Firestore\n        if (user?.uid && currentChannel?.id && video.id) {\n            try {\n                await updateVideo({\n                    videoId: video.id,\n                    updates: {\n                        packagingHistory: updatedHistory,\n                        activeVersion: versionToRestore,\n                        isDraft: false,\n                        //       ( UI )\n                        title: targetVersionData.configurationSnapshot.title,\n                        description: targetVersionData.configurationSnapshot.description,\n                        tags: targetVersionData.configurationSnapshot.tags,\n                        thumbnailUrl: targetVersionData.configurationSnapshot.coverImage, // Changed from customImage\n                        abTestTitles: targetVersionData.configurationSnapshot.abTestTitles,\n                        abTestThumbnails: targetVersionData.configurationSnapshot.abTestThumbnails,\n                        localizations: targetVersionData.configurationSnapshot.localizations\n                    }\n                });\n                // 6. Toast\n                showToast(`Restored v.${versionToRestore}`, 'success');\n            } catch (error) {\n                console.error(\"Failed to update video history on restore:\", error);\n                showToast(\"Failed to save restore to server\", \"error\");\n            }\n        }\n    }, [video, versions, user, currentChannel, updateVideo, showToast, onOpenSnapshotRequest]);\n\n    return {\n        handleVersionClick,\n        confirmSwitch,\n        handleDeleteVersion,\n        confirmDelete,\n        handleRestoreVersion\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/services/VersionService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/services/VersionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/PackagingTab.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'formState' and 'versionState'. Either include them or remove the dependency array.","line":159,"column":8,"nodeType":"ArrayExpression","endLine":166,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [versionState.viewingVersion, video, formState.isDirty, formState.incomingVideoMatchesSnapshot, formState.resetToSnapshot, versionState.getVersionSnapshot, versionState, formState]","fix":{"range":[7578,7787],"text":"[versionState.viewingVersion, video, formState.isDirty, formState.incomingVideoMatchesSnapshot, formState.resetToSnapshot, versionState.getVersionSnapshot, versionState, formState]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\nimport { type VideoDetails } from '../../../../core/utils/youtubeApi';\nimport type { TrafficData } from '../../../../core/types/traffic';\nimport { PackagingForm } from './components/PackagingForm';\nimport { VideoPreviewCard } from './components/VideoPreviewCard';\nimport { LanguageTabs } from '../../../../features/Video/LanguageTabs';\nimport { ABTestingModal } from '../../../../components/Shared/ABTesting';\nimport { Button } from '../../../../components/ui/atoms/Button';\nimport { useChannelStore } from '../../../../core/stores/channelStore';\nimport { useAuth } from '../../../../core/hooks/useAuth';\nimport { uploadImageToStorage } from '../../../../core/services/storageService';\nimport { resizeImageToBlob } from '../../../../core/utils/imageUtils';\nimport { usePackagingLocalization } from './hooks/usePackagingLocalization';\nimport { usePackagingFormState } from './hooks/usePackagingFormState';\nimport { useABTesting } from './hooks/useABTesting';\nimport { usePackagingActions } from './hooks/usePackagingActions';\nimport { useVideos } from '../../../../core/hooks/useVideos';\nimport { useThumbnailActions } from '../../../../core/hooks/useThumbnailActions';\nimport {\n    type VersionState,\n    DEFAULT_TAGS,\n    DEFAULT_LOCALIZATIONS,\n    DEFAULT_AB_RESULTS,\n    DEFAULT_COVER_HISTORY\n} from './types';\n\n// ============================================================================\n// COMPONENT PROPS\n// ============================================================================\n\ninterface PackagingTabProps {\n    video: VideoDetails;\n    versionState: VersionState;\n    onDirtyChange: (isDirty: boolean) => void;  // Sync dirty state to parent for version switch confirmation\n    onRestoreVersion?: (version: number) => void; // Callback for restore version button\n    onRequestSnapshot?: (versionNumber: number) => Promise<string | null | undefined>; // Callback for CSV snapshot request\n    trafficData?: TrafficData | null; // Traffic data for finding snapshots\n}\n\nexport const PackagingTab: React.FC<PackagingTabProps> = ({ video, versionState, onDirtyChange, onRestoreVersion, onRequestSnapshot, trafficData }) => {\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { videos } = useVideos(user?.uid || '', currentChannel?.id || '');\n    const { handleLikeThumbnail, handleRemoveThumbnail } = useThumbnailActions(video.id);\n    const sentinelRef = useRef<HTMLDivElement>(null);\n    // Detect scroll for sticky header shadow\n    const [isScrolled, setIsScrolled] = useState(false);\n\n    // Is the user viewing an old version (read-only)?\n    const isViewingOldVersion = versionState.viewingVersion !== 'draft' &&\n        versionState.viewingVersion !== versionState.activeVersion;\n\n    // 1. Hook: Localization State\n    const localization = usePackagingLocalization({\n        initialTitle: video.title || '',\n        initialDescription: video.description || '',\n        initialTags: video.tags || DEFAULT_TAGS,\n        initialLocalizations: video.localizations || DEFAULT_LOCALIZATIONS\n    });\n\n    // 2. Hook: A/B Testing State\n    const abTesting = useABTesting({\n        initialTitles: video.abTestTitles || [],\n        initialThumbnails: video.abTestThumbnails || [],\n        initialResults: video.abTestResults || DEFAULT_AB_RESULTS,\n        onResultsSave: (results) => actions.handleSaveResultsOnly(results),\n        onTitleChange: (title) => localization.setTitle(title),\n        onThumbnailChange: (thumbnail) => formState.setCustomImage(thumbnail)\n    });\n\n    // 3. Hook: Form State & Dirty Checking (consolidated)\n    const formState = usePackagingFormState({\n        video,\n        isViewingOldVersion,\n        localization,\n        abTesting\n    });\n\n    // 4. Hook: Actions (Save, Versions, Clone, Restore, Languages)\n    const actions = usePackagingActions({\n        video,\n        versionState,\n        localization,\n        formState,\n        abTesting,\n        onRequestSnapshot,\n        trafficData\n    });\n\n    // Detect scroll for sticky header shadow\n    useEffect(() => {\n        const sentinel = sentinelRef.current;\n        if (!sentinel) return;\n        const observer = new IntersectionObserver(\n            ([entry]) => setIsScrolled(!entry.isIntersecting),\n            { threshold: 0 }\n        );\n        observer.observe(sentinel);\n        return () => observer.disconnect();\n    }, []);\n\n    // Sync dirty state with parent\n    useEffect(() => {\n        onDirtyChange(formState.isDirty);\n    }, [formState.isDirty, onDirtyChange]);\n\n\n    // ============================================================================\n    // BUSINESS LOGIC: Version Loading\n    // ============================================================================\n    useEffect(() => {\n        if (versionState.viewingVersion === 'draft') {\n            // Load unsaved drafts from video prop, but only if not dirty (preserve edits)\n            if (!formState.isDirty) {\n                // Construct a snapshot from current props to check for changes\n                const snapshotFromProps = {\n                    title: video.title || '',\n                    description: video.description || '',\n                    tags: video.tags || DEFAULT_TAGS,\n                    customImage: video.customImage || '',\n                    customImageName: video.customImageName || '',\n                    customImageVersion: video.customImageVersion || 1,\n                    localizations: video.localizations || DEFAULT_LOCALIZATIONS,\n                    abTestTitles: video.abTestTitles || DEFAULT_TAGS,\n                    abTestThumbnails: video.abTestThumbnails || DEFAULT_TAGS,\n                    abTestResults: video.abTestResults || DEFAULT_AB_RESULTS as { titles: number[], thumbnails: number[] },\n                    coverHistory: video.coverHistory || DEFAULT_COVER_HISTORY\n                };\n\n                // Only update if prop data is actually different from what we last loaded\n                // to prevent infinite loops.\n                if (!formState.incomingVideoMatchesSnapshot(snapshotFromProps)) {\n                    formState.resetToSnapshot(snapshotFromProps);\n                }\n            }\n        } else {\n            // Load historical version\n            const versionSnapshot = versionState.getVersionSnapshot(versionState.viewingVersion);\n            if (versionSnapshot) {\n                const snapshot = {\n                    title: versionSnapshot.title,\n                    description: versionSnapshot.description,\n                    tags: versionSnapshot.tags || DEFAULT_TAGS,\n                    customImage: versionSnapshot.coverImage || '',\n                    customImageName: versionSnapshot.originalName || '',\n                    customImageVersion: typeof versionState.viewingVersion === 'number' ? versionState.viewingVersion : 1,\n                    localizations: versionSnapshot.localizations || DEFAULT_LOCALIZATIONS,\n                    abTestTitles: versionSnapshot.abTestTitles || DEFAULT_TAGS,\n                    abTestThumbnails: versionSnapshot.abTestThumbnails || DEFAULT_TAGS,\n                    abTestResults: versionSnapshot.abTestResults || DEFAULT_AB_RESULTS as { titles: number[], thumbnails: number[] },\n                    coverHistory: video.coverHistory || DEFAULT_COVER_HISTORY\n                };\n\n                if (!formState.incomingVideoMatchesSnapshot(snapshot)) {\n                    formState.resetToSnapshot(snapshot);\n                }\n            }\n        }\n    }, [\n        versionState.viewingVersion,\n        video,\n        formState.isDirty,\n        formState.incomingVideoMatchesSnapshot,\n        formState.resetToSnapshot,\n        versionState.getVersionSnapshot\n    ]);\n\n    // Beforeunload warning\n    useEffect(() => {\n        const handleBeforeUnload = (e: BeforeUnloadEvent) => {\n            if (formState.isDirty) {\n                e.preventDefault();\n                e.returnValue = '';\n            }\n        };\n        window.addEventListener('beforeunload', handleBeforeUnload);\n        return () => window.removeEventListener('beforeunload', handleBeforeUnload);\n    }, [formState.isDirty]);\n\n    // Auto-save metadata fields (publishedVideoId, videoRender, audioRender)\n    // These fields don't affect packaging versions, so they auto-save independently\n    useEffect(() => {\n        if (isViewingOldVersion) return;\n\n        const timer = setTimeout(() => {\n            const hasMetadataChanges =\n                formState.publishedVideoId !== (video.publishedVideoId || '') ||\n                formState.videoRender !== (video.videoRender || '') ||\n                formState.audioRender !== (video.audioRender || '');\n\n            if (hasMetadataChanges) {\n                actions.handleSaveMetadata({\n                    publishedVideoId: formState.publishedVideoId,\n                    videoRender: formState.videoRender,\n                    audioRender: formState.audioRender\n                });\n            }\n        }, 1000); // 1 second debounce\n\n        return () => clearTimeout(timer);\n    }, [\n        formState.publishedVideoId,\n        formState.videoRender,\n        formState.audioRender,\n        video.publishedVideoId,\n        video.videoRender,\n        video.audioRender,\n        isViewingOldVersion,\n        actions\n    ]);\n\n\n    // ============================================================================\n    // ACTIONS: Save / Undo / Versions\n    // ============================================================================\n    // Logic extracted to usePackagingActions hook.\n\n\n    // Derived UI State\n    const isViewingActiveVersion = versionState.viewingVersion === versionState.activeVersion;\n\n    const headerTitle = React.useMemo(() => {\n        if (versionState.viewingVersion === 'draft') {\n            return 'Video Packaging (Draft)';\n        }\n        if (typeof versionState.viewingVersion === 'number') {\n            // Use the actual version number directly.\n            // visualVersionMap logic removed to prevent re-indexing (e.g. v.5 becoming v.4 if v.3 is deleted).\n            // This ensures header matches sidebar \"v.X\".\n            return `Video Packaging v.${versionState.viewingVersion}`;\n        }\n        return 'Video Packaging';\n    }, [versionState.viewingVersion]);\n\n\n    return (\n        <div className=\"flex-1 overflow-y-auto custom-scrollbar\">\n            <div ref={sentinelRef} className=\"h-0\" />\n\n            {/* Sticky Header */}\n            <div className={`sticky top-0 z-10 px-6 py-4 transition-shadow duration-200 bg-video-edit-bg ${isScrolled ? 'shadow-[0_2px_8px_rgba(0,0,0,0.3)]' : ''}`}>\n                <div className=\"flex items-center gap-4 max-w-[1050px]\">\n                    <h1 className=\"text-2xl font-medium text-text-primary\">{headerTitle}</h1>\n\n                    {!isViewingActiveVersion && versionState.viewingVersion !== 'draft' && (\n                        <Button\n                            variant=\"outline\"\n                            size=\"sm\"\n                            onClick={() => {\n                                if (onRestoreVersion && typeof versionState.viewingVersion === 'number') {\n                                    onRestoreVersion(versionState.viewingVersion);\n                                }\n                            }}\n                            className=\"bg-[#3ea6ff]/20 hover:bg-[#3ea6ff]/30\"\n                        >\n                            Restore this version\n                        </Button>\n                    )}\n\n                    <div className=\"flex-1\" />\n\n                    <div className=\"flex-1\" />\n\n                    {/* Show actions if viewing Current OR if Editing an Old Version (Dirty) */}\n                    {(!isViewingOldVersion || formState.isDirty) && (\n                        <div className=\"flex gap-3\">\n                            <Button\n                                variant=\"secondary\"\n                                size=\"sm\"\n                                onClick={actions.handleCancel}\n                                disabled={!formState.isDirty}\n                            >\n                                Undo changes\n                            </Button>\n                            <Button\n                                variant=\"primary\"\n                                size=\"sm\"\n                                onClick={actions.handleSave}\n                                disabled={!formState.isDirty || actions.isSaving}\n                                isLoading={actions.isSavingDraft}\n                            >\n                                {formState.isDirty ? 'Save as draft' : 'Save'}\n                            </Button>\n\n                            {(formState.isDirty || versionState.viewingVersion === 'draft') && (\n                                <Button\n                                    variant=\"outline\"\n                                    size=\"sm\"\n                                    onClick={actions.handleSaveAsNewVersion}\n                                    disabled={actions.isSaving}\n                                    isLoading={actions.isSavingNewVersion}\n                                >\n                                    Save as v.{versionState.nextVisualVersionNumber}\n                                </Button>\n                            )}\n                        </div>\n                    )}\n                </div>\n            </div>\n\n            {/* Content */}\n            <div className=\"p-6\">\n                <div className=\"mb-6\">\n                    <LanguageTabs\n                        activeLanguage={localization.activeLanguage}\n                        localizations={localization.localizations}\n                        onSwitchLanguage={localization.switchLanguage} // Note: simplified direct pass\n                        onAddLanguage={actions.handleAddLanguage}\n                        onRemoveLanguage={localization.removeLanguage}\n                        savedCustomLanguages={currentChannel?.customLanguages || []}\n                        onDeleteCustomLanguage={actions.handleDeleteCustomLanguage}\n                    />\n                </div>\n\n                <div className=\"flex gap-8 max-w-[1050px] items-start\">\n                    <div className=\"flex-1 min-w-0\">\n                        <PackagingForm\n                            title={localization.title}\n                            setTitle={localization.setTitle}\n                            description={localization.description}\n                            setDescription={localization.setDescription}\n                            tags={localization.tags}\n                            setTags={localization.setTags}\n                            coverImage={formState.customImage}\n                            setCoverImage={(url, filename, version) => {\n                                formState.setCustomImage(url);\n\n                                // 1. If we have an explicit version (from Restore), use it\n                                if (version !== undefined) {\n                                    formState.setCustomImageVersion(version);\n                                } else {\n                                    // 2. New upload - calculate next version\n                                    // We must look at BOTH history AND current version to handle the race condition\n                                    // where history hasn't updated yet (from onPushToHistory).\n                                    const historyMax = formState.pendingHistory.length > 0\n                                        ? Math.max(...formState.pendingHistory.map(v => v.version))\n                                        : 0;\n                                    const currentMax = formState.customImageVersion || 0;\n\n                                    // New version is strictly higher than anything seen so far\n                                    const nextVersion = Math.max(historyMax, currentMax) + 1;\n                                    formState.setCustomImageVersion(nextVersion);\n                                }\n\n                                // 3. Update filename if provided (from Restore)\n                                if (filename) {\n                                    formState.setCustomImageName(filename);\n                                }\n                            }}\n                            onFileUpload={async (file: File) => {\n                                // Resize and compress the image\n                                const blob = await resizeImageToBlob(file, 1280, 0.7);\n                                // Create path: users/{userId}/channels/{channelId}/videos/{videoId}/{timestamp}_{filename}\n                                const timestamp = Date.now();\n                                const path = `users/${user?.uid}/channels/${currentChannel?.id}/videos/${video.id}/${timestamp}_${file.name}`;\n\n                                // Capture the real filename immediately\n                                formState.setCustomImageName(file.name);\n\n                                // Upload to Firebase Storage and return download URL\n                                return uploadImageToStorage(blob, path);\n                            }}\n                            onPushToHistory={(url) => {\n                                // Add current cover to history before it gets replaced\n                                // Use the EXISTING version number for the item being pushed to history\n                                // Do NOT calculate a new one here.\n                                formState.setPendingHistory(prev => {\n                                    // Prevent duplicates: specific check for existing URL\n                                    // We check primarily the most recent one, but also scan the whole list just in case\n                                    // to avoid any identical duplicates cluttering history.\n                                    if (prev.some(v => v.url === url)) {\n                                        return prev;\n                                    }\n\n                                    return [{\n                                        url,\n                                        version: formState.customImageVersion || 1,\n                                        timestamp: Date.now(),\n                                        originalName: formState.customImageName\n                                    }, ...prev];\n                                });\n                            }}\n                            publishedUrl={formState.publishedVideoId}\n                            setPublishedUrl={formState.setPublishedVideoId}\n                            videoRender={formState.videoRender}\n                            setVideoRender={formState.setVideoRender}\n                            audioRender={formState.audioRender}\n                            setAudioRender={formState.setAudioRender}\n                            // Allow editing even for old versions to support \"Forking\" (Save as Draft from history)\n                            // We only disable if strictly needed, but for now we want to allow edits.\n                            readOnly={false}\n\n                            // A/B Test props\n                            abTestTitles={abTesting.titles}\n                            abTestThumbnails={abTesting.thumbnails}\n                            abTestStatus=\"draft\"\n                            abTestResults={abTesting.results}\n                            onTitleABTestClick={abTesting.openFromTitle}\n                            onThumbnailABTestClick={abTesting.openFromThumbnail}\n\n                            // History Props\n                            coverHistory={formState.pendingHistory}\n                            onDeleteHistoryVersion={(ts) => {\n                                // Find version number for the timestamp to use handleRemoveThumbnail\n                                const item = formState.pendingHistory.find(v => v.timestamp === ts);\n                                if (item) {\n                                    // Remove from local state immediately for visual feedback\n                                    formState.setPendingHistory(prev => prev.filter(v => v.timestamp !== ts));\n                                    // Note: Smart storage cleanup will happen either via handleRemoveThumbnail (direct)\n                                    // or handleSave (deferred). In this modal context, we keep it as local removal\n                                    // and let handleSave handle the storage cleanup if the user clicks Save.\n                                }\n                            }}\n                            onCloneFromVersion={actions.handleCloneFromVersion}\n                            cloningVersion={actions.cloningVersion}\n                            currentVersionInfo={{\n                                // Use the explicitly tracked version from state\n                                version: formState.customImageVersion,\n                                originalName: formState.customImageName\n                            }}\n                            // Check if a clone with this thumbnail already exists\n                            checkIsCloned={(thumbnailUrl) => {\n                                return videos.some(v =>\n                                    v.isCloned &&\n                                    v.clonedFromId === video.id &&\n                                    v.customImage === thumbnailUrl\n                                );\n                            }}\n                            likedThumbnailVersions={video.likedThumbnailVersions}\n                            onLikeThumbnail={handleLikeThumbnail}\n                            onRemoveThumbnail={handleRemoveThumbnail}\n                        />\n                    </div>\n\n                    <div className=\"w-80 flex-shrink-0\">\n                        <VideoPreviewCard video={video} currentCoverImage={formState.customImage} />\n                    </div>\n                </div>\n\n                {abTesting.modalOpen && (\n                    <ABTestingModal\n                        isOpen={abTesting.modalOpen}\n                        onClose={abTesting.closeModal}\n                        initialTab={abTesting.initialTab}\n                        currentTitle={localization.title}\n                        currentThumbnail={formState.customImage}\n                        titleVariants={abTesting.titles}\n                        thumbnailVariants={abTesting.thumbnails}\n                        onSave={abTesting.saveChanges}\n                        initialResults={abTesting.results}\n                    />\n                )}\n            </div>\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/components/ABTitlesDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/components/DescriptionInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/components/PackagingForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/components/ShowMoreSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/components/TagsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/components/TitleInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/components/VideoPreviewCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/useABTesting.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/useABTesting.ts:39:37\n  37 |     // Sync state when props change (e.g. data loaded from server)\n  38 |     useEffect(() => {\n> 39 |         if (options?.initialTitles) setAbTestTitles(options.initialTitles);\n     |                                     ^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  40 |     }, [JSON.stringify(options?.initialTitles)]);\n  41 |\n  42 |     useEffect(() => {","line":39,"column":37,"nodeType":null,"endLine":39,"endColumn":52},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'options.initialTitles'. Either include it or remove the dependency array. If 'setAbTestTitles' needs the current value of 'options.initialTitles', you can also switch to useReducer instead of useState and read 'options.initialTitles' in the reducer.","line":40,"column":8,"nodeType":"ArrayExpression","endLine":40,"endColumn":48,"suggestions":[{"desc":"Update the dependencies array to be: [options.initialTitles]","fix":{"range":[1840,1880],"text":"[options.initialTitles]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":40,"column":9,"nodeType":"CallExpression","endLine":40,"endColumn":47},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/useABTesting.ts:43:41\n  41 |\n  42 |     useEffect(() => {\n> 43 |         if (options?.initialThumbnails) setAbTestThumbnails(options.initialThumbnails);\n     |                                         ^^^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  44 |     }, [JSON.stringify(options?.initialThumbnails)]);\n  45 |\n  46 |     useEffect(() => {","line":43,"column":41,"nodeType":null,"endLine":43,"endColumn":60},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'options.initialThumbnails'. Either include it or remove the dependency array. If 'setAbTestThumbnails' needs the current value of 'options.initialThumbnails', you can also switch to useReducer instead of useState and read 'options.initialThumbnails' in the reducer.","line":44,"column":8,"nodeType":"ArrayExpression","endLine":44,"endColumn":52,"suggestions":[{"desc":"Update the dependencies array to be: [options.initialThumbnails]","fix":{"range":[2001,2045],"text":"[options.initialThumbnails]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":44,"column":9,"nodeType":"CallExpression","endLine":44,"endColumn":51},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/useABTesting.ts:47:38\n  45 |\n  46 |     useEffect(() => {\n> 47 |         if (options?.initialResults) setAbTestResults(options.initialResults);\n     |                                      ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  48 |     }, [JSON.stringify(options?.initialResults)]);\n  49 |\n  50 |     // Handlers","line":47,"column":38,"nodeType":null,"endLine":47,"endColumn":54},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'options.initialResults'. Either include it or remove the dependency array. If 'setAbTestResults' needs the current value of 'options.initialResults', you can also switch to useReducer instead of useState and read 'options.initialResults' in the reducer.","line":48,"column":8,"nodeType":"ArrayExpression","endLine":48,"endColumn":49,"suggestions":[{"desc":"Update the dependencies array to be: [options.initialResults]","fix":{"range":[2157,2198],"text":"[options.initialResults]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":48,"column":9,"nodeType":"CallExpression","endLine":48,"endColumn":48}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react';\nimport { DEFAULT_AB_RESULTS } from '../types';\n\n/**\n * Manages A/B testing modal state and data.\n * \n * KEY FEATURE: Supports \"background save\" for results-only changes.\n * When the user updates watch time share data without changing titles/thumbnails,\n * the `onResultsSave` callback is triggered to save results immediately to the server\n * without affecting the main packaging \"dirty\" state or version history.\n */\n\ninterface UseABTestingOptions {\n    initialTitles?: string[];\n    initialThumbnails?: string[];\n    initialResults?: { titles: number[], thumbnails: number[] };\n    /** Called when only results changed, allows parent to save results in background */\n    onResultsSave?: (results: { titles: number[], thumbnails: number[] }) => void;\n    /** Called when a single title is edited (not creating A/B test) */\n    onTitleChange?: (title: string) => void;\n    /** Called when a single thumbnail is edited (not creating A/B test) */\n    onThumbnailChange?: (thumbnail: string) => void;\n}\n\nexport const useABTesting = (options?: UseABTestingOptions) => {\n    // A/B Testing state\n    const [isOpen, setIsOpen] = useState(false);\n    const [activeTab, setActiveTab] = useState<'title' | 'thumbnail' | 'both'>('title');\n\n    // Data state\n    const [abTestTitles, setAbTestTitles] = useState<string[]>(options?.initialTitles || []);\n    const [abTestThumbnails, setAbTestThumbnails] = useState<string[]>(options?.initialThumbnails || []);\n    const [abTestResults, setAbTestResults] = useState<{ titles: number[], thumbnails: number[] }>(\n        options?.initialResults || DEFAULT_AB_RESULTS\n    );\n\n    // Sync state when props change (e.g. data loaded from server)\n    useEffect(() => {\n        if (options?.initialTitles) setAbTestTitles(options.initialTitles);\n    }, [JSON.stringify(options?.initialTitles)]);\n\n    useEffect(() => {\n        if (options?.initialThumbnails) setAbTestThumbnails(options.initialThumbnails);\n    }, [JSON.stringify(options?.initialThumbnails)]);\n\n    useEffect(() => {\n        if (options?.initialResults) setAbTestResults(options.initialResults);\n    }, [JSON.stringify(options?.initialResults)]);\n\n    // Handlers\n    const handleOpenFromTitle = useCallback(() => {\n        setActiveTab('title');\n        setIsOpen(true);\n    }, []);\n\n    const handleOpenFromThumbnail = useCallback(() => {\n        setActiveTab('thumbnail');\n        setIsOpen(true);\n    }, []);\n\n    const closeModal = useCallback(() => {\n        setIsOpen(false);\n    }, []);\n\n    /**\n     * Handles save from the A/B modal.\n     * - Always updates local state with new titles/thumbnails/results.\n     * - If packagingChanged is FALSE (only results changed), triggers background save\n     *   via onResultsSave callback so data persists without \"Draft\" status.\n     * - If saving a single variant (not A/B test), syncs with main title/thumbnail.\n     */\n    const handleSave = useCallback((data: {\n        mode: 'title' | 'thumbnail' | 'both';\n        titles: string[];\n        thumbnails: string[];\n        results: { titles: number[], thumbnails: number[] };\n        packagingChanged: boolean;\n    }) => {\n        setAbTestTitles(data.titles);\n        setAbTestThumbnails(data.thumbnails);\n        setAbTestResults(data.results);\n\n        // If editing a single title (not creating A/B test), sync with main title\n        if (data.titles.length === 1 && options?.onTitleChange) {\n            options.onTitleChange(data.titles[0]);\n        }\n\n        // If editing a single thumbnail (not creating A/B test), sync with main thumbnail\n        if (data.thumbnails.length === 1 && options?.onThumbnailChange) {\n            options.onThumbnailChange(data.thumbnails[0]);\n        }\n\n        // If only results changed, trigger a background save\n        if (!data.packagingChanged && options?.onResultsSave) {\n            options.onResultsSave(data.results);\n        }\n    }, [options]);\n\n    return {\n        // State\n        modalOpen: isOpen,\n        initialTab: activeTab,\n        titles: abTestTitles,\n        thumbnails: abTestThumbnails,\n        results: abTestResults,\n\n        // Actions\n        setTitles: setAbTestTitles,\n        setThumbnails: setAbTestThumbnails,\n        setResults: setAbTestResults,\n        openFromTitle: handleOpenFromTitle,\n        openFromThumbnail: handleOpenFromThumbnail,\n        closeModal,\n        saveChanges: handleSave,\n    };\n};\n\nexport type UseABTestingResult = ReturnType<typeof useABTesting>;\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/useDirtyTracking.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/useDirtyTracking.ts:70:13\n  68 |     useEffect(() => {\n  69 |         if (isReadOnly) {\n> 70 |             setIsDirty(false);\n     |             ^^^^^^^^^^ Avoid calling setState() directly within an effect\n  71 |         }\n  72 |     }, [isReadOnly]);\n  73 |","line":70,"column":13,"nodeType":null,"endLine":70,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useDirtyTracking Hook\n *\n * BUSINESS LOGIC: Tracks unsaved changes in a form\n *\n * - Compares current form values against a \"loaded snapshot\"\n * - Returns isDirty boolean\n * - Provides reset function to update snapshot after save\n * - Old versions are always clean (read-only)\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { type VideoLocalization, type CoverVersion } from '../../../../../core/utils/youtubeApi';\nimport { type ABTestResults } from '../types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface FormSnapshot {\n    title: string;\n    description: string;\n    tags: string[];\n    customImage: string;\n    localizations: Record<string, VideoLocalization>;\n    abTestTitles: string[];\n    abTestThumbnails: string[];\n    abTestResults: ABTestResults;\n    coverHistory: CoverVersion[];\n}\n\nexport interface CurrentFormValues {\n    title: string;\n    description: string;\n    tags: string[];\n    customImage: string;\n    localizations: Record<string, VideoLocalization>;\n    abTestTitles: string[];\n    abTestThumbnails: string[];\n    abTestResults: ABTestResults;\n    coverHistory: CoverVersion[];\n}\n\ninterface UseDirtyTrackingOptions {\n    initialSnapshot: FormSnapshot;\n    isReadOnly: boolean;\n}\n\ninterface UseDirtyTrackingReturn {\n    isDirty: boolean;\n    loadedSnapshot: FormSnapshot;\n    checkDirty: (current: CurrentFormValues) => void;\n    resetSnapshot: (newSnapshot: FormSnapshot) => void;\n}\n\n// ============================================================================\n// HOOK\n// ============================================================================\n\nexport function useDirtyTracking({\n    initialSnapshot,\n    isReadOnly\n}: UseDirtyTrackingOptions): UseDirtyTrackingReturn {\n    const [isDirty, setIsDirty] = useState(false);\n    const [loadedSnapshot, setLoadedSnapshot] = useState<FormSnapshot>(initialSnapshot);\n\n    // BUSINESS LOGIC: Read-only versions are never dirty\n    useEffect(() => {\n        if (isReadOnly) {\n            setIsDirty(false);\n        }\n    }, [isReadOnly]);\n\n    // Check if current values differ from loaded snapshot\n    const checkDirty = useCallback((current: CurrentFormValues) => {\n        if (isReadOnly) {\n            return; // Don't update dirty state for read-only views\n        }\n\n        const hasChanges =\n            current.title !== loadedSnapshot.title ||\n            current.description !== loadedSnapshot.description ||\n            JSON.stringify(current.tags) !== JSON.stringify(loadedSnapshot.tags) ||\n            current.customImage !== loadedSnapshot.customImage ||\n            JSON.stringify(current.localizations) !== JSON.stringify(loadedSnapshot.localizations) ||\n            JSON.stringify(current.abTestTitles) !== JSON.stringify(loadedSnapshot.abTestTitles) ||\n            JSON.stringify(current.abTestThumbnails) !== JSON.stringify(loadedSnapshot.abTestThumbnails) ||\n            JSON.stringify(current.abTestResults) !== JSON.stringify(loadedSnapshot.abTestResults) ||\n            JSON.stringify(current.coverHistory) !== JSON.stringify(loadedSnapshot.coverHistory);\n\n        // Only update if changed to prevent infinite loops\n        if (hasChanges !== isDirty) {\n            setIsDirty(hasChanges);\n        }\n    }, [loadedSnapshot, isDirty, isReadOnly]);\n\n    // Reset snapshot after save or version switch\n    const resetSnapshot = useCallback((newSnapshot: FormSnapshot) => {\n        setLoadedSnapshot(newSnapshot);\n        setIsDirty(false);\n    }, []);\n\n    return {\n        isDirty,\n        loadedSnapshot,\n        checkDirty,\n        resetSnapshot\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingActions.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1246,1249],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1246,1249],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1305,1308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1305,1308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1313,1316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1313,1316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1992,1995],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1992,1995],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2051,2054],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2051,2054],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2059,2062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2059,2062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2441,2444],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2441,2444],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2544,2547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2544,2547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2603,2606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2603,2606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2611,2614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2611,2614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3313,3316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3313,3316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3372,3375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3372,3375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3380,3383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3380,3383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\n\n//  \nvi.mock('../../../../core/hooks/useAuth', () => ({\n    useAuth: () => ({ user: { uid: 'test-user' } })\n}));\n\nvi.mock('../../../../core/stores/channelStore', () => ({\n    useChannelStore: () => ({\n        currentChannel: { id: 'test-channel' },\n        setCurrentChannel: vi.fn()\n    })\n}));\n\nvi.mock('../../../../core/hooks/useVideos', () => ({\n    useVideos: () => ({ updateVideo: vi.fn() })\n}));\n\ndescribe('usePackagingActions - closingSnapshotId logic', () => {\n    /**\n     *    closingSnapshotId  trafficData\n     *    publishedVideoId\n     */\n\n    it('      ', () => {\n        const activeVersion = 3;\n        const trafficData = {\n            snapshots: [\n                { id: 'snap-v1', version: 1, timestamp: 150 },\n                { id: 'snap-v2', version: 2, timestamp: 250 },\n                { id: 'snap-v3-old', version: 3, timestamp: 350 },\n                { id: 'snap-v3-new', version: 3, timestamp: 400 } //    v.3\n            ]\n        };\n\n        //   handleRestore\n        const activeVersionSnapshots = trafficData.snapshots\n            .filter((s: any) => s.version === activeVersion)\n            .sort((a: any, b: any) => b.timestamp - a.timestamp);\n\n        const closingSnapshotId = activeVersionSnapshots.length > 0\n            ? activeVersionSnapshots[0].id\n            : null;\n\n        expect(closingSnapshotId).toBe('snap-v3-new');\n    });\n\n    it('  null,      ', () => {\n        const activeVersion = 3;\n        const trafficData = {\n            snapshots: [\n                { id: 'snap-v1', version: 1, timestamp: 150 },\n                { id: 'snap-v2', version: 2, timestamp: 250 }\n                //    v.3\n            ]\n        };\n\n        const activeVersionSnapshots = trafficData.snapshots\n            .filter((s: any) => s.version === activeVersion)\n            .sort((a: any, b: any) => b.timestamp - a.timestamp);\n\n        const closingSnapshotId = activeVersionSnapshots.length > 0\n            ? activeVersionSnapshots[0].id\n            : null;\n\n        expect(closingSnapshotId).toBe(null);\n    });\n\n    it('  null,  trafficData ', () => {\n        const activeVersion = 3;\n        const trafficData = {\n            snapshots: [] as any[]\n        };\n\n        const activeVersionSnapshots = trafficData.snapshots\n            .filter((s: any) => s.version === activeVersion)\n            .sort((a: any, b: any) => b.timestamp - a.timestamp);\n\n        const closingSnapshotId = activeVersionSnapshots.length > 0\n            ? activeVersionSnapshots[0].id\n            : null;\n\n        expect(closingSnapshotId).toBe(null);\n    });\n\n    it('     timestamp', () => {\n        const activeVersion = 2;\n        const trafficData = {\n            snapshots: [\n                { id: 'snap-v2-1', version: 2, timestamp: 100 },\n                { id: 'snap-v2-3', version: 2, timestamp: 300 }, //  \n                { id: 'snap-v2-2', version: 2, timestamp: 200 }\n            ]\n        };\n\n        const activeVersionSnapshots = trafficData.snapshots\n            .filter((s: any) => s.version === activeVersion)\n            .sort((a: any, b: any) => b.timestamp - a.timestamp);\n\n        expect(activeVersionSnapshots[0].id).toBe('snap-v2-3');\n        expect(activeVersionSnapshots[1].id).toBe('snap-v2-2');\n        expect(activeVersionSnapshots[2].id).toBe('snap-v2-1');\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingActions.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'video.publishedVideoId'. Either exclude it or remove the dependency array.","line":271,"column":8,"nodeType":"ArrayExpression","endLine":271,"endColumn":206,"suggestions":[{"desc":"Update the dependencies array to be: [user, currentChannel, video.id, buildSavePayload, versionState, updateVideo, formState, showToast, abTesting, onRequestSnapshot, video.coverHistory, video.packagingRevision]","fix":{"range":[12817,13015],"text":"[user, currentChannel, video.id, buildSavePayload, versionState, updateVideo, formState, showToast, abTesting, onRequestSnapshot, video.coverHistory, video.packagingRevision]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":378,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":378,"endColumn":19},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'video.packagingRevision'. Either include it or remove the dependency array.","line":438,"column":8,"nodeType":"ArrayExpression","endLine":438,"endColumn":113,"suggestions":[{"desc":"Update the dependencies array to be: [user, currentChannel, video.id, video.packagingHistory, video.packagingRevision, versionState, updateVideo, formState, showToast]","fix":{"range":[20842,20947],"text":"[user, currentChannel, video.id, video.packagingHistory, video.packagingRevision, versionState, updateVideo, formState, showToast]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from 'react';\nimport type { VideoDetails, CoverVersion } from '../../../../../core/utils/youtubeApi';\nimport type { PackagingVersion, ActivePeriod } from '../../../../../core/types/versioning';\nimport type { TrafficData, TrafficSnapshot } from '../../../../../core/types/traffic';\nimport { useUIStore } from '../../../../../core/stores/uiStore';\nimport { useVideos } from '../../../../../core/hooks/useVideos';\nimport { useAuth } from '../../../../../core/hooks/useAuth';\nimport { useChannelStore } from '../../../../../core/stores/channelStore';\nimport { useSettings } from '../../../../../core/hooks/useSettings';\nimport { ChannelService } from '../../../../../core/services/channelService';\nimport { deleteImageFromStorage } from '../../../../../core/services/storageService';\nimport { type VersionState } from '../types';\nimport { type UsePackagingLocalizationResult } from './usePackagingLocalization';\nimport { type UsePackagingFormStateResult } from './usePackagingFormState';\nimport { type UseABTestingResult } from './useABTesting';\n\ninterface UsePackagingActionsProps {\n    video: VideoDetails;\n    versionState: VersionState;\n    localization: UsePackagingLocalizationResult;\n    formState: UsePackagingFormStateResult;\n    abTesting: UseABTestingResult;\n    onRequestSnapshot?: (versionNumber: number) => Promise<string | null | undefined>; // Returns snapshotId, null (skip), or undefined (cancel)\n    trafficData?: TrafficData | null; // Traffic data for finding snapshots\n}\n\nexport const usePackagingActions = ({\n    video,\n    versionState,\n    localization,\n    formState,\n    abTesting,\n    onRequestSnapshot,\n    trafficData\n}: UsePackagingActionsProps) => {\n    const { user } = useAuth();\n    const { currentChannel, setCurrentChannel } = useChannelStore();\n    const { cloneSettings } = useSettings();\n    const { updateVideo, cloneVideo } = useVideos(user?.uid || '', currentChannel?.id || '');\n    const { showToast } = useUIStore();\n    const [savingAction, setSavingAction] = useState<'draft' | 'version' | 'metadata' | null>(null);\n    const [cloningVersion, setCloningVersion] = useState<number | null>(null);\n\n    // Common payload construction\n    const buildSavePayload = useCallback(() => {\n        const locPayload = localization.getFullPayload();\n\n        return {\n            ...locPayload,\n            customImage: formState.customImage,\n            customImageName: formState.customImageName,\n            customImageVersion: formState.customImageVersion,\n            publishedVideoId: formState.publishedVideoId,\n            videoRender: formState.videoRender,\n            audioRender: formState.audioRender,\n            coverHistory: formState.pendingHistory,\n            abTestTitles: abTesting.titles,\n            abTestThumbnails: abTesting.thumbnails,\n            abTestResults: abTesting.results\n        };\n    }, [localization, formState, abTesting]);\n\n    const handleSave = useCallback(async () => {\n        if (!user || !currentChannel || !video.id) return;\n\n        // Prevent saving if image is still uploading (blob: URLs are temporary)\n        if (formState.customImage.startsWith('blob:')) {\n            showToast('Please wait for image upload to complete', 'error');\n            return;\n        }\n\n        setSavingAction('draft');\n        try {\n            const payload = buildSavePayload();\n\n            // Mark as draft -> switches sidebar to Draft\n            const { updatedHistory: updatedPackagingHistory } = versionState.saveDraft();\n            const versionPayload = versionState.getVersionsPayload();\n\n            // Prepare for cleanup: identify images removed from coverHistory\n            const removedImages = (video.coverHistory || [])\n                .filter(old => !payload.coverHistory.some(curr => curr.url === old.url))\n                .map(item => item.url);\n\n            await updateVideo({\n                videoId: video.id,\n                updates: {\n                    ...payload,\n                    // Keep thumbnail in sync with customImage (use empty string if deliberately cleared)\n                    thumbnail: payload.customImage,\n                    // Version data\n                    packagingHistory: updatedPackagingHistory,\n                    currentPackagingVersion: versionPayload.currentPackagingVersion,\n                    isDraft: true,\n                    activeVersion: 'draft' // Ensure ACTIVE badge shows on draft\n                },\n                expectedRevision: video.packagingRevision\n            });\n\n            // Smart Cleanup: Delete removed images from storage IF they aren't in packaging history\n            if (removedImages.length > 0) {\n                const combinedPackagingHistory = updatedPackagingHistory;\n                const currentImage = payload.customImage;\n\n                removedImages.forEach(url => {\n                    if (url && url.includes('firebasestorage.googleapis.com')) {\n                        const isInUse = combinedPackagingHistory.some(v =>\n                            v.configurationSnapshot?.coverImage === url ||\n                            v.configurationSnapshot?.abTestVariants?.includes(url)\n                        ) || currentImage === url;\n\n                        if (!isInUse) {\n                            console.log('[usePackagingActions] Safe Cleanup: Deleting unused file', url);\n                            deleteImageFromStorage(url).catch(e => console.error(e));\n                        }\n                    }\n                });\n            }\n\n            formState.updateSnapshotToCurrent();\n            showToast('Saved as draft', 'success');\n        } catch (error: unknown) {\n            console.error('Failed to save video:', error);\n            const err = error as Error;\n            if (err?.message === 'VERSION_MISMATCH') {\n                showToast('Data is out of sync. Please refresh the page.', 'error');\n            } else {\n                showToast('Failed to save video', 'error');\n            }\n        } finally {\n            setSavingAction(null);\n        }\n    }, [user, currentChannel, video.id, buildSavePayload, versionState, updateVideo, formState, showToast, video.coverHistory, video.packagingRevision]);\n\n    /**\n     * BUSINESS LOGIC: Save As New Version with CSV Snapshot\n     * \n     * For published videos:\n     * 1. Request CSV snapshot to close current version's period\n     * 2. Create new version with closingSnapshotId\n     * 3. Save to Firestore\n     * \n     * For unpublished videos:\n     * 1. Create new version without snapshot\n     * 2. Save to Firestore\n     */\n    const handleSaveAsNewVersion = useCallback(async () => {\n        if (!user || !currentChannel || !video.id) return;\n\n        // Prevent saving if image is still uploading (blob: URLs are temporary)\n        if (formState.customImage.startsWith('blob:')) {\n            showToast('Please wait for image upload to complete', 'error');\n            return;\n        }\n\n        setSavingAction('version');\n        try {\n            const payload = buildSavePayload();\n            let closingSnapshotId: string | null | undefined = null;\n\n            let versionForSnapshot = versionState.activeVersion;\n\n            // ... (rest of snapshot logic)\n            // If we are in Draft mode, we need to find the \"previous active version\" to close its period.\n            if (versionForSnapshot === 'draft' && versionState.packagingHistory.length > 0) {\n                // Strategy 1: Find version with most recent active period start date\n                const latestByDate = versionState.packagingHistory.reduce((best, current) => {\n                    const currentStart = current.activePeriods?.reduce((max: number, p: ActivePeriod) =>\n                        (p.startDate || 0) > (max || 0) ? (p.startDate || 0) : (max || 0)\n                        , 0) || 0;\n\n                    const bestStart = best?.activePeriods?.reduce((max: number, p: ActivePeriod) =>\n                        (p.startDate || 0) > (max || 0) ? (p.startDate || 0) : (max || 0)\n                        , 0) || 0;\n\n                    return currentStart > bestStart ? current : best;\n                }, null as typeof versionState.packagingHistory[0] | null);\n\n                // Strategy 2: Fallback to max version number if no dates found\n                if (latestByDate && (latestByDate.activePeriods?.length || 0) > 0) {\n                    versionForSnapshot = latestByDate.versionNumber;\n                } else {\n                    const maxVersion = Math.max(...versionState.packagingHistory.map(v => v.versionNumber));\n                    versionForSnapshot = maxVersion;\n                }\n            }\n\n            // Request CSV snapshot - always offer to save current traffic state before versioning\n            // Only proceed if we have a valid numeric version to snapshot against\n            if (onRequestSnapshot && typeof versionForSnapshot === 'number') {\n                // Returns string (snapshotId), null (skip), or undefined (cancel)\n                closingSnapshotId = await onRequestSnapshot(versionForSnapshot);\n\n                // If user cancelled the modal (undefined), stop everything\n                if (closingSnapshotId === undefined) {\n                    setSavingAction(null);\n                    return;\n                }\n                // If returned null (Skip), we proceed with creation but closingSnapshotId remains null\n            }\n\n            // Create new version - this updates local state via reducer\n            const { newVersion, updatedHistory: updatedPackagingHistory, currentPackagingVersion } = versionState.createVersion({\n                title: payload.title,\n                description: payload.description,\n                tags: payload.tags,\n                coverImage: formState.customImage || null,\n                abTestTitles: abTesting.titles,\n                abTestThumbnails: abTesting.thumbnails,\n                abTestResults: abTesting.results,\n                localizations: payload.localizations\n            }, closingSnapshotId || null);\n\n            // Prepare for cleanup: identify images removed from coverHistory\n            const removedImages = (video.coverHistory || [])\n                .filter(old => !payload.coverHistory.some(curr => curr.url === old.url))\n                .map(item => item.url);\n\n            // Update snapshot and show toast\n            formState.updateSnapshotToCurrent();\n            showToast(`Saved as v.${newVersion.versionNumber}`, 'success');\n\n            // Save to Firestore in background\n            updateVideo({\n                videoId: video.id,\n                updates: {\n                    ...payload,\n                    thumbnail: payload.customImage,\n                    packagingHistory: updatedPackagingHistory,\n                    currentPackagingVersion: currentPackagingVersion,\n                    activeVersion: newVersion.versionNumber,\n                    isDraft: false\n                },\n                expectedRevision: video.packagingRevision\n            }).then(() => {\n                // Smart Cleanup after successful server update\n                if (removedImages.length > 0) {\n                    removedImages.forEach(url => {\n                        if (url && url.includes('firebasestorage.googleapis.com')) {\n                            const isInUse = updatedPackagingHistory.some(v =>\n                                v.configurationSnapshot?.coverImage === url ||\n                                v.configurationSnapshot?.abTestVariants?.includes(url)\n                            ) || payload.customImage === url;\n\n                            if (!isInUse) {\n                                console.log('[usePackagingActions] Safe Cleanup: Deleting unused file', url);\n                                deleteImageFromStorage(url).catch(e => console.error(e));\n                            }\n                        }\n                    });\n                }\n            }).catch(error => {\n                console.error('Failed to create version:', error);\n                if (error?.message === 'VERSION_MISMATCH') {\n                    showToast('Data is out of sync. Please refresh the page.', 'error');\n                } else {\n                    showToast('Failed to save to server', 'error');\n                }\n            });\n        } catch (error: unknown) {\n            console.error('Failed to create version:', error);\n            const err = error as Error;\n            if (err?.message === 'VERSION_MISMATCH') {\n                showToast('Data is out of sync. Please refresh the page.', 'error');\n            } else {\n                showToast('Failed to create version', 'error');\n            }\n        } finally {\n            setSavingAction(null);\n        }\n    }, [user, currentChannel, video.id, video.publishedVideoId, buildSavePayload, versionState, updateVideo, formState, showToast, abTesting, onRequestSnapshot, video.coverHistory, video.packagingRevision]);\n\n    const handleCancel = useCallback(() => {\n        formState.resetToSnapshot(formState.loadedSnapshot);\n    }, [formState]);\n\n    const handleCloneFromVersion = useCallback(async (version: CoverVersion) => {\n        if (cloningVersion !== null) return;\n        setCloningVersion(version.version);\n        try {\n            await cloneVideo({\n                originalVideo: video,\n                coverVersion: version,\n                cloneDurationSeconds: cloneSettings?.cloneDurationSeconds || 3600\n            });\n\n            // Dynamic message based on whether there are unsaved changes\n            const message = formState.isDirty\n                ? `Thumbnail cloned  save & view`\n                : `Thumbnail cloned  click to view`;\n\n            // Show toast with action to save draft and navigate to homepage\n            showToast(\n                message,\n                'success',\n                'clickable', // This signals the toast is clickable\n                async () => {\n                    // Auto-save draft before navigating (only if dirty)\n                    if (formState.isDirty) {\n                        try {\n                            await handleSave();\n                        } catch (error) {\n                            console.error('Failed to save draft:', error);\n                            showToast('Failed to save changes', 'error');\n                            return; // Don't navigate if save failed\n                        }\n                    }\n                    // Navigate to homepage to see the cloned video\n                    window.location.href = '/';\n                }\n            );\n        } catch {\n            showToast('Failed to clone version', 'error');\n        } finally {\n            setCloningVersion(null);\n        }\n    }, [cloningVersion, cloneVideo, video, showToast, cloneSettings, formState.isDirty, handleSave]);\n\n    const handleRestore = useCallback(async () => {\n        if (versionState.viewingVersion !== 'draft' && typeof versionState.viewingVersion === 'number') {\n            //  closingSnapshotId      \n            let closingSnapshotId: string | null = null;\n\n            if (typeof versionState.activeVersion === 'number') {\n                //  1:   onRequestSnapshot (   publishedVideoId),  CSV\n                if (onRequestSnapshot) {\n                    const snapshotResult = await onRequestSnapshot(versionState.activeVersion);\n\n                    //    (undefined),  \n                    if (snapshotResult === undefined) {\n                        return;\n                    }\n\n                    closingSnapshotId = snapshotResult;\n                }\n                //  2:    publishedVideoId     \n                else if (trafficData?.snapshots) {\n                    //      \n                    const activeVersionSnapshots = trafficData.snapshots\n                        .filter((s: TrafficSnapshot) => s.version === versionState.activeVersion)\n                        .sort((a: TrafficSnapshot, b: TrafficSnapshot) => b.timestamp - a.timestamp); //   \n\n                    //    \n                    if (activeVersionSnapshots.length > 0) {\n                        closingSnapshotId = activeVersionSnapshots[0].id;\n                    }\n                }\n            }\n\n            versionState.restoreVersion(versionState.viewingVersion, closingSnapshotId);\n            showToast(`Restored to v.${versionState.viewingVersion}`, 'success');\n        }\n    }, [versionState, showToast, onRequestSnapshot, trafficData]);\n\n    const handleAddLanguage = useCallback(async (code: string, customName?: string, customFlag?: string) => {\n        localization.addLanguage(code, customName, customFlag);\n        if (customName && user && currentChannel) {\n            const existing = currentChannel.customLanguages || [];\n            if (!existing.some(l => l.code === code)) {\n                const updated = [...existing, { code, name: customName, flag: customFlag || '' }];\n                try {\n                    await ChannelService.updateChannel(user.uid, currentChannel.id, { customLanguages: updated });\n                    setCurrentChannel({ ...currentChannel, customLanguages: updated });\n                } catch (e) {\n                    console.error('Failed to save language', e);\n                }\n            }\n        }\n    }, [localization, user, currentChannel, setCurrentChannel]);\n\n    const handleDeleteCustomLanguage = useCallback(async (code: string) => {\n        if (!user || !currentChannel) return;\n        const updated = (currentChannel.customLanguages || []).filter(l => l.code !== code);\n        try {\n            await ChannelService.updateChannel(user.uid, currentChannel.id, { customLanguages: updated });\n            setCurrentChannel({ ...currentChannel, customLanguages: updated });\n            showToast(`Language \"${code.toUpperCase()}\" deleted`, 'success');\n        } catch (e) {\n            showToast('Failed to delete language', 'error');\n        }\n    }, [user, currentChannel, setCurrentChannel, showToast]);\n\n    /**\n     * Saves ONLY A/B test results to the server in the background.\n     * \n     * This is a \"quiet\" save that:\n     * - Does NOT create a draft or trigger version history\n     * - Does NOT show a toast notification\n     * - Updates the loaded snapshot so the sync logic doesn't revert the change\n     * \n     * Used when the user updates watch time share data without modifying\n     * the actual A/B test content (titles/thumbnails).\n     */\n    const handleSaveResultsOnly = useCallback(async (newResults: { titles: number[], thumbnails: number[] }) => {\n        if (!user || !currentChannel || !video.id) return;\n        try {\n            // 1. Prepare updated history to include results in the active version's snapshot\n            // This ensures results survive a page refresh when viewing that version\n            let updatedHistory = [...(video.packagingHistory || [])];\n            if (versionState.activeVersion !== 'draft') {\n                updatedHistory = updatedHistory.map(v =>\n                    v.versionNumber === versionState.activeVersion && v.configurationSnapshot\n                        ? {\n                            ...v,\n                            configurationSnapshot: {\n                                ...v.configurationSnapshot,\n                                abTestResults: newResults\n                            }\n                        }\n                        : v\n                ) as PackagingVersion[];\n            }\n\n            // 2. Perform Update to Firestore\n            await updateVideo({\n                videoId: video.id,\n                updates: {\n                    abTestResults: newResults,\n                    packagingHistory: updatedHistory\n                },\n                expectedRevision: video.packagingRevision\n            });\n\n            // 3. Update local state to stay in sync\n            // Update versionState history so it knows about the change immediately\n            versionState.setPackagingHistory(updatedHistory);\n\n            // Update the loaded snapshot's results so it stays in sync with what's on server\n            // (even though results are ignored for dirty check, it's good practice)\n            formState.setLoadedSnapshot(prev => ({\n                ...prev,\n                abTestResults: newResults\n            }));\n        } catch (error) {\n            console.error('Failed to save results in background:', error);\n            showToast('Failed to sync results with server', 'error');\n        }\n    }, [user, currentChannel, video.id, video.packagingHistory, versionState, updateVideo, formState, showToast]);\n\n    // Auto-save metadata fields (publishedVideoId, videoRender, audioRender)\n    // These fields don't belong to packaging versioning, so they save independently\n    const handleSaveMetadata = useCallback(async (metadata: {\n        publishedVideoId: string;\n        videoRender: string;\n        audioRender: string;\n    }) => {\n        if (!user || !currentChannel || !video.id) return;\n\n        try {\n            await updateVideo({\n                videoId: video.id,\n                updates: metadata,\n                expectedRevision: video.packagingRevision\n            });\n        } catch (error) {\n            console.error('Failed to auto-save metadata:', error);\n            // Silent fail - don't show toast for auto-save\n        }\n    }, [user, currentChannel, video.id, video.packagingRevision, updateVideo]);\n\n    return {\n        isSaving: savingAction === 'draft' || savingAction === 'version', // Backwards compatibility if needed, though we should prefer specific props\n        isSavingDraft: savingAction === 'draft',\n        isSavingNewVersion: savingAction === 'version',\n        cloningVersion,\n        handleSave,\n        handleSaveAsNewVersion,\n        handleSaveResultsOnly,\n        handleSaveMetadata,\n        handleCancel,\n        handleCloneFromVersion,\n        handleRestore,\n        handleAddLanguage,\n        handleDeleteCustomLanguage\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingFormState.ts","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `localization`, but the source dependencies were [localization.getFullPayload, customImage, customImageName, abTesting.titles, abTesting.thumbnails, abTesting.results, pendingHistory, loadedSnapshot]. Inferred less specific property than source.\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingFormState.ts:94:29\n   92 |      * and do not affect the main packaging \"dirty\" state.\n   93 |      */\n>  94 |     const isDirty = useMemo(() => {\n      |                             ^^^^^^^\n>  95 |         // Old versions were previously read-only, but now we allow editing to support \"Forking\".\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  96 |         // So we calculate isDirty normally regardless of isViewingOldVersion.\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 119 |         return !deepEqual(restCurrent, restLoaded);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 120 |     }, [\n      | ^^^^^^ Could not preserve existing manual memoization\n  121 |         localization.getFullPayload,\n  122 |         customImage,\n  123 |         customImageName, // Added dependency","line":94,"column":29,"nodeType":null,"endLine":120,"endColumn":6},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `customImageVersion`, but the source dependencies were [localization.getFullPayload, customImage, customImageName, abTesting.titles, abTesting.thumbnails, abTesting.results, pendingHistory, loadedSnapshot]. Inferred different dependency than source.\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingFormState.ts:94:29\n   92 |      * and do not affect the main packaging \"dirty\" state.\n   93 |      */\n>  94 |     const isDirty = useMemo(() => {\n      |                             ^^^^^^^\n>  95 |         // Old versions were previously read-only, but now we allow editing to support \"Forking\".\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  96 |         // So we calculate isDirty normally regardless of isViewingOldVersion.\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 119 |         return !deepEqual(restCurrent, restLoaded);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 120 |     }, [\n      | ^^^^^^ Could not preserve existing manual memoization\n  121 |         localization.getFullPayload,\n  122 |         customImage,\n  123 |         customImageName, // Added dependency","line":94,"column":29,"nodeType":null,"endLine":120,"endColumn":6},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_' is assigned a value but never used.","line":117,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'__' is assigned a value but never used.","line":118,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":34},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has missing dependencies: 'customImageVersion' and 'localization'. Either include them or remove the dependency array.","line":120,"column":8,"nodeType":"ArrayExpression","endLine":129,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [localization, customImage, customImageName, customImageVersion, abTesting.titles, abTesting.thumbnails, abTesting.results, pendingHistory, loadedSnapshot]","fix":{"range":[5101,5341],"text":"[localization, customImage, customImageName, customImageVersion, abTesting.titles, abTesting.thumbnails, abTesting.results, pendingHistory, loadedSnapshot]"}}]},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `customImageVersion`, but the source dependencies were [localization, customImage, customImageName, abTesting, pendingHistory]. Inferred different dependency than source.\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingFormState.ts:151:49\n  149 |\n  150 |     // Update the snapshot to current form values (used after save)\n> 151 |     const updateSnapshotToCurrent = useCallback(() => {\n      |                                                 ^^^^^^^\n> 152 |         const locPayload = localization.getFullPayload();\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 153 |         setLoadedSnapshot({\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 166 |         localization.resetDirty();\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 167 |     }, [localization, customImage, customImageName, abTesting, pendingHistory]); // Added dependency\n      | ^^^^^^ Could not preserve existing manual memoization\n  168 |\n  169 |     /**\n  170 |      * Checks if incoming video props match the current loaded snapshot.","line":151,"column":49,"nodeType":null,"endLine":167,"endColumn":6},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'customImageVersion'. Either include it or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setLoadedSnapshot' needs the current value of 'customImageVersion'.","line":167,"column":8,"nodeType":"ArrayExpression","endLine":167,"endColumn":79,"suggestions":[{"desc":"Update the dependencies array to be: [localization, customImage, customImageName, customImageVersion, abTesting.titles, abTesting.thumbnails, abTesting.results, pendingHistory]","fix":{"range":[6867,6938],"text":"[localization, customImage, customImageName, customImageVersion, abTesting.titles, abTesting.thumbnails, abTesting.results, pendingHistory]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_' is assigned a value but never used.","line":178,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":178,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'__' is assigned a value but never used.","line":179,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":34}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useMemo, useCallback } from 'react';\nimport { type VideoDetails, type CoverVersion, type VideoLocalization } from '../../../../../core/utils/youtubeApi';\nimport { deepEqual } from '../../../../../core/utils/deepEqual';\nimport { DEFAULT_TAGS, DEFAULT_LOCALIZATIONS, DEFAULT_AB_RESULTS, DEFAULT_COVER_HISTORY } from '../types';\n\n/**\n * Manages form state and dirty-checking for the Packaging tab.\n * \n * KEY DESIGN DECISION: A/B test results (watch time share) are excluded from\n * dirty-checking and sync comparisons. This allows users to update results\n * without triggering \"unsaved changes\" warnings or affecting version history.\n * Results are saved immediately to the server in the background via a separate action.\n */\n\ninterface PackagingFormSnapshot {\n    title: string;\n    description: string;\n    tags: string[];\n    customImage: string;\n    customImageName: string;\n    customImageVersion: number;\n    localizations: Record<string, VideoLocalization>;\n    abTestTitles: string[];\n    abTestThumbnails: string[];\n    abTestResults: { titles: number[], thumbnails: number[] };\n    coverHistory: CoverVersion[];\n}\n\ninterface UsePackagingFormStateOptions {\n    video: VideoDetails;\n    isViewingOldVersion: boolean;\n    localization: {\n        getFullPayload: () => {\n            title: string;\n            description: string;\n            tags: string[];\n            localizations: Record<string, VideoLocalization>;\n        };\n        resetToSnapshot: (snapshot: {\n            title: string;\n            description: string;\n            tags: string[];\n            localizations?: Record<string, VideoLocalization>;\n        }) => void;\n        resetDirty: () => void;\n    };\n    abTesting: {\n        titles: string[];\n        thumbnails: string[];\n        results: { titles: number[], thumbnails: number[] };\n        setTitles: (val: string[]) => void;\n        setThumbnails: (val: string[]) => void;\n        setResults: (val: { titles: number[], thumbnails: number[] }) => void;\n    };\n}\n\nexport const usePackagingFormState = ({\n    video,\n    isViewingOldVersion,\n    localization,\n    abTesting\n}: UsePackagingFormStateOptions) => {\n    // Non-localized form state\n    const [customImage, setCustomImage] = useState(video.customImage || '');\n    const [customImageName, setCustomImageName] = useState(video.customImageName || '');\n    const [customImageVersion, setCustomImageVersion] = useState(video.customImageVersion || 1);\n    const [publishedVideoId, setPublishedVideoId] = useState(video.publishedVideoId || '');\n    const [videoRender, setVideoRender] = useState(video.videoRender || '');\n    const [audioRender, setAudioRender] = useState(video.audioRender || '');\n    const [pendingHistory, setPendingHistory] = useState<CoverVersion[]>(video.coverHistory || DEFAULT_COVER_HISTORY);\n\n    // Snapshot of the last saved state (for dirty checking)\n    const [loadedSnapshot, setLoadedSnapshot] = useState<PackagingFormSnapshot>({\n        title: video.title || '',\n        description: video.description || '',\n        tags: video.tags || DEFAULT_TAGS,\n        customImage: video.customImage || '',\n        customImageName: video.customImageName || '',\n        customImageVersion: video.customImageVersion || 1,\n        localizations: video.localizations || DEFAULT_LOCALIZATIONS,\n        abTestTitles: video.abTestTitles || DEFAULT_TAGS,\n        abTestThumbnails: video.abTestThumbnails || DEFAULT_TAGS,\n        abTestResults: video.abTestResults || DEFAULT_AB_RESULTS as { titles: number[], thumbnails: number[] },\n        coverHistory: video.coverHistory || DEFAULT_COVER_HISTORY\n    });\n\n    /**\n     * Determines if the form has unsaved changes.\n     * \n     * NOTE: A/B test results (watch time share) are intentionally EXCLUDED\n     * from this check. Results are saved in the background independently\n     * and do not affect the main packaging \"dirty\" state.\n     */\n    const isDirty = useMemo(() => {\n        // Old versions were previously read-only, but now we allow editing to support \"Forking\".\n        // So we calculate isDirty normally regardless of isViewingOldVersion.\n        // if (isViewingOldVersion) return false;\n\n        const locPayload = localization.getFullPayload();\n\n        const currentSnapshot: PackagingFormSnapshot = {\n            title: locPayload.title,\n            description: locPayload.description,\n            tags: locPayload.tags,\n            localizations: locPayload.localizations,\n            customImage,\n            customImageName,\n            customImageVersion,\n            abTestTitles: abTesting.titles,\n            abTestThumbnails: abTesting.thumbnails,\n            abTestResults: abTesting.results,\n            coverHistory: pendingHistory\n        };\n\n        // Note: abTestResults are intentionally excluded from dirty check \n        // Compare everything except results to determine if the form is dirty\n        const { abTestResults: _, ...restCurrent } = currentSnapshot;\n        const { abTestResults: __, ...restLoaded } = loadedSnapshot;\n        return !deepEqual(restCurrent, restLoaded);\n    }, [\n        localization.getFullPayload,\n        customImage,\n        customImageName, // Added dependency\n        abTesting.titles,\n        abTesting.thumbnails,\n        abTesting.results,\n        pendingHistory,\n        loadedSnapshot\n    ]);\n\n    // Reset form to a specific snapshot (used when loading versions)\n    const resetToSnapshot = useCallback((snapshot: PackagingFormSnapshot) => {\n        localization.resetToSnapshot({\n            title: snapshot.title,\n            description: snapshot.description,\n            tags: snapshot.tags,\n            localizations: snapshot.localizations\n        });\n        setCustomImage(snapshot.customImage);\n        setCustomImageName(snapshot.customImageName);\n        setCustomImageVersion(snapshot.customImageVersion);\n        setPendingHistory(snapshot.coverHistory);\n        abTesting.setTitles(snapshot.abTestTitles);\n        abTesting.setThumbnails(snapshot.abTestThumbnails);\n        abTesting.setResults(snapshot.abTestResults);\n\n        setLoadedSnapshot(snapshot);\n    }, [localization, abTesting]);\n\n    // Update the snapshot to current form values (used after save)\n    const updateSnapshotToCurrent = useCallback(() => {\n        const locPayload = localization.getFullPayload();\n        setLoadedSnapshot({\n            title: locPayload.title,\n            description: locPayload.description,\n            tags: locPayload.tags,\n            localizations: locPayload.localizations,\n            customImage,\n            customImageName,\n            customImageVersion,\n            abTestTitles: abTesting.titles,\n            abTestThumbnails: abTesting.thumbnails,\n            abTestResults: abTesting.results,\n            coverHistory: pendingHistory\n        });\n        localization.resetDirty();\n    }, [localization, customImage, customImageName, abTesting, pendingHistory]); // Added dependency\n\n    /**\n     * Checks if incoming video props match the current loaded snapshot.\n     * Used to detect external changes (e.g., from another tab or Firebase sync).\n     * \n     * NOTE: A/B test results are EXCLUDED from this comparison to prevent\n     * the sync loop from resetting locally-saved results before they're\n     * persisted to the server.\n     */\n    const incomingVideoMatchesSnapshot = useCallback((videoSnapshot: PackagingFormSnapshot) => {\n        const { abTestResults: _, ...incomingRest } = videoSnapshot;\n        const { abTestResults: __, ...loadedRest } = loadedSnapshot;\n        return deepEqual(incomingRest, loadedRest);\n    }, [loadedSnapshot]);\n\n    return {\n        // State\n        customImage, setCustomImage,\n        customImageName, setCustomImageName,\n        customImageVersion, setCustomImageVersion,\n        publishedVideoId, setPublishedVideoId,\n        videoRender, setVideoRender,\n        audioRender, setAudioRender,\n        pendingHistory, setPendingHistory,\n        loadedSnapshot, setLoadedSnapshot,\n\n        // Results of computed state\n        isDirty,\n        isViewingOldVersion,\n\n        // Helpers\n        resetToSnapshot,\n        updateSnapshotToCurrent,\n        incomingVideoMatchesSnapshot\n    };\n};\n\nexport type UsePackagingFormStateResult = ReturnType<typeof usePackagingFormState>;\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingLocalization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingVersions.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'initialActive', 'initialActiveVersion', 'initialHistory.length', and 'initialIsDraft'. Either include them or remove the dependency array.","line":355,"column":8,"nodeType":"ArrayExpression","endLine":355,"endColumn":10,"suggestions":[{"desc":"Update the dependencies array to be: [initialActive, initialActiveVersion, initialHistory.length, initialIsDraft]","fix":{"range":[15172,15174],"text":"[initialActive, initialActiveVersion, initialHistory.length, initialIsDraft]"}}]},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `state.packagingRevision`, but the source dependencies were [state.packagingHistory, state.activeVersion, state.currentVersionNumber]. Inferred different dependency than source.\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingVersions.ts:417:39\n  415 |     }, [state.packagingHistory]);\n  416 |\n> 417 |     const createVersion = useCallback((snapshot: PackagingSnapshot, closingSnapshotId?: string | null): {\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 418 |         newVersion: PackagingVersion;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 419 |         updatedHistory: PackagingVersion[];\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 448 |         };\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 449 |     }, [state.packagingHistory, state.activeVersion, state.currentVersionNumber]);\n      | ^^^^^^ Could not preserve existing manual memoization\n  450 |\n  451 |     const saveDraft = useCallback((closingSnapshotId?: string | null): {\n  452 |         updatedHistory: PackagingVersion[]","line":417,"column":39,"nodeType":null,"endLine":449,"endColumn":6},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'state.packagingRevision'. Either include it or remove the dependency array.","line":449,"column":8,"nodeType":"ArrayExpression","endLine":449,"endColumn":81,"suggestions":[{"desc":"Update the dependencies array to be: [state.packagingHistory, state.currentVersionNumber, state.packagingRevision]","fix":{"range":[18766,18839],"text":"[state.packagingHistory, state.currentVersionNumber, state.packagingRevision]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'state.activeVersion'. Either exclude it or remove the dependency array.","line":461,"column":8,"nodeType":"ArrayExpression","endLine":461,"endColumn":53,"suggestions":[{"desc":"Update the dependencies array to be: [state.packagingHistory]","fix":{"range":[19231,19276],"text":"[state.packagingHistory]"}}]},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `nextVisualVersionNumber`, but the source dependencies were [state, sortedVersions, switchToVersion, restoreVersion, createVersion, saveDraft, deleteVersion, markDirty, getVersionSnapshot, getVersionsPayload, setPackagingHistory, setHasDraft, setActiveVersion, setCurrentVersionNumber]. Inferred different dependency than source.\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/hooks/usePackagingVersions.ts:523:20\n  521 |     }, [state.packagingHistory]);\n  522 |\n> 523 |     return useMemo(() => ({\n      |                    ^^^^^^^^\n> 524 |         // State\n      | ^^^^^^^^^^^^^^^^\n> 525 |         packagingHistory: state.packagingHistory,\n      \n      | ^^^^^^^^^^^^^^^^\n> 549 |         setCurrentVersionNumber\n      | ^^^^^^^^^^^^^^^^\n> 550 |     }), [\n      | ^^^^^^^ Could not preserve existing manual memoization\n  551 |         state,\n  552 |         sortedVersions,\n  553 |         switchToVersion,","line":523,"column":20,"nodeType":null,"endLine":550,"endColumn":7},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'nextVisualVersionNumber'. Either include it or remove the dependency array.","line":550,"column":9,"nodeType":"ArrayExpression","endLine":565,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [state.packagingHistory, state.navSortedVersions, state.currentVersionNumber, state.hasDraft, state.activeVersion, state.viewingVersion, state.viewingPeriodIndex, sortedVersions, nextVisualVersionNumber, switchToVersion, restoreVersion, createVersion, saveDraft, deleteVersion, markDirty, getVersionSnapshot, getVersionsPayload, setPackagingHistory, setHasDraft, setActiveVersion, setCurrentVersionNumber]","fix":{"range":[22946,23289],"text":"[state.packagingHistory, state.navSortedVersions, state.currentVersionNumber, state.hasDraft, state.activeVersion, state.viewingVersion, state.viewingPeriodIndex, sortedVersions, nextVisualVersionNumber, switchToVersion, restoreVersion, createVersion, saveDraft, deleteVersion, markDirty, getVersionSnapshot, getVersionsPayload, setPackagingHistory, setHasDraft, setActiveVersion, setCurrentVersionNumber]"}}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useReducer, useCallback, useMemo, useEffect } from 'react';\nimport type { PackagingVersion } from '../../../../../core/utils/youtubeApi';\nimport type { PackagingSnapshot } from '../../../../../core/types/versioning';\nimport { VersionService } from '../../../services/VersionService';\nimport { logger } from '../../../../../core/utils/logger';\n\n\ninterface UsePackagingVersionsOptions {\n    initialHistory: PackagingVersion[];\n    initialCurrentVersion: number;\n    isDraft: boolean;\n    initialActiveVersion?: number | 'draft';\n}\n\n// State managed by reducer\ninterface VersionsState {\n    packagingHistory: PackagingVersion[];\n    currentVersionNumber: number;\n    hasDraft: boolean;\n    activeVersion: number | 'draft';\n    viewingVersion: number | 'draft';\n    viewingPeriodIndex?: number;\n    navSortedVersions: PackagingVersion[]; // Pre-computed for atomic updates\n    packagingRevision: number; // Track revision to detect stale props\n}\n\n// Actions\ntype VersionsAction =\n    | { type: 'SYNC_FROM_PROPS'; payload: { history: PackagingVersion[]; currentVersion: number; isDraft: boolean; initialActiveVersion?: number | 'draft' } }\n    | { type: 'CREATE_VERSION'; payload: { newVersion: PackagingVersion; updatedHistory: PackagingVersion[]; closingSnapshotId?: string | null } }\n    | { type: 'DELETE_VERSION'; payload: { versionNumbers: number[] } }\n    | { type: 'RESTORE_VERSION'; payload: { versionNumber: number; closingSnapshotId?: string | null } }\n    | { type: 'SWITCH_TO_VERSION'; payload: { versionNumber: number | 'draft'; periodIndex?: number } }\n    | { type: 'SAVE_DRAFT'; payload: { closingSnapshotId?: string | null } }\n    | { type: 'MARK_DIRTY' }\n    | { type: 'SET_CURRENT_VERSION_NUMBER'; payload: number }\n    | { type: 'SET_HAS_DRAFT'; payload: boolean }\n    | { type: 'SET_ACTIVE_VERSION'; payload: { versionNumber: number | 'draft'; closingSnapshotId?: string | null } };\n\n/**\n * BUSINESS LOGIC: Helper Functions for Active Periods Management (Aliased from VersionService)\n */\nconst { ensureActivePeriods, closeAllPeriods, addNewActivePeriod } = VersionService;\n\n// Helper: Compute sidebar-sorted versions (active first, then desc by number)\n\n\n// Helper: Compute sidebar-sorted versions (active first, then by last activation time desc)\nfunction computeNavSorted(history: PackagingVersion[], activeVersion: number | 'draft'): PackagingVersion[] {\n    return [...history].sort((a, b) => {\n        const aIsActive = a.versionNumber === activeVersion;\n        const bIsActive = b.versionNumber === activeVersion;\n\n        // Active version always first\n        if (aIsActive && !bIsActive) return -1;\n        if (!aIsActive && bIsActive) return 1;\n\n        // For non-active versions, sort by last activation time (newest first)\n        const aLastActivation = a.activePeriods && a.activePeriods.length > 0\n            ? a.activePeriods[0].startDate\n            : a.startDate;\n        const bLastActivation = b.activePeriods && b.activePeriods.length > 0\n            ? b.activePeriods[0].startDate\n            : b.startDate;\n\n        return bLastActivation - aLastActivation;\n    });\n}\n\n// Reducer - single source of truth for all state transitions\nfunction versionsReducer(state: VersionsState, action: VersionsAction): VersionsState {\n    switch (action.type) {\n        case 'SYNC_FROM_PROPS': {\n            const { history, currentVersion, isDraft, initialActiveVersion } = action.payload;\n\n            // Calculate incoming revision from props\n            // Revision is stored in each PackagingVersion, we take the max\n            const incomingRevision = history.length > 0\n                ? Math.max(...history.map(v => v.revision || 0))\n                : 0;\n\n            // If local revision is newer, keep local state (optimistic update in progress)\n            if (state.packagingRevision > incomingRevision) {\n                logger.debug('Preserving newer local state (optimistic update)', {\n                    component: 'usePackagingVersions',\n                    localRevision: state.packagingRevision,\n                    incomingRevision\n                });\n                return state;\n            }\n\n            // Priority: \n            // 1. initialActiveVersion from props (if provided)\n            // 2. 'draft' if isDraft is true\n            // 3. Max version if history exists\n            // 4. Fallback to 'draft'\n            const computedActive = initialActiveVersion || (isDraft ? 'draft' : (history.length > 0\n                ? Math.max(...history.map(v => v.versionNumber))\n                : 'draft'));\n\n            logger.debug('SYNC_FROM_PROPS', {\n                component: 'usePackagingVersions',\n                isDraft,\n                initialActiveVersion,\n                computedActive,\n                historyCount: history.length,\n                incomingRevision,\n                localRevision: state.packagingRevision\n            });\n\n            // Smart sync: preserve local selection if still valid AND we are not forcing a specific initialActiveVersion\n            const isActiveValid = state.activeVersion === 'draft' ||\n                history.some(v => v.versionNumber === state.activeVersion);\n            const isViewingValid = state.viewingVersion === 'draft' ||\n                history.some(v => v.versionNumber === state.viewingVersion);\n\n            // If we have an explicit initialActiveVersion from props (e.g. from fresh data fetch), use it.\n            // Otherwise, if our local state is valid, keep it.\n            let newActive = computedActive;\n            if (initialActiveVersion !== undefined && initialActiveVersion !== null) {\n                newActive = initialActiveVersion;\n            } else if (isActiveValid) {\n                newActive = state.activeVersion;\n            }\n\n            // Sanitize history: ensure at most one version is active (has open period)\n            const sanitizedHistory = history.map(v => {\n                if (v.versionNumber !== newActive) {\n                    return closeAllPeriods(v);\n                }\n\n                // If this IS the active version, ensure it has an OPEN period\n                const withPeriods = ensureActivePeriods(v);\n                const hasOpen = withPeriods.activePeriods!.some(p => !p.endDate);\n                if (!hasOpen) {\n                    return addNewActivePeriod(withPeriods);\n                }\n                return withPeriods;\n            });\n\n            return {\n                packagingHistory: sanitizedHistory,\n                currentVersionNumber: currentVersion,\n                hasDraft: isDraft,\n                activeVersion: newActive,\n                viewingVersion: isViewingValid ? state.viewingVersion : computedActive,\n                viewingPeriodIndex: isViewingValid ? state.viewingPeriodIndex : 0,\n                navSortedVersions: computeNavSorted(sanitizedHistory, newActive),\n                packagingRevision: incomingRevision\n            };\n        }\n\n        case 'CREATE_VERSION': {\n            const { newVersion, updatedHistory } = action.payload;\n            const newRevision = state.packagingRevision + 1;\n\n            logger.info('Version created', {\n                component: 'usePackagingVersions',\n                versionNumber: newVersion.versionNumber,\n                revision: newRevision,\n                title: newVersion.configurationSnapshot?.title\n            });\n\n            return {\n                ...state,\n                packagingHistory: updatedHistory,\n                currentVersionNumber: state.currentVersionNumber + 1,\n                hasDraft: false,\n                activeVersion: newVersion.versionNumber,\n                viewingVersion: newVersion.versionNumber,\n                viewingPeriodIndex: 0,\n                navSortedVersions: computeNavSorted(updatedHistory, newVersion.versionNumber),\n                packagingRevision: newRevision\n            };\n        }\n\n        case 'DELETE_VERSION': {\n            const { versionNumbers } = action.payload;\n            const remaining = state.packagingHistory.filter(v => !versionNumbers.includes(v.versionNumber));\n            const newest = remaining.length > 0 ? Math.max(...remaining.map(v => v.versionNumber)) : null;\n\n            // Determine the new active version after deletion\n            let newActive: number | 'draft' = 'draft';\n            if (remaining.length > 0) {\n                // If the currently active version is not deleted, keep it.\n                if (typeof state.activeVersion === 'number' && !versionNumbers.includes(state.activeVersion)) {\n                    newActive = state.activeVersion;\n                } else {\n                    // Otherwise, activate the newest remaining version.\n                    newActive = newest!;\n                }\n            }\n\n            // Determine if the currently viewed version was deleted\n            const isViewingDeleted = typeof state.viewingVersion === 'number' && versionNumbers.includes(state.viewingVersion);\n\n            // Ensure the new active version's periods are managed correctly\n            const updatedHistory = remaining.map(v => {\n                if (v.versionNumber === newActive && typeof newActive === 'number') {\n                    // Force close existing and open fresh\n                    return addNewActivePeriod(closeAllPeriods(v));\n                }\n                return closeAllPeriods(v);\n            });\n\n            logger.info('Version(s) deleted', {\n                component: 'usePackagingVersions',\n                deletedVersions: versionNumbers,\n                newActiveVersion: newActive,\n                remainingCount: remaining.length\n            });\n\n            return {\n                ...state,\n                packagingHistory: updatedHistory,\n                currentVersionNumber: remaining.length === 0 ? 1 : (newest! + 1),\n                hasDraft: remaining.length === 0,\n                activeVersion: newActive,\n                viewingVersion: isViewingDeleted\n                    ? (newest ?? 'draft')\n                    : state.viewingVersion,\n                viewingPeriodIndex: isViewingDeleted ? 0 : state.viewingPeriodIndex,\n                navSortedVersions: computeNavSorted(updatedHistory, newActive),\n                packagingRevision: state.packagingRevision + 1\n            };\n        }\n\n        case 'RESTORE_VERSION': {\n            const { versionNumber, closingSnapshotId } = action.payload;\n\n            /**\n             * BUSINESS LOGIC: Restore Version with New Period\n             * \n             * When restoring an old version (e.g., v.3  v.1):\n             * 1. Close the current version's (v.3) active period\n             * 2. Add a NEW activation period to the restored version (v.1)\n             * \n             * IMPORTANT: We don't reuse v.1's old period! We create a new one.\n             * This allows accurate attribution of views to each activation period.\n             * \n             * Example:\n             * v.1 activePeriods before restore: [{ startDate: Day1, endDate: Day2 }]\n             * v.1 activePeriods after restore:  [\n             *   { startDate: Day1, endDate: Day2 },\n             *   { startDate: Day4, endDate: undefined }  NEW period!\n             * ]\n             */\n\n            const updatedHistory = state.packagingHistory.map(v => {\n                if (v.versionNumber === versionNumber) {\n                    return addNewActivePeriod(closeAllPeriods(v, closingSnapshotId));\n                }\n                return closeAllPeriods(v, closingSnapshotId);\n            });\n\n            logger.info('Version restored', {\n                component: 'usePackagingVersions',\n                versionNumber,\n                closingSnapshotId,\n                previousActiveVersion: state.activeVersion\n            });\n\n            return {\n                ...state,\n                packagingHistory: updatedHistory,\n                hasDraft: false,\n                activeVersion: versionNumber,\n                viewingVersion: versionNumber,\n                viewingPeriodIndex: 0, // Latest period after restore\n                navSortedVersions: computeNavSorted(updatedHistory, versionNumber),\n                packagingRevision: state.packagingRevision + 1\n            };\n        }\n\n        case 'SWITCH_TO_VERSION':\n            return {\n                ...state,\n                viewingVersion: action.payload.versionNumber,\n                viewingPeriodIndex: action.payload.periodIndex ?? 0\n            };\n\n        case 'SAVE_DRAFT': {\n            const { closingSnapshotId } = action.payload;\n\n            const updatedHistory = state.packagingHistory.map(v => {\n                return closeAllPeriods(v, closingSnapshotId || null);\n            });\n\n            return {\n                ...state,\n                packagingHistory: updatedHistory,\n                hasDraft: true,\n                activeVersion: 'draft',\n                viewingVersion: 'draft',\n                viewingPeriodIndex: 0,\n                navSortedVersions: computeNavSorted(updatedHistory, 'draft'),\n                packagingRevision: state.packagingRevision + 1\n            };\n        }\n\n        case 'MARK_DIRTY':\n            // USER REQUIREMENT: Draft should only appear explicitly (via Save as Draft)\n            // Dirty state is managed externally by formDirty flag.\n            // We no longer automatically show \"Draft\" in sidebar just because fields changed.\n            return state;\n\n        case 'SET_CURRENT_VERSION_NUMBER':\n            return { ...state, currentVersionNumber: action.payload };\n\n        case 'SET_HAS_DRAFT':\n            return { ...state, hasDraft: action.payload };\n\n        case 'SET_ACTIVE_VERSION': {\n            const { versionNumber, closingSnapshotId } = action.payload;\n\n            const updatedHistory = state.packagingHistory.map(v => {\n                if (v.versionNumber === versionNumber && typeof versionNumber === 'number') {\n                    return addNewActivePeriod(closeAllPeriods(v, closingSnapshotId || null));\n                }\n                return closeAllPeriods(v, closingSnapshotId || null);\n            });\n\n            return {\n                ...state,\n                packagingHistory: updatedHistory,\n                activeVersion: versionNumber,\n                navSortedVersions: computeNavSorted(updatedHistory, versionNumber),\n                packagingRevision: state.packagingRevision + 1\n            };\n        }\n\n        default:\n            return state;\n    }\n}\n\nexport const usePackagingVersions = ({\n    initialHistory,\n    initialCurrentVersion,\n    isDraft: initialIsDraft,\n    initialActiveVersion\n}: UsePackagingVersionsOptions) => {\n    const initialActive = initialActiveVersion || (initialIsDraft ? 'draft' : (initialHistory.length > 0\n        ? Math.max(...initialHistory.map(v => v.versionNumber))\n        : 'draft'));\n\n    useEffect(() => {\n        logger.debug('Initializing usePackagingVersions', {\n            component: 'usePackagingVersions',\n            initialIsDraft,\n            initialActiveVersion,\n            initialActive,\n            historyCount: initialHistory.length\n        });\n    }, []);\n\n    // Calculate initial revision from history\n    const initialRevision = initialHistory.length > 0\n        ? Math.max(...initialHistory.map(v => v.revision || 0))\n        : 0;\n\n    // Single reducer for atomic state management\n    const [state, dispatch] = useReducer(versionsReducer, {\n        packagingHistory: initialHistory,\n        currentVersionNumber: initialCurrentVersion,\n        hasDraft: initialIsDraft,\n        activeVersion: initialActive,\n        viewingVersion: initialActive,\n        viewingPeriodIndex: 0,\n        navSortedVersions: computeNavSorted(initialHistory, initialActive),\n        packagingRevision: initialRevision\n    });\n\n    // Sync with props\n    useEffect(() => {\n        dispatch({\n            type: 'SYNC_FROM_PROPS',\n            payload: {\n                history: initialHistory,\n                currentVersion: initialCurrentVersion,\n                isDraft: initialIsDraft,\n                initialActiveVersion\n            }\n        });\n    }, [initialHistory, initialCurrentVersion, initialIsDraft, initialActiveVersion]);\n\n    // Derived values - always in sync with state\n    const sortedVersions = useMemo(() =>\n        [...state.packagingHistory].sort((a, b) => b.versionNumber - a.versionNumber),\n        [state.packagingHistory]\n    );\n\n    // Actions\n    const getVersionSnapshot = useCallback((versionNumber: number): PackagingSnapshot | null => {\n        const version = state.packagingHistory.find(v => v.versionNumber === versionNumber);\n        return version?.configurationSnapshot || null;\n    }, [state.packagingHistory]);\n\n    const switchToVersion = useCallback((versionNumber: number | 'draft', periodIndex?: number) => {\n        dispatch({ type: 'SWITCH_TO_VERSION', payload: { versionNumber, periodIndex } });\n    }, []);\n\n    const restoreVersion = useCallback((versionNumber: number, closingSnapshotId?: string | null): {\n        updatedHistory: PackagingVersion[]\n    } => {\n        const updatedHistory = state.packagingHistory.map(v => {\n            if (v.versionNumber === versionNumber) {\n                return addNewActivePeriod(closeAllPeriods(v, closingSnapshotId || null));\n            }\n            return closeAllPeriods(v, closingSnapshotId || null);\n        });\n\n        dispatch({ type: 'RESTORE_VERSION', payload: { versionNumber, closingSnapshotId: closingSnapshotId || null } });\n        return { updatedHistory };\n    }, [state.packagingHistory]);\n\n    const createVersion = useCallback((snapshot: PackagingSnapshot, closingSnapshotId?: string | null): {\n        newVersion: PackagingVersion;\n        updatedHistory: PackagingVersion[];\n        currentPackagingVersion: number;\n    } => {\n        let updatedHistory = state.packagingHistory.map(v => {\n            return closeAllPeriods(v, closingSnapshotId || null);\n        });\n\n        const newVersion: PackagingVersion = {\n            versionNumber: state.currentVersionNumber,\n            startDate: Date.now(),\n            endDate: null,\n            activePeriods: [{\n                startDate: Date.now(),\n                endDate: null,\n                closingSnapshotId: null\n            }],\n            checkins: [],\n            configurationSnapshot: snapshot,\n            revision: state.packagingRevision + 1\n        };\n\n        updatedHistory = [...updatedHistory, newVersion];\n\n        dispatch({ type: 'CREATE_VERSION', payload: { newVersion, updatedHistory, closingSnapshotId } });\n\n        return {\n            newVersion,\n            updatedHistory,\n            currentPackagingVersion: state.currentVersionNumber + 1\n        };\n    }, [state.packagingHistory, state.activeVersion, state.currentVersionNumber]);\n\n    const saveDraft = useCallback((closingSnapshotId?: string | null): {\n        updatedHistory: PackagingVersion[]\n    } => {\n        const updatedHistory = state.packagingHistory.map(v => {\n            return closeAllPeriods(v, closingSnapshotId || null);\n        });\n\n        dispatch({ type: 'SAVE_DRAFT', payload: { closingSnapshotId } });\n\n        return { updatedHistory };\n    }, [state.packagingHistory, state.activeVersion]);\n\n    const deleteVersion = useCallback((versionNumbers: number | number[]) => {\n        const payload = Array.isArray(versionNumbers) ? versionNumbers : [versionNumbers];\n        dispatch({ type: 'DELETE_VERSION', payload: { versionNumbers: payload } });\n    }, []);\n\n    const markDirty = useCallback(() => {\n        dispatch({ type: 'MARK_DIRTY' });\n    }, []);\n\n    const getVersionsPayload = useCallback(() => ({\n        packagingHistory: state.packagingHistory,\n        currentPackagingVersion: state.currentVersionNumber,\n        isDraft: state.hasDraft,\n        activeVersion: state.activeVersion\n    }), [state.packagingHistory, state.currentVersionNumber, state.hasDraft, state.activeVersion]);\n\n    // Direct setters for external sync\n    const setPackagingHistory = useCallback((history: PackagingVersion[] | ((prev: PackagingVersion[]) => PackagingVersion[])) => {\n        const newHistory = typeof history === 'function' ? history(state.packagingHistory) : history;\n        dispatch({\n            type: 'SYNC_FROM_PROPS',\n            payload: {\n                history: newHistory,\n                currentVersion: state.currentVersionNumber,\n                isDraft: state.hasDraft\n            }\n        });\n    }, [state.packagingHistory, state.currentVersionNumber, state.hasDraft]);\n\n    const setHasDraft = useCallback((value: boolean | ((prev: boolean) => boolean)) => {\n        const newValue = typeof value === 'function' ? value(state.hasDraft) : value;\n        dispatch({ type: 'SET_HAS_DRAFT', payload: newValue });\n    }, [state.hasDraft]);\n\n    const setActiveVersion = useCallback((versionNumber: number | 'draft', closingSnapshotId?: string | null) => {\n        dispatch({ type: 'SET_ACTIVE_VERSION', payload: { versionNumber, closingSnapshotId } });\n    }, []);\n\n    const setCurrentVersionNumber = useCallback((value: number | ((prev: number) => number)) => {\n        const newValue = typeof value === 'function' ? value(state.currentVersionNumber) : value;\n        dispatch({ type: 'SET_CURRENT_VERSION_NUMBER', payload: newValue });\n    }, [state.currentVersionNumber]);\n\n    // Compute next VISUAL version number (excluding clones)\n    // This is what users see in the UI, not the internal database version number\n    const nextVisualVersionNumber = useMemo(() => {\n        if (state.packagingHistory.length === 0) {\n            return 1; // First version\n        }\n\n        // Find all unique \"canonical\" versions (cloneOf || versionNumber)\n        // Since we map these sequentially (1, 2, 3...) in the UI, the next visual version\n        // is simply the count of unique groups + 1.\n        const canonicalVersions = new Set(\n            state.packagingHistory.map(v => v.cloneOf || v.versionNumber)\n        );\n\n        return canonicalVersions.size + 1;\n    }, [state.packagingHistory]);\n\n    return useMemo(() => ({\n        // State\n        packagingHistory: state.packagingHistory,\n        sortedVersions,\n        navSortedVersions: state.navSortedVersions,\n        currentVersionNumber: state.currentVersionNumber,\n        nextVisualVersionNumber, // Visual version number for UI (excludes clones)\n        hasDraft: state.hasDraft,\n        activeVersion: state.activeVersion,\n        viewingVersion: state.viewingVersion,\n        viewingPeriodIndex: state.viewingPeriodIndex,\n\n        // Actions\n        switchToVersion,\n        restoreVersion,\n        createVersion,\n        saveDraft,\n        deleteVersion,\n        markDirty,\n        getVersionSnapshot,\n        getVersionsPayload,\n\n        // Direct setters\n        setPackagingHistory,\n        setHasDraft,\n        setActiveVersion,\n        setCurrentVersionNumber\n    }), [\n        state,\n        sortedVersions,\n        switchToVersion,\n        restoreVersion,\n        createVersion,\n        saveDraft,\n        deleteVersion,\n        markDirty,\n        getVersionSnapshot,\n        getVersionsPayload,\n        setPackagingHistory,\n        setHasDraft,\n        setActiveVersion,\n        setCurrentVersionNumber\n    ]);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Packaging/utils/abTestRank.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/TrafficTab.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/TrafficTab.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'currentChannel'. Either include it or remove the dependency array.","line":409,"column":8,"nodeType":"ArrayExpression","endLine":409,"endColumn":100,"suggestions":[{"desc":"Update the dependencies array to be: [user.uid, currentChannel, selectedIds, getActiveSuggestion, assignVideoToTrafficNiche]","fix":{"range":[17476,17568],"text":"[user.uid, currentChannel, selectedIds, getActiveSuggestion, assignVideoToTrafficNiche]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useMemo, useCallback } from 'react';\nimport { TrafficTable, type SortConfig, type SortKey } from './components/TrafficTable';\nimport { TrafficHeader } from './components/TrafficHeader';\nimport { TrafficModals } from './components/TrafficModals';\nimport { TrafficFilterChips } from './components/TrafficFilterChips';\nimport { TrafficErrorState } from './components/TrafficErrorState';\nimport { TrafficFloatingBar } from './components/TrafficFloatingBar';\n// MissingTitlesModal is now wrapped in TrafficModals\nimport { useMissingTitles, repairTrafficSources } from './hooks/useMissingTitles';\nimport { generateTrafficCsv } from './utils/csvGenerator';\nimport { useApiKey } from '../../../../core/hooks/useApiKey';\nimport { useSuggestedVideos } from './hooks/useSuggestedVideos';\n\n\n// ... imports\n\nimport type { VideoDetails } from '../../../../core/utils/youtubeApi';\n\nimport { useTrafficSelection } from './hooks/useTrafficSelection';\nimport { useSettings } from '../../../../core/hooks/useSettings';\nimport { formatPremiumPeriod } from './utils/dateUtils';\nimport { useTrafficNicheStore } from '../../../../core/stores/useTrafficNicheStore';\nimport { useAuth } from '../../../../core/hooks/useAuth';\nimport { useChannelStore } from '../../../../core/stores/channelStore';\nimport { useVideos } from '../../../../core/hooks/useVideos';\nimport { useSmartNicheSuggestions } from './hooks/useSmartNicheSuggestions';\nimport { assistantLogger } from '../../../../core/utils/logger';\nimport { useTrafficTypeStore } from '../../../../core/stores/useTrafficTypeStore';\nimport { useSmartTrafficAutoApply } from './hooks/useSmartTrafficAutoApply';\nimport { useViewerTypeStore } from '../../../../core/stores/useViewerTypeStore';\nimport { useSmartViewerTypeAutoApply } from './hooks/useSmartViewerTypeAutoApply';\n\nimport type { TrafficSource } from '../../../../core/types/traffic';\n\ninterface TrafficTabProps {\n    video: VideoDetails;\n    activeVersion: number;\n    viewingVersion?: number | 'draft';\n    viewingPeriodIndex?: number;\n    selectedSnapshot?: string | null;\n    // Shared state from DetailsLayout\n    trafficData: import('../../../../core/types/traffic').TrafficData | null;\n    isLoadingData: boolean;\n    isSaving: boolean;\n    handleCsvUpload: (sources: TrafficSource[], totalRow?: TrafficSource, file?: File) => Promise<string | null>;\n    onSnapshotClick?: (id: string) => void;\n    packagingHistory?: import('../../../../core/types/versioning').PackagingVersion[]; // Passed to resolve version aliases\n    // Lifted Props\n    displayedSources: TrafficSource[];\n    viewMode: 'cumulative' | 'delta';\n    onViewModeChange: (mode: 'cumulative' | 'delta') => void;\n    isLoadingSnapshot: boolean;\n    error: Error | null;\n    retry: () => void;\n    // Niche Data\n    groups: import('../../../../core/types/traffic').TrafficGroup[];\n    // Filter Props (Lifted)\n    filters: import('../../../../core/types/traffic').TrafficFilter[];\n    onAddFilter: (filter: Omit<import('../../../../core/types/traffic').TrafficFilter, 'id'>) => void;\n    onRemoveFilter: (id: string) => void;\n    onClearFilters: () => void;\n    applyFilters: (sources: import('../../../../core/types/traffic').TrafficSource[], groups?: import('../../../../core/types/traffic').TrafficGroup[]) => import('../../../../core/types/traffic').TrafficSource[];\n    // Sorting (Lifted)\n    sortConfig: SortConfig | null;\n    onSort: (key: SortKey) => void;\n    actualTotalRow?: TrafficSource;\n    trashMetrics?: import('./hooks/useTrafficDataLoader').TrashMetrics;\n    deltaContext?: import('./hooks/useTrafficDataLoader').DeltaContext;\n}\n\nexport const TrafficTab: React.FC<TrafficTabProps> = ({\n    video: _video,\n    activeVersion,\n    viewingVersion,\n    viewingPeriodIndex = 0,\n    selectedSnapshot,\n    trafficData,\n    isLoadingData: isLoading,\n    handleCsvUpload,\n    onSnapshotClick,\n    packagingHistory = [],\n    // Lifted props\n    displayedSources,\n    viewMode,\n    onViewModeChange: setViewMode,\n    isLoadingSnapshot,\n    error,\n    retry,\n    groups,\n    filters,\n    onAddFilter: addFilter,\n    onRemoveFilter: removeFilter,\n    onClearFilters: clearFilters,\n\n    applyFilters,\n    sortConfig,\n    onSort,\n    actualTotalRow,\n    trashMetrics,\n    deltaContext\n}) => {\n    // Scroll detection for sticky header\n    const sentinelRef = useRef<HTMLDivElement>(null);\n    const [isScrolled, setIsScrolled] = useState(false);\n\n    // Modals State\n    const [isMapperOpen, setIsMapperOpen] = useState(false);\n    const [failedFile, setFailedFile] = useState<File | null>(null);\n    const [isMissingTitlesModalOpen, setIsMissingTitlesModalOpen] = useState(false);\n    const [missingTitlesVariant, setMissingTitlesVariant] = useState<'sync' | 'assistant'>('sync');\n\n    // Pending Upload State (for Pre-Upload Checks)\n    const [pendingUpload, setPendingUpload] = useState<{\n        sources: TrafficSource[],\n        totalRow?: TrafficSource,\n        file?: File\n    } | null>(null);\n\n    // Initial Auth & API Key\n    const { user } = useAuth();\n    const { apiKey } = useApiKey();\n    const { currentChannel } = useChannelStore();\n\n    // Video Data: Home Videos + Suggested Videos\n    const { videos: homeVideos } = useVideos(user?.uid || '', currentChannel?.id || '');\n    const { suggestedVideos } = useSuggestedVideos(user?.uid || '', currentChannel?.id || '');\n\n    // OPTIMIZATION: Merge home videos and suggested videos for tooltip lookup\n    const allVideos = useMemo(() => {\n        return [...homeVideos, ...suggestedVideos];\n    }, [homeVideos, suggestedVideos]);\n\n    // 1. Existing/Post-Load Missing Titles Logic\n    const {\n        missingCount: existingMissingCount,\n        unenrichedCount: existingUnenrichedCount,\n        estimatedQuota: existingEstimatedQuota,\n        fetchMissingTitles: fetchExistingMissingTitles,\n        isRestoring: isRestoringExisting\n    } = useMissingTitles({\n        displayedSources,\n        userId: user?.uid || '',\n        channelId: currentChannel?.id || '',\n        trafficVideoId: _video.id,\n        activeVersion,\n        apiKey: apiKey || '',\n        currentSnapshotId: selectedSnapshot,\n        cachedVideos: allVideos,\n        onDataRestored: (_newSources, newSnapshotId) => {\n            setIsMissingTitlesModalOpen(false);\n\n            // Force reload of traffic data (CSV) because in-place update won't change ID\n            if (retry) {\n                retry();\n            }\n\n            if (onSnapshotClick) {\n                onSnapshotClick(newSnapshotId); // Reload with new snapshot\n            }\n        },\n        trafficData\n    });\n\n    // 2. Pre-Upload Pending Logic\n    const pendingMissingCount = useMemo(() => {\n        if (!pendingUpload) return 0;\n        return pendingUpload.sources.filter(s => s.videoId && (!s.sourceTitle || s.sourceTitle.trim() === '')).length;\n    }, [pendingUpload]);\n\n    const pendingEstimatedQuota = Math.ceil(pendingMissingCount / 50) * 7;\n    const [isRestoringPending, setIsRestoringPending] = useState(false);\n\n    // Determines which \"mode\" the modal is in\n    const isPendingMode = !!pendingUpload;\n    const estimatedQuota = isPendingMode ? pendingEstimatedQuota : existingEstimatedQuota;\n    const isRestoring = isPendingMode ? isRestoringPending : isRestoringExisting;\n\n    // Auto-open modal if missing titles detected in displayed data (only if not pending)\n    // AND if user has not explicitly dismissed/handled it (could add flag, but current logic is fine)\n    useEffect(() => {\n        if (!pendingUpload && existingMissingCount > 0 && !isRestoringExisting) {\n            setIsMissingTitlesModalOpen(true);\n        }\n    }, [existingMissingCount, isRestoringExisting, pendingUpload]);\n\n\n    // Filter Logic and Selection...\n\n    const { selectedIds, toggleSelection, toggleAll } = useTrafficSelection();\n\n    // Niche Store Management - Consolidated\n    const {\n        niches: allNiches,\n        assignments: allAssignments,\n        assignVideoToTrafficNiche,\n        initializeSubscriptions,\n        cleanup\n    } = useTrafficNicheStore();\n\n    // Check if this is the first snapshot of a version (for specific message)\n    const isFirstSnapshot = React.useMemo(() => {\n        // 1. Specific Snapshot Selection\n        if (selectedSnapshot) {\n            const snapshots = trafficData?.snapshots || [];\n            const versionSnapshots = snapshots\n                .filter((s: import('../../../../core/types/traffic').TrafficSnapshot) => s.version === viewingVersion)\n                .sort((a: import('../../../../core/types/traffic').TrafficSnapshot, b: import('../../../../core/types/traffic').TrafficSnapshot) => a.timestamp - b.timestamp);\n            return versionSnapshots.length > 0 && versionSnapshots[0].id === selectedSnapshot;\n        }\n\n        // 2. Viewing a Version (History Mode)\n        if (viewingVersion !== 'draft' && packagingHistory.length > 0) {\n            // Sort history to find the absolute oldest version\n            const sortedHistory = [...packagingHistory].sort((a, b) => a.versionNumber - b.versionNumber);\n            const isOldestVersion = sortedHistory[0].versionNumber === viewingVersion;\n\n            // If we are viewing the oldest version AND the first period (start of time)\n            // Then this is effectively the \"First Snapshot\" state\n            if (isOldestVersion && (!viewingPeriodIndex || viewingPeriodIndex === 0)) {\n                return true;\n            }\n        }\n\n        return false;\n    }, [selectedSnapshot, viewingVersion, trafficData?.snapshots, packagingHistory, viewingPeriodIndex]);\n\n    // Traffic Type Store\n    const {\n        edges: trafficEdges,\n        initialize: initTrafficTypes,\n        setTrafficType: toggleTrafficType,\n        deleteTrafficType\n    } = useTrafficTypeStore();\n\n    // Viewer Type Store\n    const {\n        edges: viewerEdges,\n        initialize: initViewerTypes,\n        setViewerType: updateViewerType,\n        deleteViewerType: deleteViewerTypeRecord\n    } = useViewerTypeStore();\n\n    // Initialize store when video changes\n    useEffect(() => {\n        if (_video.id) {\n            initTrafficTypes(_video.id);\n            initViewerTypes(_video.id);\n        }\n    }, [_video.id, initTrafficTypes, initViewerTypes]);\n\n    // Filters are now managed by parent (DetailsLayout)\n    const filteredSources = useMemo(() => {\n        // Force empty if First Version in Delta Mode (Growth Analysis requires history)\n        if (viewMode === 'delta' && isFirstSnapshot) {\n            return [];\n        }\n\n        // Inject Traffic Type for Sorting/Filtering before applying other filters\n        // We do this by creating a synthetic property on the source objects if needed, \n        // but sorting is handled by the table using the edges map or we can enrich here.\n        // BETTER: Enrich here so \"applyFilters\" could potentially filter by type in future.\n        const enrichedSources = displayedSources.map(s => ({\n            ...s,\n            trafficType: s.videoId ? trafficEdges[s.videoId]?.type : undefined,\n            trafficSource: s.videoId ? trafficEdges[s.videoId]?.source : undefined,\n            viewerType: s.videoId ? viewerEdges[s.videoId]?.type : undefined,\n            viewerSource: s.videoId ? viewerEdges[s.videoId]?.source : undefined\n        }));\n\n        let sources = applyFilters(enrichedSources, groups);\n\n        // Global Trash Filter: Hide videos assigned to Trash\n        const trashNiche = allNiches.find(n => n.name.trim().toLowerCase() === 'trash');\n        const isFilteringTrash = trashNiche && filters.some(f => {\n            if (f.type !== 'niche') return false;\n            // Check for array or single value\n            if (Array.isArray(f.value)) {\n                return (f.value as string[]).includes(trashNiche.id);\n            }\n            return f.value === trashNiche.id;\n        });\n\n        if (trashNiche && !isFilteringTrash) {\n            const trashVideoIds = new Set(\n                allAssignments\n                    .filter(a => a.nicheId === trashNiche.id)\n                    .map(a => a.videoId)\n            );\n            sources = sources.filter(s => !s.videoId || !trashVideoIds.has(s.videoId));\n        }\n\n        return sources;\n    }, [displayedSources, applyFilters, groups, allNiches, allAssignments, viewMode, isFirstSnapshot, filters, trafficEdges, viewerEdges]);\n\n    // Handle Traffic Type Toggle\n    const handleToggleTrafficType = useCallback((videoId: string, currentType?: import('../../../../core/types/videoTrafficType').TrafficType) => {\n        // 3-State Cycle: Unknown -> Autoplay -> Click -> Unknown (delete)\n\n        if (!currentType) {\n            toggleTrafficType(videoId, 'autoplay', 'manual');\n        } else if (currentType === 'autoplay') {\n            toggleTrafficType(videoId, 'user_click', 'manual');\n        } else if (currentType === 'user_click') {\n            // Cycle back to unset\n            deleteTrafficType(videoId);\n        }\n    }, [toggleTrafficType, deleteTrafficType]);\n\n    // Handle Viewer Type Toggle\n    const handleToggleViewerType = useCallback((videoId: string, currentType?: import('../../../../core/types/viewerType').ViewerType) => {\n        // Cycle: bouncer -> trialist -> explorer -> interested -> core -> passive -> unset\n        const types: import('../../../../core/types/viewerType').ViewerType[] = ['bouncer', 'trialist', 'explorer', 'interested', 'core', 'passive'];\n\n        if (!currentType) {\n            updateViewerType(videoId, types[0], 'manual');\n        } else {\n            const index = types.indexOf(currentType);\n            if (index === types.length - 1) {\n                deleteViewerTypeRecord(videoId);\n            } else {\n                updateViewerType(videoId, types[index + 1], 'manual');\n            }\n        }\n    }, [updateViewerType, deleteViewerTypeRecord]);\n\n    // OPTIMIZATION: Memoize array props to prevent TrafficTable re-renders.\n    // Without memoization, `|| []` creates a new array reference each render.\n    const { trafficSettings } = useSettings();\n    const ctrRules = useMemo(() => trafficSettings?.ctrRules || [], [trafficSettings?.ctrRules]);\n    // groups is now passed as prop\n\n    // user and currentChannel hooks moved up\n\n    // Initialize niche subscriptions when user/channel are available\n    useEffect(() => {\n        if (user?.uid && currentChannel?.id) {\n            initializeSubscriptions(user.uid, currentChannel.id);\n        }\n        return () => {\n            cleanup();\n        };\n    }, [user?.uid, currentChannel?.id, initializeSubscriptions, cleanup]);\n\n    // Detect scroll for sticky header shadow\n    useEffect(() => {\n        const sentinel = sentinelRef.current;\n        if (!sentinel) return;\n        const observer = new IntersectionObserver(\n            ([entry]) => setIsScrolled(!entry.isIntersecting),\n            { threshold: 0 }\n        );\n        observer.observe(sentinel);\n        return () => observer.disconnect();\n    }, []);\n\n    // -------------------------------------------------------------------------\n    // SMART ASSISTANT LOGIC\n    // -------------------------------------------------------------------------\n    const [isAssistantEnabled, setIsAssistantEnabled] = useState(false);\n\n    // Auto-Apply Logic: Automatically tag videos as \"Autoplay\" if 0 Imp / >0 Views\n    useSmartTrafficAutoApply(isAssistantEnabled, filteredSources);\n\n    // Auto-Apply Viewer Types Logic\n    useSmartViewerTypeAutoApply(isAssistantEnabled, filteredSources, _video);\n\n    // Connect to the Store to get assignment history - ALREADY DESTRUCTURED ABOVE\n\n    const { getSuggestion } = useSmartNicheSuggestions(\n        displayedSources,\n        allAssignments,\n        allNiches,\n        allVideos\n    );\n\n    // Wrapper to respect the toggle state\n    const getActiveSuggestion = useCallback((videoId: string) => {\n        if (!isAssistantEnabled) return null;\n        const suggestion = getSuggestion(videoId);\n        return suggestion ? suggestion.targetNiche : null;\n    }, [isAssistantEnabled, getSuggestion]);\n\n    // Handle Confirmation (Single or Bulk)\n    const handleConfirmSuggestion = useCallback(async (videoId: string, targetNiche: import('../../../../core/types/suggestedTrafficNiches').SuggestedTrafficNiche) => {\n        if (!user?.uid || !currentChannel?.id) return;\n\n        // Check if we have multiple selected items including this one\n        const isBulkAction = selectedIds.has(videoId) && selectedIds.size > 1;\n\n        if (isBulkAction) {\n            // Bulk Confirm: Apply to ALL selected videos that have THIS SAME suggestion\n            // Logic: Iterate selected IDs -> check if they have a suggestion -> if match targetNiche -> assign\n            const promises: Promise<void>[] = [];\n\n            selectedIds.forEach(selectedId => {\n                const suggestion = getActiveSuggestion(selectedId);\n                // We confirm for all selected videos that are suggested the SAME niche\n                if (suggestion && suggestion.id === targetNiche.id) {\n                    promises.push(assignVideoToTrafficNiche(selectedId, targetNiche.id, user.uid, currentChannel!.id));\n                }\n            });\n\n            await Promise.all(promises);\n            // Optionally clear selection? keeping it seems better flow\n        } else {\n            // Single Confirm\n            await assignVideoToTrafficNiche(videoId, targetNiche.id, user.uid, currentChannel.id);\n        }\n    }, [user?.uid, currentChannel?.id, selectedIds, getActiveSuggestion, assignVideoToTrafficNiche]);\n\n    // -------------------------------------------------------------------------\n\n    const [isSkipping, setIsSkipping] = useState(false);\n\n    // Wrapper to catch upload errors and open mapper - memoized to prevent re-renders\n    const handleUploadWithErrorTracking = React.useCallback(async (sources: TrafficSource[], totalRow?: TrafficSource, file?: File) => {\n        // If sources is empty and we have a file, it means parsing failed\n        if (sources.length === 0 && file) {\n            setFailedFile(file);\n            setIsMapperOpen(true);\n            return;\n        }\n\n        let wasPatched = false;\n\n        // OPTIMIZATION: Try to patch missing titles from cache (allVideos) before checking\n        // This prevents the assistant modal from appearing if we already know the data\n        const patchedSources = sources.map(s => {\n            if (s.videoId && (!s.sourceTitle || s.sourceTitle.trim() === '')) {\n                const cachedVideo = allVideos.find(v => v.id === s.videoId);\n                if (cachedVideo) {\n                    wasPatched = true;\n                    return {\n                        ...s,\n                        sourceTitle: cachedVideo.title || s.sourceTitle,\n                        channelId: cachedVideo.channelId || s.channelId,\n                        // We can also patch other fields if needed\n                    };\n                }\n            }\n            return s;\n        });\n\n        // PRE-CHECK: Missing Titles (on patched data)\n        const hasMissingTitles = patchedSources.some((s: TrafficSource) => s.videoId && (!s.sourceTitle || s.sourceTitle.trim() === ''));\n\n        if (hasMissingTitles && file) {\n            setPendingUpload({ sources: patchedSources, totalRow, file });\n            setIsMissingTitlesModalOpen(true);\n            return;\n        }\n\n        try {\n            let finalFile = file;\n\n            // If we patched any data, we MUST regenerate the CSV file so that the\n            // patches are persisted in Storage (the source of truth)\n            if (wasPatched && file) {\n                const newCsvContent = generateTrafficCsv(patchedSources, totalRow);\n                finalFile = new File([newCsvContent], file.name, { type: \"text/csv\" });\n                assistantLogger.info('Regenerated CSV with patched titles from cache');\n            }\n\n            // Upload the patched sources and potentially regenerated file\n            const newSnapshotId = await handleCsvUpload(patchedSources, totalRow, finalFile);\n            if (newSnapshotId && onSnapshotClick) {\n                onSnapshotClick(newSnapshotId);\n            }\n        } catch (error) {\n            console.error('Upload failed:', error);\n        }\n    }, [handleCsvUpload, onSnapshotClick, allVideos]);\n\n    // Handler for Syncing Pending Upload\n    const handleConfirmPendingSync = async () => {\n        if (!pendingUpload) return;\n        setIsRestoringPending(true);\n        try {\n            // Repair sources\n            const repairedSources = await repairTrafficSources(\n                pendingUpload.sources,\n                user?.uid || '',\n                currentChannel?.id || '',\n                apiKey || '',\n                allVideos\n            );\n\n            // Generate new CSV from repaired sources\n            const newCsvContent = generateTrafficCsv(repairedSources, pendingUpload.totalRow);\n            const repairedFile = new File([newCsvContent], pendingUpload.file?.name || 'traffic_data.csv', { type: \"text/csv\" });\n\n            // Proceed with upload\n            const newSnapshotId = await handleCsvUpload(repairedSources, pendingUpload.totalRow, repairedFile);\n\n            if (newSnapshotId && onSnapshotClick) {\n                onSnapshotClick(newSnapshotId);\n            }\n\n            // Cleanup\n            setPendingUpload(null);\n            setIsMissingTitlesModalOpen(false);\n\n        } catch (err) {\n            console.error(\"Failed to repair pending upload:\", err);\n            // Optionally show error toast\n        } finally {\n            setIsRestoringPending(false);\n        }\n    };\n\n    const handleRepairConfirm = async () => {\n        await fetchExistingMissingTitles();\n        setIsMissingTitlesModalOpen(false);\n        // If we were prompted by the Assistant, auto-enable it after successful sync\n        if (missingTitlesVariant === 'assistant') {\n            setIsAssistantEnabled(true);\n        }\n    };\n\n    // Handler for Skipping Pending Sync (Upload as is)\n    const handleSkipPendingSync = async () => {\n        if (!pendingUpload || isSkipping || isRestoringPending) return;\n\n        setIsSkipping(true);\n        try {\n            // Upload original data (or whatever was patched before determining it was still incomplete)\n            const newSnapshotId = await handleCsvUpload(pendingUpload.sources, pendingUpload.totalRow, pendingUpload.file);\n\n            if (newSnapshotId && onSnapshotClick) {\n                onSnapshotClick(newSnapshotId);\n            }\n        } catch (err) {\n            console.error('Upload failed:', err);\n        } finally {\n            setPendingUpload(null);\n            setIsMissingTitlesModalOpen(false);\n            setIsSkipping(false);\n        }\n    };\n\n\n    // Derived UI State\n    const isViewingOldVersion = viewingVersion && viewingVersion !== activeVersion;\n    const headerTitle = 'Suggested Traffic';\n    const isEmpty = displayedSources.length === 0;\n\n    // OPTIMIZATION: Memoize FloatingBar props to prevent re-renders from affecting TrafficTable.\n    // These are stable references that only change when selection or data actually changes.\n    const selectedTrafficVideos = useMemo(\n        () => displayedSources.filter(s => s.videoId && selectedIds.has(s.videoId)),\n        [displayedSources, selectedIds]\n    );\n    const clearFloatingBar = React.useCallback(() => toggleAll([]), [toggleAll]);\n\n    /**\n     * BUSINESS LOGIC: Check if current viewing context has a snapshot with data\n     * \n     * This determines whether to show action buttons (Filter, CTR Settings, Update CSV).\n     * We need to check if there's a snapshot for the CURRENT PERIOD, not just any snapshot for the version.\n     * \n     * Cases:\n     * 1. Viewing a snapshot directly -> always has data (by definition)\n     * 2. Viewing active version -> check if current period has a snapshot\n     * 3. Viewing historical period -> check if that period has a snapshot\n     */\n    const hasExistingSnapshot = React.useMemo(() => {\n        // If viewing a specific snapshot, it exists by definition\n        if (selectedSnapshot) return true;\n\n        const snapshots = trafficData?.snapshots || [];\n\n        // Find snapshots for the viewing version\n        const versionSnapshots = snapshots.filter((s: import('../../../../core/types/traffic').TrafficSnapshot) => s.version === viewingVersion);\n        if (versionSnapshots.length === 0) return false;\n\n        // Get the period we're viewing\n        const versionData = packagingHistory.find((v: import('../../../../core/types/versioning').PackagingVersion) => v.versionNumber === viewingVersion);\n        if (!versionData?.activePeriods) return false;\n\n        const period = versionData.activePeriods[viewingPeriodIndex];\n        if (!period) return false;\n\n        // Check if any snapshot exists within this period's time range\n        const periodStart = period.startDate;\n        const periodEnd = period.endDate;\n\n        const hasSnapshotInPeriod = versionSnapshots.some((s: import('../../../../core/types/traffic').TrafficSnapshot) => {\n            const matchesStart = s.timestamp >= (periodStart - 5000);\n            const matchesEnd = periodEnd ? s.timestamp <= (periodEnd + 5000) : true;\n            return matchesStart && matchesEnd;\n        });\n\n        return hasSnapshotInPeriod;\n    }, [trafficData?.snapshots, viewingVersion, viewingPeriodIndex, selectedSnapshot, packagingHistory]);\n\n    // Compute Version Label (with Alias Support)\n    // Returns object with main label and optional period label for separate styling\n    const versionLabel = React.useMemo(() => {\n        if (viewingVersion === 'draft') return { main: 'Draft', period: null };\n        if (typeof viewingVersion === 'number') {\n            // 1. Build the map (same logic as PackagingNav)\n            const map = new Map<number, number>();\n            const canonicalIds = Array.from(new Set(\n                packagingHistory.map((v: import('../../../../core/types/versioning').PackagingVersion) => v.cloneOf || v.versionNumber)\n            )).sort((a: number, b: number) => a - b);\n\n            canonicalIds.forEach((id, index) => {\n                map.set(id, index + 1);\n            });\n\n            // 2. Get the visual number for current viewing version\n            const currentVersionData = packagingHistory.find((v: import('../../../../core/types/versioning').PackagingVersion) => v.versionNumber === viewingVersion);\n            const canonicalId = currentVersionData?.cloneOf || viewingVersion;\n            const visualNumber = map.get(canonicalId) || canonicalId;\n\n            const main = `Version ${visualNumber}`;\n            let period: string | null = null;\n\n            // 3. Add period label if version has multiple active periods\n            if (currentVersionData?.activePeriods && currentVersionData.activePeriods.length > 1) {\n                const periodData = currentVersionData.activePeriods[viewingPeriodIndex];\n                if (periodData) {\n                    period = formatPremiumPeriod(periodData.startDate, periodData.endDate ?? null);\n                }\n            }\n\n            return { main, period };\n        }\n        return null;\n    }, [viewingVersion, viewingPeriodIndex, packagingHistory]);\n\n    /**\n     * BUSINESS LOGIC: Check if there are snapshots in previous versions\n     * \n     * Determines if this is the \"first version with traffic data\".\n     * A version is \"first\" if its oldest active period has closingSnapshotId === null.\n     * This means there was no previous version active when this version was activated.\n     * \n     * Example: v.2 is first if it was activated without any previous version having data.\n     */\n    // Check if there are snapshots in previous versions (Global Time-Based)\n    const hasPreviousSnapshots = React.useMemo(() => {\n        if (!viewingVersion || viewingVersion === 'draft') return false;\n\n        // Find the current version's data\n        const currentVersionData = packagingHistory.find((v: import('../../../../core/types/versioning').PackagingVersion) => v.versionNumber === viewingVersion);\n        if (!currentVersionData?.activePeriods || currentVersionData.activePeriods.length === 0) {\n            return false;\n        }\n\n        // Get the period we're viewing\n        const viewingPeriod = currentVersionData.activePeriods[viewingPeriodIndex];\n        if (!viewingPeriod) return false;\n\n        // GLOBAL TIME-BASED CHECK:\n        // Are there any snapshots OLDER than this period's start?\n        // This matches the logic in useTrafficDataLoader\n        const allSnapshots = trafficData?.snapshots || [];\n        const hasOlderSnapshots = allSnapshots.some((s: import('../../../../core/types/traffic').TrafficSnapshot) => s.timestamp < viewingPeriod.startDate);\n\n        return hasOlderSnapshots;\n    }, [viewingVersion, viewingPeriodIndex, packagingHistory, trafficData?.snapshots]);\n\n    // Check if this is the first snapshot of a version (for specific message)\n\n\n    // Show actions if: data exists OR (empty but has snapshots - could be delta mode)\n    const shouldShowActions = !isEmpty || hasExistingSnapshot;\n\n    return (\n        <div className=\"flex-1 flex flex-col min-h-0\">\n            <div ref={sentinelRef} className=\"h-0\" />\n\n            {/* Sticky Header */}\n            <TrafficHeader\n                headerTitle={headerTitle}\n                versionLabel={versionLabel} // Use computed alias\n                isViewingOldVersion={!!isViewingOldVersion}\n                viewingVersion={viewingVersion}\n                shouldShowActions={shouldShowActions}\n                viewMode={viewMode}\n                onViewModeChange={setViewMode}\n                isLoading={isLoading}\n                hasExistingSnapshot={hasExistingSnapshot}\n                onUpload={handleUploadWithErrorTracking}\n                isScrolled={isScrolled}\n                filters={filters}\n                onAddFilter={addFilter}\n                onRemoveFilter={removeFilter}\n                groups={groups}\n                trafficSources={displayedSources}\n                missingTitlesCount={existingMissingCount}\n                onOpenMissingTitles={() => {\n                    setMissingTitlesVariant('sync');\n                    setIsMissingTitlesModalOpen(true);\n                }}\n                isAssistantEnabled={isAssistantEnabled}\n                onToggleAssistant={() => {\n                    assistantLogger.debug('onToggleAssistant clicked', {\n                        currentEnabled: isAssistantEnabled,\n                        missingCount: existingMissingCount,\n                        unenrichedCount: existingUnenrichedCount\n                    });\n\n                    // Smart Check: If we have missing titles OR unenriched data, prompt to sync first\n                    if (!isAssistantEnabled && (existingMissingCount > 0 || existingUnenrichedCount > 0)) {\n                        assistantLogger.info('Blocking assistant activation, prompting for sync');\n                        setMissingTitlesVariant('assistant');\n                        setIsMissingTitlesModalOpen(true);\n                        return;\n                    }\n                    assistantLogger.debug('Toggling assistant state');\n                    setIsAssistantEnabled(prev => !prev);\n                }}\n            />\n\n            {/* Main Content - Table Area */}\n            <div className=\"px-6 pb-0 pt-6 min-h-0 flex-1 flex flex-col overflow-hidden\">\n                <div className=\"w-full max-w-[1050px] relative flex-1 flex flex-col min-h-0\">\n                    {error ? (\n                        <div className=\"flex-1 min-h-[400px]\">\n                            <TrafficErrorState error={error} onRetry={retry} />\n                        </div>\n                    ) : (\n                        <>\n                            <TrafficFilterChips\n                                filters={filters}\n                                onRemoveFilter={removeFilter}\n                                onClearAll={clearFilters}\n                            />\n                            <div className=\"flex-1 min-h-0 relative w-full flex flex-col\">\n                                <TrafficTable\n                                    data={filteredSources}\n                                    selectedIds={selectedIds}\n                                    isLoading={isLoading || isLoadingSnapshot}\n                                    ctrRules={ctrRules}\n                                    viewMode={viewMode}\n                                    onToggleSelection={toggleSelection}\n                                    onToggleAll={toggleAll}\n                                    activeVersion={activeVersion}\n                                    viewingVersion={viewingVersion}\n                                    onUpload={handleUploadWithErrorTracking}\n                                    hasExistingSnapshot={hasExistingSnapshot}\n                                    hasPreviousSnapshots={hasPreviousSnapshots}\n                                    isFirstSnapshot={isFirstSnapshot}\n                                    isViewingSnapshot={!!selectedSnapshot}\n                                    hasActiveFilters={filters.length > 0}\n                                    onSwitchToTotal={() => setViewMode('cumulative')}\n                                    videos={allVideos}\n                                    sortConfig={sortConfig}\n                                    onSort={onSort}\n                                    getSuggestion={getActiveSuggestion}\n                                    onConfirmSuggestion={handleConfirmSuggestion}\n                                    actualTotalRow={actualTotalRow}\n                                    trashMetrics={trashMetrics}\n                                    deltaContext={deltaContext}\n                                    // Traffic Type Props\n                                    trafficEdges={trafficEdges}\n                                    onToggleTrafficType={handleToggleTrafficType}\n                                    // Viewer Type Props\n                                    viewerEdges={viewerEdges}\n                                    onToggleViewerType={handleToggleViewerType}\n                                />\n\n                                {/* Floating Action Bar - Positioned absolutely relative to parent container */}\n                                {selectedIds.size > 0 && (\n                                    <TrafficFloatingBar\n                                        videos={selectedTrafficVideos}\n                                        homeVideos={homeVideos}\n                                        position={{ x: 0, y: 0 }}\n                                        onClose={clearFloatingBar}\n                                        isDocked={true}\n                                        dockingStrategy=\"absolute\"\n                                    />\n                                )}\n                            </div>\n                        </>\n                    )}\n                </div>\n            </div>\n\n            {/* Modals */}\n            <TrafficModals\n                isMapperOpen={isMapperOpen}\n                failedFile={failedFile}\n                onMapperClose={() => setIsMapperOpen(false)}\n                onCsvUpload={handleCsvUpload}\n\n                // Missing Titles Props\n                isMissingTitlesOpen={isMissingTitlesModalOpen}\n                missingTitlesCount={isPendingMode ? pendingMissingCount : (existingMissingCount + existingUnenrichedCount)}\n                estimatedQuota={estimatedQuota}\n                onMissingTitlesConfirm={isPendingMode ? handleConfirmPendingSync : handleRepairConfirm}\n                onMissingTitlesClose={() => {\n                    if (isPendingMode) {\n                        handleSkipPendingSync();\n                    } else {\n                        setIsMissingTitlesModalOpen(false);\n                    }\n                }}\n                isRestoringTitles={isRestoring}\n                missingTitlesVariant={missingTitlesVariant}\n            />\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/CTRRulesList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/NicheColorPickerGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/TrafficNicheContextMenu.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/TrafficNicheContextMenu.tsx:51:13\n  49 |             const needsFlip = spaceBelow < rect.height + 10;\n  50 |\n> 51 |             setAdjustedStyle({\n     |             ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  52 |                 opacity: 1,\n  53 |                 left: position.x,\n  54 |                 top: needsFlip ? position.y - rect.height : position.y,","line":51,"column":13,"nodeType":null,"endLine":51,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6436,6439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6436,6439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useLayoutEffect, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Pencil, Trash2, Tag, ChevronLeft, CircleOff, Target, Flag, Layers } from 'lucide-react';\nimport type { SuggestedTrafficNiche, TrafficNicheProperty } from '@/core/types/suggestedTrafficNiches';\n\ninterface TrafficNicheContextMenuProps {\n    niche: SuggestedTrafficNiche;\n    isOpen: boolean;\n    onClose: () => void;\n    position: { x: number; y: number };\n    onRename: () => void;\n    onDelete: () => void;\n    onUpdateProperty: (property: TrafficNicheProperty) => void;\n}\n\nexport const TrafficNicheContextMenu: React.FC<TrafficNicheContextMenuProps> = ({\n    niche,\n    isOpen,\n    onClose,\n    position,\n    onRename,\n    onDelete,\n    onUpdateProperty\n}) => {\n    const [view, setView] = useState<'main' | 'properties'>('main');\n    const menuRef = useRef<HTMLDivElement>(null);\n    const [adjustedStyle, setAdjustedStyle] = useState<React.CSSProperties>({\n        opacity: 0,\n        left: position.x,\n        top: position.y\n    });\n\n    // Reset view on open/close\n    React.useEffect(() => {\n        if (!isOpen) {\n            setView('main');\n        }\n    }, [isOpen]);\n\n    // Calculate position to prevent clipping\n    useLayoutEffect(() => {\n        if (isOpen && menuRef.current) {\n            const rect = menuRef.current.getBoundingClientRect();\n            const viewportHeight = window.innerHeight;\n            const spaceBelow = viewportHeight - position.y;\n\n            // If space below is less than menu height (approx 150px safety), flip up\n            // Or measure actual height: rect.height\n            const needsFlip = spaceBelow < rect.height + 10;\n\n            setAdjustedStyle({\n                opacity: 1,\n                left: position.x,\n                top: needsFlip ? position.y - rect.height : position.y,\n            });\n        }\n    }, [isOpen, position, view]); // Re-calculate when view changes (height changes)\n\n    if (!isOpen) return null;\n\n    const renderMainView = () => (\n        <>\n            <button\n                key=\"rename\"\n                onClick={() => onRename()}\n                className=\"w-full text-left px-3 py-1.5 text-xs text-text-primary hover:bg-white/5 transition-colors flex items-center gap-2 rounded-md\"\n            >\n                <Pencil size={12} className=\"text-text-secondary\" />\n                Rename\n            </button>\n\n            <button\n                key=\"set-type\"\n                onClick={() => setView('properties')}\n                className=\"w-full text-left px-3 py-1.5 text-xs text-text-primary hover:bg-white/5 transition-colors flex items-center gap-2 rounded-md\"\n            >\n                <Tag size={12} className=\"text-text-secondary\" />\n                Set Type\n            </button>\n\n            <div className=\"h-px bg-white/10 my-1 mx-2\" />\n\n            <button\n                key=\"delete\"\n                onClick={onDelete}\n                className=\"w-full text-left px-3 py-1.5 text-xs text-red-400 hover:bg-white/5 transition-colors flex items-center gap-2 rounded-md\"\n            >\n                <Trash2 size={12} />\n                Delete\n            </button>\n        </>\n    );\n\n    const renderPropertiesView = () => (\n        <>\n            <div className=\"flex items-center gap-1 px-2 py-1 mb-1 border-b border-white/5\">\n                <button\n                    onClick={() => setView('main')}\n                    className=\"p-1 -ml-1 hover:bg-white/10 rounded-md text-text-secondary hover:text-white transition-colors\"\n                >\n                    <ChevronLeft size={12} />\n                </button>\n                <span className=\"text-[10px] text-text-tertiary uppercase font-medium tracking-wider\">\n                    Select Type\n                </span>\n            </div>\n\n            <button\n                key=\"unrelated\"\n                onClick={() => { onUpdateProperty('unrelated'); onClose(); }}\n                className=\"w-full text-left px-3 py-1.5 text-xs text-text-primary hover:bg-white/5 transition-colors flex items-center gap-2 rounded-md group\"\n            >\n                <CircleOff size={12} className={`transition-colors ${niche.property === 'unrelated' ? 'text-red-400' : 'text-text-secondary group-hover:text-red-400'}`} />\n                <span className={niche.property === 'unrelated' ? 'text-white font-medium' : ''}>Unrelated</span>\n            </button>\n\n            <button\n                key=\"adjacent\"\n                onClick={() => { onUpdateProperty('adjacent'); onClose(); }}\n                className=\"w-full text-left px-3 py-1.5 text-xs text-text-primary hover:bg-white/5 transition-colors flex items-center gap-2 rounded-md group\"\n            >\n                <Layers size={12} className={`transition-colors ${niche.property === 'adjacent' ? 'text-blue-400' : 'text-text-secondary group-hover:text-blue-400'}`} />\n                <span className={niche.property === 'adjacent' ? 'text-white font-medium' : ''}>Adjacent</span>\n            </button>\n\n            <button\n                key=\"targeted\"\n                onClick={() => { onUpdateProperty('targeted'); onClose(); }}\n                className=\"w-full text-left px-3 py-1.5 text-xs text-text-primary hover:bg-white/5 transition-colors flex items-center gap-2 rounded-md group\"\n            >\n                <Target size={12} className={`transition-all ${niche.property === 'targeted' ? 'text-yellow-400' : 'text-text-secondary group-hover:text-yellow-400'}`} />\n                <span className={niche.property === 'targeted' ? 'text-white font-medium' : ''}>Targeted</span>\n            </button>\n\n            <button\n                key=\"desired\"\n                onClick={() => { onUpdateProperty('desired'); onClose(); }}\n                className=\"w-full text-left px-3 py-1.5 text-xs text-text-primary hover:bg-white/5 transition-colors flex items-center gap-2 rounded-md group\"\n            >\n                <Flag size={12} className={`transition-colors ${niche.property === 'desired' ? 'text-emerald-400' : 'text-text-secondary group-hover:text-emerald-400'}`} />\n                <span className={niche.property === 'desired' ? 'text-white font-medium' : ''}>Desired</span>\n            </button>\n\n            <div className=\"h-px bg-white/10 my-1 mx-2\" />\n\n            <button\n                key=\"no-type\"\n                onClick={() => { onUpdateProperty(undefined as any); onClose(); }}\n                className=\"w-full text-left px-3 py-1.5 text-xs text-text-primary hover:bg-white/5 transition-colors flex items-center gap-2 rounded-md\"\n            >\n                <span className=\"w-3 h-3 block\" />\n                <span className={!niche.property ? 'text-white font-medium' : 'text-text-secondary'}>No Type</span>\n            </button>\n        </>\n    );\n\n    const content = (\n        <div\n            ref={menuRef}\n            className=\"fixed z-[9999] bg-bg-secondary/95 backdrop-blur-md border border-white/10 rounded-lg p-1 shadow-xl animate-fade-in min-w-[160px]\"\n            style={adjustedStyle}\n            onClick={(e) => e.stopPropagation()}\n        >\n            {view === 'main' ? renderMainView() : renderPropertiesView()}\n        </div>\n    );\n\n    return createPortal(\n        <>\n            <div className=\"fixed inset-0 z-[9998] cursor-default\" onClick={(e) => { e.stopPropagation(); onClose(); }} />\n            {content}\n        </>,\n        document.body\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/TrafficNicheItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/TrafficNicheSelector.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/TrafficNicheSelector.tsx:177:13\n  175 |         if (showCreateUI) {\n  176 |             const existingColors = niches.map(n => n.color);\n> 177 |             setSelectedColor(generateNicheColor(existingColors));\n      |             ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  178 |         }\n  179 |     }, [showCreateUI]); // Reset when UI appears\n  180 |","line":177,"column":13,"nodeType":null,"endLine":177,"endColumn":29},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'niches'. Either include it or remove the dependency array.","line":179,"column":8,"nodeType":"ArrayExpression","endLine":179,"endColumn":22,"suggestions":[{"desc":"Update the dependencies array to be: [niches, showCreateUI]","fix":{"range":[7289,7303],"text":"[niches, showCreateUI]"}}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/TrafficNicheSelector.tsx:196:13\n  194 |     useEffect(() => {\n  195 |         if (!isOpen) {\n> 196 |             setInputValue('');\n      |             ^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  197 |             setSelectedProperty(undefined);\n  198 |             setColorPickerState(null);\n  199 |             setHighlightedIndex(-1);","line":196,"column":13,"nodeType":null,"endLine":196,"endColumn":26},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/TrafficNicheSelector.tsx:206:9\n  204 |     // Reset highlighted index when filter changes\n  205 |     useEffect(() => {\n> 206 |         setHighlightedIndex(-1);\n      |         ^^^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  207 |     }, [filteredNiches, inputValue]);\n  208 |\n  209 |     // Scroll highlighted item into view","line":206,"column":9,"nodeType":null,"endLine":206,"endColumn":28}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useMemo } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Plus, CircleOff, Target, Flag, FolderPlus, ChevronDown, Layers, Check, MoreVertical, Trash2 } from 'lucide-react';\nimport { useTrafficNicheStore } from '@/core/stores/useTrafficNicheStore';\nimport { useAuth } from '@/core/hooks/useAuth';\nimport { useChannelStore } from '@/core/stores/channelStore';\nimport type { TrafficNicheProperty } from '@/core/types/suggestedTrafficNiches';\nimport { generateNicheColor } from '@/core/stores/trendStore';\nimport { TrafficNicheContextMenu } from './TrafficNicheContextMenu';\nimport { FloatingDropdownPortal } from '@/components/Shared/FloatingDropdownPortal';\nimport { NicheColorPickerGrid } from './NicheColorPickerGrid';\nimport { logger } from '@/core/utils/logger';\n\ninterface TrafficNicheSelectorProps {\n    videoIds: string[]; // Selected videos to assign\n    isOpen: boolean;\n    openAbove?: boolean;\n    onToggle: () => void;\n    onClose: () => void;\n    onSelectionClear?: () => void;\n}\n\nexport const TrafficNicheSelector: React.FC<TrafficNicheSelectorProps> = ({\n    videoIds,\n    isOpen,\n    openAbove = false,\n    onToggle,\n    onSelectionClear\n}) => {\n    const {\n        niches,\n        assignments,\n        addTrafficNiche,\n        updateTrafficNiche,\n        deleteTrafficNiche,\n        assignVideoToTrafficNiche,\n        removeVideoFromTrafficNiche\n    } = useTrafficNicheStore();\n\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n\n    // Single input for search AND create\n    const [inputValue, setInputValue] = useState('');\n    const [selectedProperty, setSelectedProperty] = useState<TrafficNicheProperty | undefined>(undefined);\n    const [selectedColor, setSelectedColor] = useState<string>('#3B82F6'); // Default init\n    // Centralized Color Picker State\n    const [colorPickerState, setColorPickerState] = useState<{\n        type: 'create' | 'edit';\n        nicheId?: string;\n        rect: DOMRect;\n    } | null>(null);\n\n    // Active menu state for mutually exclusive item menus\n    const [activeNicheMenuId, setActiveNicheMenuId] = useState<string | null>(null);\n    const [menuPosition, setMenuPosition] = useState<{ x: number; y: number }>({ x: 0, y: 0 });\n\n    // Rename State\n    const [editingNicheId, setEditingNicheId] = useState<string | null>(null);\n    const [editValue, setEditValue] = useState('');\n\n    const [anchorRect, setAnchorRect] = useState<DOMRect | null>(null);\n\n    const buttonRef = useRef<HTMLButtonElement>(null);\n    const inputRef = useRef<HTMLInputElement>(null);\n    const listRef = useRef<HTMLDivElement>(null);\n\n    // Keyboard navigation\n    const [highlightedIndex, setHighlightedIndex] = useState(-1);\n\n    // --- Derived Logic ---\n\n    const isMultiSelect = videoIds.length > 1;\n\n    // Determine what to display on the button\n    const displayNiche = useMemo(() => {\n        if (isMultiSelect) return null;\n        const videoId = videoIds[0];\n        if (!videoId) return null;\n\n        // Find assignments for this single video\n        const videoAssignments = assignments.filter(a => a.videoId === videoId);\n        if (videoAssignments.length === 0) return null;\n\n        // Sort by property priority or just pick first? \n        // Trends sorts by viewCount then addedAt. We don't have viewCount on niche easily here without join.\n        // Let's just pick the first one for now or last added? \n        // Trends logic: sort by view count desc, then addedAt asc.\n        // We will just pick the first found niche object.\n        const assignedNicheIds = videoAssignments.map(a => a.nicheId);\n        const assignedNiches = niches.filter(n => assignedNicheIds.includes(n.id));\n\n        if (assignedNiches.length === 0) return null;\n        return assignedNiches[0];\n    }, [videoIds, assignments, niches, isMultiSelect]);\n\n    // Assignments Map: nicheId -> 'all' | 'some' | 'none' for the selected videos\n    const nicheStatusMap = useMemo(() => {\n        const status: Record<string, 'all' | 'some' | 'none'> = {};\n\n        niches.forEach(niche => {\n            const relevantAssignments = assignments.filter(a => a.nicheId === niche.id);\n            const assignedVidIds = relevantAssignments.map(a => a.videoId);\n            const count = videoIds.filter(vidId => assignedVidIds.includes(vidId)).length;\n\n            if (count === 0) status[niche.id] = 'none';\n            else if (count === videoIds.length) status[niche.id] = 'all';\n            else status[niche.id] = 'some';\n        });\n\n        return status;\n    }, [niches, assignments, videoIds]);\n\n    // Filter niches based on input\n    const filteredNiches = useMemo(() => {\n        // 1. Calculate Last Used map\n        const lastUsedMap = new Map<string, number>();\n        assignments.forEach(a => {\n            const current = lastUsedMap.get(a.nicheId) || 0;\n            if (a.addedAt > current) {\n                lastUsedMap.set(a.nicheId, a.addedAt);\n            }\n        });\n\n        // 2. Sort all niches\n        const sorted = [...niches]\n            // Filter out Trash from this selector as it has a designated button\n            .filter(n => n.name.trim().toLowerCase() !== 'trash')\n            .sort((a, b) => {\n                const lastUsedA = lastUsedMap.get(a.id) || 0;\n                const lastUsedB = lastUsedMap.get(b.id) || 0;\n\n                if (lastUsedA !== lastUsedB) {\n                    return lastUsedB - lastUsedA; // Recent first\n                }\n                // Fallback to creation time\n                return b.createdAt - a.createdAt;\n            });\n\n        // 3. Filter\n        if (!inputValue.trim()) return sorted;\n\n        const searchTerms = inputValue.toLowerCase().trim().split(/\\s+/);\n        return sorted.filter(n => {\n            const nameLower = n.name.toLowerCase();\n            return searchTerms.every(term => nameLower.includes(term));\n        });\n    }, [niches, inputValue, assignments]);\n\n    // Fast Create UI Logic\n    const exactMatch = useMemo(() => {\n        const trimmed = inputValue.trim();\n        if (!trimmed) return null;\n        return niches.find(n => n.name.toLowerCase() === trimmed.toLowerCase());\n    }, [niches, inputValue]);\n\n    // Initial random color when showing Create UI\n    useEffect(() => {\n        if (inputValue.trim() && !exactMatch) {\n            // Only set if we haven't manually picked one? \n            // Better: just set a random one once when invalid -> valid transition happens\n            // Or just on mount? No.\n            // Let's just rely on the user or default.\n            // Actually, let's pick a random one on input start if not set.\n            // But state persistence is tricky.\n            // Let's just generate one when `showCreateUI` becomes true.\n        }\n    }, [inputValue, exactMatch]);\n\n    const showCreateUI = inputValue.trim() && !exactMatch;\n\n    // Better approach: when showCreateUI becomes true, set a random color if not already set or randomized recently.\n    // For simplicity, let's just use a memoized random color or effect.\n    useEffect(() => {\n        if (showCreateUI) {\n            const existingColors = niches.map(n => n.color);\n            setSelectedColor(generateNicheColor(existingColors));\n        }\n    }, [showCreateUI]); // Reset when UI appears\n\n    // --- Effects ---\n\n    // Auto-focus input when opening\n    useEffect(() => {\n        if (isOpen && buttonRef.current) {\n            setAnchorRect(buttonRef.current.getBoundingClientRect());\n            setTimeout(() => inputRef.current?.focus(), 50);\n        } else {\n            setAnchorRect(null);\n        }\n    }, [isOpen]);\n\n    // Reset state on close\n    useEffect(() => {\n        if (!isOpen) {\n            setInputValue('');\n            setSelectedProperty(undefined);\n            setColorPickerState(null);\n            setHighlightedIndex(-1);\n            setActiveNicheMenuId(null);\n        }\n    }, [isOpen]);\n\n    // Reset highlighted index when filter changes\n    useEffect(() => {\n        setHighlightedIndex(-1);\n    }, [filteredNiches, inputValue]);\n\n    // Scroll highlighted item into view\n    useEffect(() => {\n        if (highlightedIndex >= 0 && listRef.current) {\n            const item = listRef.current.children[highlightedIndex]?.querySelector?.('div[role=\"button\"]') || listRef.current.children[highlightedIndex] as HTMLElement;\n            if (item) {\n                item.scrollIntoView({ block: 'nearest' });\n            }\n        }\n    }, [highlightedIndex]);\n\n    // --- Handlers ---\n\n    const handleCreateSubmit = async (e: React.FormEvent) => {\n        e.preventDefault();\n        const trimmed = inputValue.trim();\n        if (!trimmed || !user || !currentChannel) return;\n\n        try {\n            const newId = crypto.randomUUID();\n            // Use selected color\n            const newColor = selectedColor;\n\n            await addTrafficNiche({\n                id: newId,\n                name: trimmed,\n                channelId: currentChannel.id,\n                // Only include property if defined (Firestore rejects undefined)\n                ...(selectedProperty ? { property: selectedProperty } : {}),\n                color: newColor\n            }, user.uid, currentChannel.id);\n\n            await Promise.all(videoIds.map(vidId =>\n                assignVideoToTrafficNiche(vidId, newId, user.uid, currentChannel.id)\n            ));\n\n            // Close UI only AFTER success\n            onToggle();\n            onSelectionClear?.();\n            setInputValue('');\n            setSelectedProperty(undefined);\n\n        } catch (error: unknown) {\n            logger.error('Failed to create niche', { component: 'TrafficNicheSelector', error });\n        }\n    };\n\n    const handleToggleAssignment = async (nicheId: string, currentStatus: 'all' | 'some' | 'none') => {\n        if (!user || !currentChannel) return;\n\n        const shouldAdd = currentStatus !== 'all';\n\n        await Promise.all(videoIds.map(async (vidId) => {\n            if (shouldAdd) {\n                const assigned = assignments.some(a => a.videoId === vidId && a.nicheId === nicheId);\n                if (!assigned) {\n                    await assignVideoToTrafficNiche(vidId, nicheId, user.uid, currentChannel.id);\n                }\n            } else {\n                await removeVideoFromTrafficNiche(vidId, nicheId, user.uid, currentChannel.id);\n            }\n        }));\n    };\n\n    const handleRenameSubmit = async (nicheId: string) => {\n        const trimmed = editValue.trim();\n        if (!trimmed || !user || !currentChannel) {\n            setEditingNicheId(null);\n            return;\n        }\n\n        try {\n            await updateTrafficNiche(nicheId, { name: trimmed }, user.uid, currentChannel.id);\n            setEditingNicheId(null);\n        } catch (error: unknown) {\n            logger.error('Failed to rename niche', { component: 'TrafficNicheSelector', error });\n        }\n    };\n\n    const handleColorSelect = async (color: string) => {\n        if (!colorPickerState) return;\n\n        if (colorPickerState.type === 'create') {\n            setSelectedColor(color);\n        } else if (colorPickerState.type === 'edit' && colorPickerState.nicheId) {\n            if (user && currentChannel) {\n                await updateTrafficNiche(colorPickerState.nicheId, { color }, user.uid, currentChannel.id);\n            }\n        }\n        setColorPickerState(null);\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n        if (filteredNiches.length === 0) return;\n\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n            // INVERTED LOGIC: Arrow UP goes \"visually up\", which means deeper into the array (index increments)\n            // Input -> Index 0 -> Index 1 -> ...\n            setHighlightedIndex(prev => {\n                const next = prev + 1;\n                return next >= filteredNiches.length ? prev : next;\n            });\n        }\n        else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n            // INVERTED LOGIC: Arrow DOWN goes \"visually down\", which means towards the input (index decrements)\n            // Index 1 -> Index 0 -> Input (-1)\n            setHighlightedIndex(prev => {\n                const next = prev - 1;\n                return next < -1 ? -1 : next;\n            });\n        }\n        else if (e.key === 'Enter') {\n            e.preventDefault();\n            if (highlightedIndex >= 0) {\n                const niche = filteredNiches[highlightedIndex];\n                if (niche) {\n                    const status = nicheStatusMap[niche.id];\n                    handleToggleAssignment(niche.id, status);\n                }\n            } else if (inputValue.trim()) {\n                // Submit form if input has value (Create)\n                handleCreateSubmit(e);\n            }\n        }\n        else if (e.key === 'Escape') {\n            e.preventDefault();\n            onToggle();\n        }\n    };\n\n    return (\n        <div className=\"relative\">\n            {/* Encapsulated Trigger Button */}\n            <button\n                ref={buttonRef}\n                onClick={onToggle}\n                className={`\n                    relative flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-medium transition-all whitespace-nowrap\n                    before:absolute before:inset-[-8px] before:content-['']\n                    ${displayNiche ? 'bg-white/10 text-white' : 'bg-white/10 hover:bg-white/20 text-white'}\n                    ${isOpen ? 'ring-1 ring-white/30' : ''}\n                `}\n                style={{ backgroundColor: displayNiche?.color ? `${displayNiche.color}20` : undefined }}\n            >\n                {displayNiche ? (\n                    <>\n                        <div className=\"w-2 h-2 rounded-full flex-shrink-0\" style={{ backgroundColor: displayNiche.color }} />\n                        <span className=\"truncate max-w-[120px]\">{displayNiche.name}</span>\n                        {/* Check assignment count if > 1 */}\n                        {videoIds[0] && assignments.filter(a => a.videoId === videoIds[0]).length > 1 && (\n                            <span className=\"text-[10px] text-text-secondary\">\n                                +{assignments.filter(a => a.videoId === videoIds[0]).length - 1}\n                            </span>\n                        )}\n                    </>\n                ) : (\n                    <>\n                        <FolderPlus size={16} />\n                        {isMultiSelect ? 'Assign Niches' : 'Assign Niche'}\n                    </>\n                )}\n                <ChevronDown size={12} className={`transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} />\n            </button>\n\n            {/* Portal Dropdown */}\n            <FloatingDropdownPortal\n                isOpen={isOpen}\n                anchorRect={anchorRect}\n                openAbove={openAbove}\n                width={240}\n            >\n                <div data-portal-wrapper className=\"flex flex-col h-full min-h-0\">\n                    {/* List Section (Now First in DOM, taking remaining space) */}\n                    {/* flex-col-reverse puts the first item (Index 0 - Most Recent) at the bottom, near the input */}\n                    <div\n                        ref={listRef}\n                        className=\"flex-1 overflow-y-auto custom-scrollbar p-1 flex flex-col-reverse\"\n                    >\n                        {filteredNiches.map((niche, index) => {\n                            const status = nicheStatusMap[niche.id];\n                            const isHighlighted = index === highlightedIndex;\n\n                            // Helper for property icon\n                            const getPropertyIcon = (prop?: TrafficNicheProperty) => {\n                                switch (prop) {\n                                    case 'unrelated': return <CircleOff size={12} className=\"text-red-400\" />;\n                                    case 'adjacent': return <Layers size={12} className=\"text-blue-400\" />;\n                                    case 'targeted': return <Target size={12} className=\"text-yellow-400\" />;\n                                    case 'desired': return <Flag size={12} className=\"text-emerald-400\" />;\n                                    default: return null;\n                                }\n                            };\n\n                            // Special styling for Trash at the bottom (Index 0 in col-reverse)\n                            const isTrash = niche.name.trim().toLowerCase() === 'trash';\n                            const showSeparator = isTrash && index === 0 && filteredNiches.length > 1;\n\n                            return (\n                                <div\n                                    key={niche.id}\n                                    role=\"button\"\n                                    onClick={() => handleToggleAssignment(niche.id, status)}\n                                    // Use standard compact padding matching PlaylistSelector\n                                    className={`\n                                        group flex items-center justify-between px-3 py-2 text-xs rounded-lg cursor-pointer transition-all duration-200 shrink-0\n                                        ${isHighlighted ? 'bg-white/10 text-white' : 'text-text-secondary hover:text-white hover:bg-white/5'}\n                                        ${showSeparator ? 'mt-2 border-t border-white/10 pt-2 rounded-t-none' : ''}\n                                    `}\n                                >\n                                    <div className=\"flex items-center gap-2 min-w-0 flex-1\">\n                                        {/* Color Dot or Trash Icon */}\n                                        {isTrash ? (\n                                            <div className=\"w-4 flex justify-center shrink-0\">\n                                                <Trash2 size={12} className=\"text-text-secondary\" />\n                                            </div>\n                                        ) : (\n                                            <button\n                                                type=\"button\"\n                                                onClick={(e) => {\n                                                    e.stopPropagation();\n                                                    setColorPickerState({\n                                                        type: 'edit',\n                                                        nicheId: niche.id,\n                                                        rect: e.currentTarget.getBoundingClientRect()\n                                                    });\n                                                    setActiveNicheMenuId(null);\n                                                }}\n                                                className=\"w-2 h-2 rounded-full flex-shrink-0 transition-transform hover:scale-125 hover:ring-2 hover:ring-white/20\"\n                                                style={{ backgroundColor: niche.color }}\n                                            />\n                                        )}\n\n                                        {/* Property Icon */}\n                                        {!isTrash && niche.property && (\n                                            <div className=\"flex-shrink-0 opacity-80\">\n                                                {getPropertyIcon(niche.property)}\n                                            </div>\n                                        )}\n\n                                        {/* Name / Rename Input */}\n                                        {!isTrash && editingNicheId === niche.id ? (\n                                            <input\n                                                autoFocus\n                                                type=\"text\"\n                                                className=\"bg-transparent text-white text-xs px-0 py-0.5 border-b border-white/30 focus:outline-none focus:border-white/60 w-full rounded-none\"\n                                                value={editValue}\n                                                onChange={(e) => setEditValue(e.target.value)}\n                                                onKeyDown={(e) => {\n                                                    if (e.key === 'Enter') {\n                                                        e.preventDefault();\n                                                        handleRenameSubmit(niche.id);\n                                                    } else if (e.key === 'Escape') {\n                                                        setEditingNicheId(null);\n                                                    }\n                                                }}\n                                                onBlur={() => handleRenameSubmit(niche.id)}\n                                                onClick={(e) => e.stopPropagation()}\n                                            />\n                                        ) : (\n                                            <span className=\"truncate\" title={niche.name}>\n                                                {isTrash ? 'Trash' : niche.name}\n                                            </span>\n                                        )}\n                                    </div>\n\n                                    {/* Actions / Status */}\n                                    <div className=\"flex items-center gap-2 pl-2\">\n                                        {status === 'all' && <Check size={14} className=\"text-green-400\" />}\n                                        {status === 'some' && <div className=\"w-2 h-2 rounded-full bg-text-secondary\" />}\n\n                                        {/* Context Menu Trigger (Hide for Trash) */}\n                                        {!isTrash && (\n                                            <button\n                                                type=\"button\"\n                                                onClick={(e) => {\n                                                    e.stopPropagation();\n                                                    const rect = e.currentTarget.getBoundingClientRect();\n                                                    setMenuPosition({ x: rect.left, y: rect.bottom });\n                                                    setActiveNicheMenuId(activeNicheMenuId === niche.id ? null : niche.id);\n                                                }}\n                                                className={`p-1 rounded-md text-text-tertiary hover:text-white hover:bg-white/10 opacity-0 group-hover:opacity-100 transition-all\n                                                    ${activeNicheMenuId === niche.id ? 'opacity-100 bg-white/10 text-white' : ''}\n                                                `}\n                                            >\n                                                <MoreVertical size={12} />\n                                            </button>\n                                        )}\n\n                                        {/* Dropdown Menu Portal */}\n                                        {activeNicheMenuId === niche.id && (\n                                            <TrafficNicheContextMenu\n                                                niche={niche}\n                                                isOpen={true}\n                                                onClose={() => setActiveNicheMenuId(null)}\n                                                position={menuPosition}\n                                                onRename={() => {\n                                                    setEditingNicheId(niche.id);\n                                                    setEditValue(niche.name);\n                                                    setActiveNicheMenuId(null);\n                                                }}\n                                                onDelete={() => {\n                                                    deleteTrafficNiche(niche.id, user?.uid || '', currentChannel?.id || '');\n                                                }}\n                                                onUpdateProperty={(prop) => {\n                                                    updateTrafficNiche(niche.id, { property: prop }, user?.uid || '', currentChannel?.id || '');\n                                                }}\n                                            />\n                                        )}\n                                    </div>\n                                </div>\n                            );\n                        })}\n                        {filteredNiches.length === 0 && (\n                            <div className=\"p-4 text-center text-xs text-text-tertiary\">\n                                {inputValue ? 'Create new niche below...' : 'Start typing to create...'}\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Input Section (Now at the Bottom) */}\n                    <div className=\"p-2 border-t border-white/10 bg-white/5 shrink-0 z-10\">\n                        <form onSubmit={handleCreateSubmit} className=\"relative flex flex-col gap-2\">\n                            <div className=\"relative\">\n                                <input\n                                    ref={inputRef}\n                                    type=\"text\"\n                                    placeholder=\"Search or create niche...\"\n                                    className=\"w-full bg-bg-primary text-white text-xs px-3 py-2 pl-8 rounded-lg focus:outline-none focus:ring-1 focus:ring-white/20 placeholder:text-text-secondary\"\n                                    value={inputValue}\n                                    onChange={(e) => setInputValue(e.target.value)}\n                                    // Don't override handler, use the one defined in component which handles ArrowUp/Down\n                                    onKeyDown={handleKeyDown}\n                                    onClick={() => setActiveNicheMenuId(null)}\n                                    onFocus={() => setActiveNicheMenuId(null)}\n                                />\n                                <Plus size={14} className=\"absolute left-2.5 top-1/2 -translate-y-1/2 text-text-secondary\" />\n                            </div>\n\n                            {showCreateUI && (\n                                <div className=\"flex items-center gap-2 px-1 py-1 animate-in fade-in slide-in-from-bottom-1 duration-200\">\n                                    {/* Property Switcher - Compact & Premium */}\n                                    <div className=\"relative flex bg-white/5 rounded-full p-0.5 border border-white/10 backdrop-blur-sm h-6 flex-shrink-0\">\n                                        {/* Highlight Pill */}\n                                        <div\n                                            className={`\n                                                absolute top-0.5 bottom-0.5 rounded-full transition-all duration-300 ease-out shadow-sm\n                                                ${!selectedProperty ? 'opacity-0 scale-90' : 'opacity-100 scale-100'}\n                                                ${selectedProperty === 'unrelated' ? 'bg-gradient-to-r from-red-500 to-red-600 w-[24px]' : ''}\n                                                ${selectedProperty === 'adjacent' ? 'bg-gradient-to-r from-blue-400 to-blue-500 w-[24px]' : ''}\n                                                ${selectedProperty === 'targeted' ? 'bg-gradient-to-r from-yellow-300 to-yellow-500 w-[24px]' : ''}\n                                                ${selectedProperty === 'desired' ? 'bg-gradient-to-r from-emerald-400 to-emerald-500 w-[24px]' : ''}\n                                            `}\n                                            style={{\n                                                left: selectedProperty === 'unrelated' ? '2px' :\n                                                    selectedProperty === 'adjacent' ? '30px' :\n                                                        selectedProperty === 'targeted' ? '58px' :\n                                                            '86px'\n                                            }}\n                                        />\n\n                                        {/* Buttons */}\n                                        <div className=\"flex gap-1 relative z-10\">\n                                            <button\n                                                type=\"button\"\n                                                onClick={() => setSelectedProperty('unrelated')}\n                                                className={`w-6 h-5 flex items-center justify-center rounded-full transition-all duration-200 \n                                                    ${selectedProperty === 'unrelated' ? 'text-white' : 'text-stone-400 hover:text-stone-300 hover:bg-white/5'}\n                                                `}\n                                                title=\"Unrelated\"\n                                            >\n                                                <CircleOff size={10} className={selectedProperty === 'unrelated' ? 'scale-110' : ''} />\n                                            </button>\n                                            <button\n                                                type=\"button\"\n                                                onClick={() => setSelectedProperty('adjacent')}\n                                                className={`w-6 h-5 flex items-center justify-center rounded-full transition-all duration-200 \n                                                    ${selectedProperty === 'adjacent' ? 'text-white' : 'text-white/40 hover:text-blue-400 hover:bg-white/5'}\n                                                `}\n                                                title=\"Adjacent\"\n                                            >\n                                                <Layers size={10} className={selectedProperty === 'adjacent' ? 'scale-110' : ''} />\n                                            </button>\n                                            <button\n                                                type=\"button\"\n                                                onClick={() => setSelectedProperty('targeted')}\n                                                className={`w-6 h-5 flex items-center justify-center rounded-full transition-all duration-200 \n                                                    ${selectedProperty === 'targeted' ? 'text-black/80' : 'text-white/40 hover:text-yellow-400 hover:bg-white/5'}\n                                                `}\n                                                title=\"Targeted\"\n                                            >\n                                                <Target size={10} className={selectedProperty === 'targeted' ? 'scale-110' : ''} />\n                                            </button>\n                                            <button\n                                                type=\"button\"\n                                                onClick={() => setSelectedProperty('desired')}\n                                                className={`w-6 h-5 flex items-center justify-center rounded-full transition-all duration-200 \n                                                    ${selectedProperty === 'desired' ? 'text-white' : 'text-white/40 hover:text-emerald-400 hover:bg-white/5'}\n                                                `}\n                                                title=\"Desired\"\n                                            >\n                                                <Flag size={10} className={selectedProperty === 'desired' ? 'scale-110' : ''} />\n                                            </button>\n                                        </div>\n                                    </div>\n\n                                    {/* Color Picker Trigger */}\n                                    <div className=\"relative\">\n                                        <button\n                                            type=\"button\"\n                                            onClick={(e) => {\n                                                e.stopPropagation();\n                                                setColorPickerState(colorPickerState?.type === 'create' ? null : {\n                                                    type: 'create',\n                                                    rect: e.currentTarget.getBoundingClientRect()\n                                                });\n                                            }}\n                                            className=\"group relative w-5 h-5 flex items-center justify-center focus:outline-none\"\n                                        >\n                                            <div\n                                                className=\"w-2.5 h-2.5 rounded-full shadow-sm ring-1 ring-white/20 group-hover:ring-white/40 transition-all group-hover:scale-110\"\n                                                style={{ backgroundColor: selectedColor }}\n                                            />\n                                        </button>\n                                    </div>\n\n                                    <div className=\"flex-1\" />\n\n                                    {/* Create Button - Subtle */}\n                                    <button\n                                        type=\"submit\"\n                                        className=\"h-6 px-3 bg-white/10 hover:bg-white/20 text-white text-[10px] font-medium rounded-full transition-colors flex items-center gap-1\"\n                                    >\n                                        Create\n                                    </button>\n                                </div>\n                            )}\n                        </form>\n                    </div>\n                </div>\n            </FloatingDropdownPortal>\n\n            {/* Centralized Color Picker Portal */}\n            {colorPickerState && createPortal(\n                <>\n                    <div\n                        className=\"fixed inset-0 z-[100050]\"\n                        onClick={() => setColorPickerState(null)}\n                    />\n                    <div\n                        className=\"fixed z-[100051] bg-[#1a1a1a] border border-white/10 rounded-xl p-3 shadow-xl animate-in zoom-in-95 duration-100 w-[240px]\"\n                        style={{\n                            top: Math.min(window.innerHeight - 200, colorPickerState.rect.bottom + 8),\n                            left: Math.max(8, Math.min(window.innerWidth - 248, colorPickerState.rect.left - 110))\n                        }}\n                        onClick={(e) => e.stopPropagation()}\n                    >\n                        <div className=\"text-[10px] uppercase text-text-tertiary font-bold mb-2 tracking-wider px-1\">\n                            {colorPickerState.type === 'create' ? 'Select Color' : 'Edit Color'}\n                        </div>\n                        <NicheColorPickerGrid\n                            selectedColor={\n                                colorPickerState.type === 'edit'\n                                    ? (niches.find(n => n.id === colorPickerState.nicheId)?.color || selectedColor)\n                                    : selectedColor\n                            }\n                            onSelect={handleColorSelect}\n                        />\n                    </div>\n                </>,\n                document.body\n            )}\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/Niches/TrafficSidebarNicheList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/SmartTrafficTooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficCTRConfig.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficEmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficErrorState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficFilterChips.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficFilterInputNiche.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useLayoutEffect has a missing dependency: 'fixedWidth'. Either include it or remove the dependency array.","line":41,"column":8,"nodeType":"ArrayExpression","endLine":41,"endColumn":10,"suggestions":[{"desc":"Update the dependencies array to be: [fixedWidth]","fix":{"range":[1471,1473],"text":"[fixedWidth]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useLayoutEffect, useRef, useState } from 'react';\nimport { Check, Search, CheckCheck, CircleOff } from 'lucide-react';\nimport type { TrafficGroup, TrafficSource } from '../../../../../core/types/traffic';\n\n// Special ID for \"Unassigned\" filter option\nexport const UNASSIGNED_NICHE_ID = 'UNASSIGNED';\n\ninterface TrafficFilterInputNicheProps {\n    groups: TrafficGroup[]; // Available niches\n    sources: TrafficSource[]; // For calculating view counts\n    initialSelected: string[];\n    onApply: (selectedIds: string[]) => void;\n}\n\nconst formatViewCount = (num?: number) => {\n    if (!num) return '0';\n    return new Intl.NumberFormat('en-US', {\n        notation: \"compact\",\n        maximumFractionDigits: 1\n    }).format(num);\n};\n\nexport const TrafficFilterInputNiche: React.FC<TrafficFilterInputNicheProps> = ({\n    groups,\n    sources,\n    initialSelected,\n    onApply\n}) => {\n    const [selectedIds, setSelectedIds] = useState<string[]>(initialSelected);\n    const [searchQuery, setSearchQuery] = useState('');\n\n    // Width fixing (prevent layout shift during filtering)\n    const containerRef = useRef<HTMLDivElement>(null);\n    const [fixedWidth, setFixedWidth] = useState<number | undefined>(undefined);\n\n    useLayoutEffect(() => {\n        if (containerRef.current && !fixedWidth) {\n            // Measure the natural width with all content initially rendered\n            setFixedWidth(containerRef.current.offsetWidth);\n        }\n    }, []);\n\n    const toggleNiche = (id: string) => {\n        const newSelection = selectedIds.includes(id)\n            ? selectedIds.filter(s => s !== id)\n            : [...selectedIds, id];\n\n        setSelectedIds(newSelection);\n        onApply(newSelection);\n    };\n\n    // 1. Calculate Counts dynamically (Impressions & Views)\n    const nicheStats = useMemo(() => {\n        const stats = new Map<string, { views: number; impressions: number }>();\n\n        // Pre-compute videoId -> Set<NicheId> map\n        const videoIdToGroupIds = new Map<string, string[]>();\n        groups.forEach(group => {\n            group.videoIds.forEach(vid => {\n                const list = videoIdToGroupIds.get(vid) || [];\n                list.push(group.id);\n                videoIdToGroupIds.set(vid, list);\n            });\n        });\n\n        sources.forEach(source => {\n            if (!source.videoId) return;\n            const groupIds = videoIdToGroupIds.get(source.videoId);\n            if (groupIds) {\n                groupIds.forEach(gid => {\n                    const current = stats.get(gid) || { views: 0, impressions: 0 };\n                    stats.set(gid, {\n                        views: current.views + source.views,\n                        impressions: current.impressions + source.impressions\n                    });\n                });\n            }\n        });\n\n        return stats;\n    }, [sources, groups]);\n\n    // Calculate unassigned stats\n    const unassignedStats = useMemo(() => {\n        let views = 0;\n        let impressions = 0;\n\n        const coveredVideoIds = new Set<string>();\n        groups.forEach(g => g.videoIds.forEach(vid => coveredVideoIds.add(vid)));\n\n        sources.forEach(source => {\n            if (!source.videoId || !coveredVideoIds.has(source.videoId)) {\n                views += source.views;\n                impressions += source.impressions;\n            }\n        });\n        return { views, impressions };\n    }, [sources, groups]);\n\n    // 2. Sort niches: View Count (desc), then Name (asc)\n    // Identify Trash Group\n    const trashGroup = useMemo(() => {\n        return groups.find(g => g.name.trim().toLowerCase() === 'trash');\n    }, [groups]);\n\n    // 2. Sort niches: View Count (desc), then Name (asc)\n    const sortedNiches = useMemo(() => {\n        const otherGroups = trashGroup ? groups.filter(g => g.id !== trashGroup.id) : groups;\n        return [...otherGroups].sort((a, b) => {\n            const statsA = nicheStats.get(a.id) || { views: 0 };\n            const statsB = nicheStats.get(b.id) || { views: 0 };\n            if (statsA.views !== statsB.views) return statsB.views - statsA.views;\n            return a.name.localeCompare(b.name);\n        });\n    }, [groups, nicheStats, trashGroup]);\n\n    // Filter logic (Applied to sortedNiches which now excludes Trash)\n    const filteredNiches = useMemo(() => {\n        if (!searchQuery.trim()) return sortedNiches;\n        const lowerQuery = searchQuery.toLowerCase();\n        return sortedNiches.filter(n => n.name.toLowerCase().includes(lowerQuery));\n    }, [sortedNiches, searchQuery]);\n\n    const showUnassigned = useMemo(() => {\n        if (!searchQuery.trim()) return true;\n        return 'unassigned'.includes(searchQuery.toLowerCase());\n    }, [searchQuery]);\n\n    const showTrash = useMemo(() => {\n        if (!trashGroup) return false;\n        if (!searchQuery.trim()) return true;\n        return trashGroup.name.toLowerCase().includes(searchQuery.toLowerCase());\n    }, [searchQuery, trashGroup]);\n\n    // ... select all logic remains same ...\n    const handleSelectAll = () => {\n        const visibleIds = filteredNiches.map(n => n.id);\n        const allVisibleSelected = visibleIds.every(id => selectedIds.includes(id));\n        let newSelection: string[];\n        if (allVisibleSelected) {\n            newSelection = selectedIds.filter(id => !visibleIds.includes(id));\n        } else {\n            newSelection = Array.from(new Set([...selectedIds, ...visibleIds]));\n        }\n        setSelectedIds(newSelection);\n        onApply(newSelection);\n    };\n\n    const renderItem = (id: string, name: string, color: string | undefined, stats: { views: number, impressions: number }, isUnassigned: boolean) => {\n        const isSelected = selectedIds.includes(id);\n        const formattedViews = formatViewCount(stats.views);\n        const formattedImpr = formatViewCount(stats.impressions);\n\n        return (\n            <div\n                key={id}\n                onClick={() => toggleNiche(id)}\n                className=\"px-3 py-2 flex items-center gap-3 cursor-pointer transition-colors rounded-lg text-text-primary text-sm hover:bg-[#2a2a2a] group\"\n                title={`Impressions: ${stats.impressions.toLocaleString()}\\nViews: ${stats.views.toLocaleString()}`}\n            >\n                {/* Checkbox */}\n                <div\n                    className={`w-[16px] h-[16px] rounded border flex items-center justify-center flex-shrink-0 transition-colors ${isSelected\n                        ? 'bg-text-primary border-text-primary'\n                        : 'bg-transparent border-text-secondary group-hover:border-text-primary'\n                        }`}\n                >\n                    {isSelected && <Check size={10} className=\"text-bg-primary\" strokeWidth={3} />}\n                </div>\n\n                {/* Icon or Dot */}\n                {isUnassigned ? (\n                    <CircleOff size={12} className=\"text-text-tertiary flex-shrink-0\" />\n                ) : (\n                    <div\n                        className=\"w-2.5 h-2.5 rounded-full flex-shrink-0\"\n                        style={{ backgroundColor: color }}\n                    />\n                )}\n\n                {/* Name */}\n                <span className=\"flex-1 overflow-hidden text-ellipsis whitespace-nowrap text-xs\">\n                    {name}\n                </span>\n\n                {/* Stats: IMPR / VIEWS */}\n                <div className=\"flex items-center gap-1 text-[10px] text-text-tertiary font-medium opacity-60\">\n                    <span>{formattedImpr}</span>\n                    <span className=\"text-text-tertiary/50\"></span>\n                    <span>{formattedViews}</span>\n                </div>\n            </div>\n        );\n    };\n\n    return (\n        <div\n            ref={containerRef}\n            className=\"flex flex-col max-h-[300px] transition-[width]\"\n            style={{ width: fixedWidth ? `${fixedWidth}px` : 'auto', minWidth: '220px' }}\n        >\n            {/* Search Input Header */}\n            <div className=\"px-3 py-2 border-b border-[#2a2a2a] sticky top-0 bg-[#1F1F1F] z-10 flex items-center gap-2\">\n                <div className=\"relative flex-1\">\n                    <Search size={14} className=\"absolute left-2 top-1/2 -translate-y-1/2 text-text-tertiary\" />\n                    <input\n                        type=\"text\"\n                        value={searchQuery}\n                        onChange={(e) => setSearchQuery(e.target.value)}\n                        placeholder=\"Search niches...\"\n                        className=\"w-full bg-[#161616] border border-transparent focus:border-[#333333] rounded-md py-1.5 pl-8 pr-3 text-xs text-text-primary placeholder-text-tertiary outline-none transition-colors\"\n                        autoFocus\n                    />\n                </div>\n                <button\n                    onClick={handleSelectAll}\n                    className=\"p-1.5 text-text-tertiary hover:text-text-primary hover:bg-white/5 rounded transition-colors\"\n                    title=\"Select all visible\"\n                >\n                    <CheckCheck size={16} />\n                </button>\n            </div>\n\n            <div className=\"overflow-y-auto flex-1 p-1 custom-scrollbar\">\n                {/* Stats Legend Header (Mini) */}\n                <div className=\"px-3 pt-2 pb-1 flex justify-end gap-1 text-[9px] text-text-tertiary font-medium uppercase tracking-wider opacity-50\">\n                    <span>Impr</span>\n                    <span></span>\n                    <span>Views</span>\n                </div>\n\n                {/* Unassigned option */}\n                {/* Unassigned & Trash Block */}\n                {(showUnassigned || showTrash) && (\n                    <>\n                        {showUnassigned && renderItem(UNASSIGNED_NICHE_ID, 'Unassigned', undefined, unassignedStats, true)}\n\n                        {showTrash && trashGroup && (\n                            renderItem(\n                                trashGroup.id,\n                                'Trash',\n                                trashGroup.color,\n                                nicheStats.get(trashGroup.id) || { views: 0, impressions: 0 },\n                                false\n                            )\n                        )}\n\n                        {filteredNiches.length > 0 && <div className=\"mx-2 my-1 h-px bg-white/5\" />}\n                    </>\n                )}\n\n                {filteredNiches.length === 0 && !showUnassigned && !showTrash ? (\n                    <div className=\"px-4 py-8 text-center text-text-tertiary text-xs\">\n                        No niches found\n                    </div>\n                ) : (\n                    filteredNiches.map(niche => {\n                        const stats = nicheStats.get(niche.id) || { views: 0, impressions: 0 };\n                        return renderItem(niche.id, niche.name, niche.color, stats, false);\n                    })\n                )}\n            </div>\n\n            <div className=\"p-2 border-t border-[#2a2a2a] flex justify-between items-center text-[10px] text-text-tertiary\">\n                <span>{selectedIds.length} selected</span>\n                {selectedIds.length > 0 && (\n                    <button\n                        onClick={() => {\n                            setSelectedIds([]);\n                            onApply([]);\n                        }}\n                        className=\"text-text-primary hover:underline hover:text-red-400 transition-colors\"\n                    >\n                        Clear selection\n                    </button>\n                )}\n            </div>\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficFilterMenu.tsx","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":223,"column":25,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":223,"endColumn":79,"suggestions":[{"messageId":"addBrackets","fix":{"range":[11843,16619],"text":"{ const currentNichePropertyVal = existingFilter?.value;\n                        const selectedNicheProperties: string[] = Array.isArray(currentNichePropertyVal) ? (currentNichePropertyVal as string[]) : (currentNichePropertyVal ? [currentNichePropertyVal as string] : []);\n\n                        return (\n                            <div className=\"flex flex-col h-full overflow-hidden\">\n                                <div className=\"overflow-y-auto flex-1 p-1 custom-scrollbar\">\n                                    {[\n                                        { id: 'desired', label: 'Desired', icon: Flag, color: 'text-emerald-400', hover: 'group-hover:text-emerald-400' },\n                                        { id: 'targeted', label: 'Targeted', icon: Target, color: 'text-yellow-400', hover: 'group-hover:text-yellow-400' },\n                                        { id: 'adjacent', label: 'Adjacent', icon: Layers, color: 'text-blue-400', hover: 'group-hover:text-blue-400' },\n                                        { id: 'unrelated', label: 'Unrelated', icon: CircleOff, color: 'text-red-400', hover: 'group-hover:text-red-400' }\n                                    ].map(option => {\n                                        const isSelected = selectedNicheProperties.includes(option.id);\n                                        return (\n                                            <div\n                                                key={option.id}\n                                                onClick={() => {\n                                                    let newSelection: string[] = [...selectedNicheProperties];\n                                                    if (isSelected) {\n                                                        newSelection = newSelection.filter((v: string) => v !== option.id);\n                                                    } else {\n                                                        newSelection.push(option.id);\n                                                    }\n\n                                                    if (newSelection.length === 0) {\n                                                        if (existingFilter) onRemoveFilter(existingFilter.id);\n                                                    } else {\n                                                        const label = newSelection.length === 1\n                                                            ? `Niche Type: ${option.label}`\n                                                            : `Niche Type: ${newSelection.length} selected`;\n\n                                                        onAddFilter({\n                                                            type: 'nicheProperty',\n                                                            operator: 'contains',\n                                                            value: newSelection,\n                                                            label\n                                                        });\n                                                    }\n                                                }}\n                                                className=\"px-3 py-2 flex items-center gap-3 cursor-pointer transition-colors rounded-lg text-text-primary text-sm hover:bg-[#2a2a2a] group\"\n                                            >\n                                                <div\n                                                    className={`w-[16px] h-[16px] rounded border flex items-center justify-center flex-shrink-0 transition-colors ${isSelected\n                                                        ? 'bg-text-primary border-text-primary'\n                                                        : 'bg-transparent border-text-secondary group-hover:border-text-primary'\n                                                        }`}\n                                                >\n                                                    {isSelected && <Check size={10} className=\"text-bg-primary\" strokeWidth={3} />}\n                                                </div>\n                                                <option.icon\n                                                    size={14}\n                                                    className={`transition-colors ${isSelected ? option.color : 'text-text-tertiary'} ${option.hover}`}\n                                                />\n                                                <span className=\"flex-1\">{option.label}</span>\n                                            </div>\n                                        );\n                                    })}\n                                </div>\n                            </div>\n                        ); }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":224,"column":25,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":224,"endColumn":217,"suggestions":[{"messageId":"addBrackets","fix":{"range":[11843,16619],"text":"{ const currentNichePropertyVal = existingFilter?.value;\n                        const selectedNicheProperties: string[] = Array.isArray(currentNichePropertyVal) ? (currentNichePropertyVal as string[]) : (currentNichePropertyVal ? [currentNichePropertyVal as string] : []);\n\n                        return (\n                            <div className=\"flex flex-col h-full overflow-hidden\">\n                                <div className=\"overflow-y-auto flex-1 p-1 custom-scrollbar\">\n                                    {[\n                                        { id: 'desired', label: 'Desired', icon: Flag, color: 'text-emerald-400', hover: 'group-hover:text-emerald-400' },\n                                        { id: 'targeted', label: 'Targeted', icon: Target, color: 'text-yellow-400', hover: 'group-hover:text-yellow-400' },\n                                        { id: 'adjacent', label: 'Adjacent', icon: Layers, color: 'text-blue-400', hover: 'group-hover:text-blue-400' },\n                                        { id: 'unrelated', label: 'Unrelated', icon: CircleOff, color: 'text-red-400', hover: 'group-hover:text-red-400' }\n                                    ].map(option => {\n                                        const isSelected = selectedNicheProperties.includes(option.id);\n                                        return (\n                                            <div\n                                                key={option.id}\n                                                onClick={() => {\n                                                    let newSelection: string[] = [...selectedNicheProperties];\n                                                    if (isSelected) {\n                                                        newSelection = newSelection.filter((v: string) => v !== option.id);\n                                                    } else {\n                                                        newSelection.push(option.id);\n                                                    }\n\n                                                    if (newSelection.length === 0) {\n                                                        if (existingFilter) onRemoveFilter(existingFilter.id);\n                                                    } else {\n                                                        const label = newSelection.length === 1\n                                                            ? `Niche Type: ${option.label}`\n                                                            : `Niche Type: ${newSelection.length} selected`;\n\n                                                        onAddFilter({\n                                                            type: 'nicheProperty',\n                                                            operator: 'contains',\n                                                            value: newSelection,\n                                                            label\n                                                        });\n                                                    }\n                                                }}\n                                                className=\"px-3 py-2 flex items-center gap-3 cursor-pointer transition-colors rounded-lg text-text-primary text-sm hover:bg-[#2a2a2a] group\"\n                                            >\n                                                <div\n                                                    className={`w-[16px] h-[16px] rounded border flex items-center justify-center flex-shrink-0 transition-colors ${isSelected\n                                                        ? 'bg-text-primary border-text-primary'\n                                                        : 'bg-transparent border-text-secondary group-hover:border-text-primary'\n                                                        }`}\n                                                >\n                                                    {isSelected && <Check size={10} className=\"text-bg-primary\" strokeWidth={3} />}\n                                                </div>\n                                                <option.icon\n                                                    size={14}\n                                                    className={`transition-colors ${isSelected ? option.color : 'text-text-tertiary'} ${option.hover}`}\n                                                />\n                                                <span className=\"flex-1\">{option.label}</span>\n                                            </div>\n                                        );\n                                    })}\n                                </div>\n                            </div>\n                        ); }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { ChevronLeft, ChevronRight, X, Eye, Clock, BarChart3, Percent, Layers, Sparkles, MousePointerClick, HelpCircle, Wand2, Users, Zap, ZapOff, Compass, Target, Coffee, Flag, CircleOff, Check } from 'lucide-react';\nimport { Checkbox } from '../../../../../components/ui/atoms/Checkbox/Checkbox';\nimport { SegmentedControl } from '../../../../../components/ui/molecules/SegmentedControl';\nimport { FilterInputNumeric } from '../../../../../components/Shared/FilterInputs/FilterInputNumeric';\nimport { TrafficFilterInputNiche, UNASSIGNED_NICHE_ID } from './TrafficFilterInputNiche';\nimport type { TrafficFilterType, TrafficFilter } from '../hooks/useTrafficFilters';\nimport type { FilterOperator } from '../../../../../core/stores/filterStore';\nimport type { TrafficGroup, TrafficSource } from '../../../../../core/types/traffic';\nimport { formatDuration } from '../utils/formatters';\n\ninterface TrafficFilterMenuProps {\n    viewMode: 'cumulative' | 'delta';\n    onViewModeChange: (mode: 'cumulative' | 'delta') => void;\n    filters: TrafficFilter[];\n    onAddFilter: (filter: Omit<TrafficFilter, 'id'>) => void;\n    onRemoveFilter: (id: string) => void;\n    onClose: () => void;\n    groups?: TrafficGroup[];\n    sources?: TrafficSource[];\n}\n\nexport const TrafficFilterMenu: React.FC<TrafficFilterMenuProps> = ({\n    viewMode,\n    onViewModeChange,\n    filters,\n    onAddFilter,\n    onRemoveFilter,\n    onClose,\n    groups,\n    sources\n}) => {\n    // Navigation State\n    const [activeView, setActiveView] = useState<TrafficFilterType | 'main'>('main');\n\n    const filterTypes: { type: TrafficFilterType; label: string; icon: React.ElementType }[] = [\n        { type: 'impressions', label: 'Impressions', icon: Eye },\n        { type: 'ctr', label: 'CTR', icon: Percent },\n        { type: 'views', label: 'Views', icon: BarChart3 },\n        { type: 'avgViewDuration', label: 'Average View Duration', icon: Clock },\n        { type: 'niche', label: 'Niche', icon: Layers },\n        { type: 'trafficType', label: 'Traffic Type', icon: Sparkles },\n        { type: 'viewerType', label: 'Viewer Type', icon: Users },\n        { type: 'nicheProperty', label: 'Niche Type', icon: Flag },\n    ];\n\n    const getTitleForView = (view: TrafficFilterType) => {\n        const match = filterTypes.find(t => t.type === view);\n        return match ? match.label : 'Filter';\n    };\n\n    const handleApplyFilter = (type: TrafficFilterType, operator: FilterOperator, value: number | string, maxValue?: number | string) => {\n        // Generate label\n        let label = '';\n        const opLabel = operator === 'between' ? '-' : operator === 'gte' ? '>=' : operator === 'lte' ? '<=' : operator === 'gt' ? '>' : operator === 'lt' ? '<' : '=';\n\n        if (type === 'avgViewDuration') {\n            const valStr = formatDuration(value.toString()); // Value passed from SmartDurationInput is seconds number\n            const maxStr = maxValue ? formatDuration(maxValue.toString()) : '';\n            label = operator === 'between'\n                ? `AVD: ${valStr} - ${maxStr}`\n                : `AVD ${opLabel} ${valStr}`;\n        } else if (type === 'ctr') {\n            const valStr = value + '%';\n            const maxStr = maxValue ? maxValue + '%' : '';\n            label = operator === 'between'\n                ? `CTR: ${valStr} - ${maxStr}`\n                : `CTR ${opLabel} ${valStr}`;\n        } else {\n            // Impressions / Views\n            const metricName = type === 'impressions' ? 'Impr.' : 'Views';\n            const valStr = value.toLocaleString();\n            const maxStr = maxValue ? maxValue.toLocaleString() : '';\n            label = operator === 'between'\n                ? `${metricName}: ${valStr} - ${maxStr}`\n                : `${metricName} ${opLabel} ${valStr}`;\n        }\n\n        // Final value object for hook\n        // For range, value is [min, max]\n        const finalValue: number | string | string[] | [number, number] = (operator === 'between' && typeof value === 'number' && typeof maxValue === 'number')\n            ? [value, maxValue] as [number, number]\n            : value;\n\n        onAddFilter({\n            type,\n            operator,\n            value: finalValue,\n            label\n        });\n    };\n\n    // Find existing filter of current type to pre-fill\n    // Note: This finds the MAIN filter (views/impressions/ctr/avd)\n    const existingFilter = filters.find(f => f.type === activeView);\n    const initialVal = existingFilter?.value;\n    const isRange = Array.isArray(initialVal);\n\n    return (\n        <div className=\"flex flex-col w-[280px]\">\n            {/* Header for Submenus */}\n            {activeView !== 'main' && (\n                <div className=\"flex items-center justify-between px-2 py-2 border-b border-[#333333]\">\n                    <button\n                        onClick={() => setActiveView('main')}\n                        className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                    >\n                        <ChevronLeft size={20} />\n                    </button>\n                    <span className=\"text-sm font-bold text-text-primary\">{getTitleForView(activeView)}</span>\n                    <button\n                        onClick={onClose}\n                        className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                    >\n                        <X size={20} />\n                    </button>\n                </div>\n            )}\n\n            {/* View Content Switcher */}\n            {(() => {\n                switch (activeView) {\n                    case 'main':\n                        return (\n                            <div className=\"py-2\">\n                                {/* View Mode Section */}\n                                <div className=\"px-4 py-3 mb-1\">\n                                    <div className=\"flex items-center justify-between mb-2\">\n                                        <span className=\"text-[11px] font-medium text-text-tertiary uppercase tracking-wider\">\n                                            View Mode\n                                        </span>\n                                    </div>\n                                    <SegmentedControl\n                                        options={[\n                                            { label: 'Total', value: 'cumulative' },\n                                            { label: 'New', value: 'delta' }\n                                        ]}\n                                        value={viewMode}\n                                        onChange={(v) => onViewModeChange(v)}\n                                    />\n                                    <div className=\"mt-2 text-[10px] text-text-tertiary leading-relaxed grid\">\n                                        <span className={`col-start-1 row-start-1 transition-opacity duration-150 ${viewMode === 'cumulative' ? 'opacity-100' : 'opacity-0'}`}>\n                                            Show total accumulated views\n                                        </span>\n                                        <span className={`col-start-1 row-start-1 transition-opacity duration-150 ${viewMode === 'delta' ? 'opacity-100' : 'opacity-0'}`}>\n                                            Show new views since last snapshot\n                                        </span>\n                                    </div>\n                                </div>\n\n                                {/* Separator */}\n                                <div className=\"h-px bg-[#2a2a2a] mx-4 mb-1.5\" />\n\n                                {/* Add Filter Section - COMPACT SPACING */}\n                                <div className=\"px-4 pt-1.5 pb-0\">\n                                    <div className=\"flex items-center justify-between mb-0.5\">\n                                        <span className=\"text-[11px] font-medium text-text-tertiary uppercase tracking-wider\">\n                                            Add Filter\n                                        </span>\n                                    </div>\n                                </div>\n\n                                {filterTypes.map(({ type, label, icon: Icon }) => {\n                                    // Check if filter exists\n                                    const isActive = filters.some(f => f.type === type);\n\n                                    return (\n                                        <button\n                                            key={type}\n                                            onClick={() => setActiveView(type)}\n                                            className=\"w-full text-left px-4 py-2.5 text-sm font-medium flex items-center justify-between gap-8 transition-colors border-none cursor-pointer text-text-primary hover:bg-[#161616] bg-transparent group\"\n                                        >\n                                            <div className=\"flex items-center gap-3\">\n                                                <Icon size={16} className={`transition-colors ${isActive ? 'text-accent-blue' : 'text-text-secondary group-hover:text-text-primary'}`} />\n                                                <span className={isActive ? 'text-accent-blue' : ''}>{label}</span>\n                                            </div>\n                                            <ChevronRight size={16} className=\"text-text-secondary opacity-0 group-hover:opacity-100 transition-opacity\" />\n                                        </button>\n                                    );\n                                })}\n                            </div>\n                        );\n\n                    case 'niche':\n                        return groups ? (\n                            <TrafficFilterInputNiche\n                                groups={groups}\n                                sources={sources || []}\n                                initialSelected={(existingFilter?.value as string[]) || []}\n                                onApply={(selectedIds) => {\n                                    if (existingFilter) {\n                                        onRemoveFilter(existingFilter.id);\n                                    }\n                                    if (selectedIds.length > 0) {\n                                        // Format label\n                                        const names = groups\n                                            .filter(g => selectedIds.includes(g.id))\n                                            .map(g => g.name);\n\n                                        if (selectedIds.includes(UNASSIGNED_NICHE_ID)) {\n                                            names.push('Unassigned');\n                                        }\n\n                                        const label = names.length === 1\n                                            ? `Niche: ${names[0]}`\n                                            : `Niche: ${names.length} selected`;\n\n                                        onAddFilter({\n                                            type: 'niche',\n                                            operator: 'contains',\n                                            value: selectedIds,\n                                            label\n                                        });\n                                    }\n                                    // Don't close immediately to allow multi-select\n                                }}\n                            />\n                        ) : (\n                            <div className=\"p-4 text-xs text-text-tertiary\">Data not available</div>\n                        );\n\n                    case 'nicheProperty':\n                        const currentNichePropertyVal = existingFilter?.value;\n                        const selectedNicheProperties: string[] = Array.isArray(currentNichePropertyVal) ? (currentNichePropertyVal as string[]) : (currentNichePropertyVal ? [currentNichePropertyVal as string] : []);\n\n                        return (\n                            <div className=\"flex flex-col h-full overflow-hidden\">\n                                <div className=\"overflow-y-auto flex-1 p-1 custom-scrollbar\">\n                                    {[\n                                        { id: 'desired', label: 'Desired', icon: Flag, color: 'text-emerald-400', hover: 'group-hover:text-emerald-400' },\n                                        { id: 'targeted', label: 'Targeted', icon: Target, color: 'text-yellow-400', hover: 'group-hover:text-yellow-400' },\n                                        { id: 'adjacent', label: 'Adjacent', icon: Layers, color: 'text-blue-400', hover: 'group-hover:text-blue-400' },\n                                        { id: 'unrelated', label: 'Unrelated', icon: CircleOff, color: 'text-red-400', hover: 'group-hover:text-red-400' }\n                                    ].map(option => {\n                                        const isSelected = selectedNicheProperties.includes(option.id);\n                                        return (\n                                            <div\n                                                key={option.id}\n                                                onClick={() => {\n                                                    let newSelection: string[] = [...selectedNicheProperties];\n                                                    if (isSelected) {\n                                                        newSelection = newSelection.filter((v: string) => v !== option.id);\n                                                    } else {\n                                                        newSelection.push(option.id);\n                                                    }\n\n                                                    if (newSelection.length === 0) {\n                                                        if (existingFilter) onRemoveFilter(existingFilter.id);\n                                                    } else {\n                                                        const label = newSelection.length === 1\n                                                            ? `Niche Type: ${option.label}`\n                                                            : `Niche Type: ${newSelection.length} selected`;\n\n                                                        onAddFilter({\n                                                            type: 'nicheProperty',\n                                                            operator: 'contains',\n                                                            value: newSelection,\n                                                            label\n                                                        });\n                                                    }\n                                                }}\n                                                className=\"px-3 py-2 flex items-center gap-3 cursor-pointer transition-colors rounded-lg text-text-primary text-sm hover:bg-[#2a2a2a] group\"\n                                            >\n                                                <div\n                                                    className={`w-[16px] h-[16px] rounded border flex items-center justify-center flex-shrink-0 transition-colors ${isSelected\n                                                        ? 'bg-text-primary border-text-primary'\n                                                        : 'bg-transparent border-text-secondary group-hover:border-text-primary'\n                                                        }`}\n                                                >\n                                                    {isSelected && <Check size={10} className=\"text-bg-primary\" strokeWidth={3} />}\n                                                </div>\n                                                <option.icon\n                                                    size={14}\n                                                    className={`transition-colors ${isSelected ? option.color : 'text-text-tertiary'} ${option.hover}`}\n                                                />\n                                                <span className=\"flex-1\">{option.label}</span>\n                                            </div>\n                                        );\n                                    })}\n                                </div>\n                            </div>\n                        );\n\n                    case 'viewerType':\n                        return (\n                            <div className=\"flex flex-col h-full overflow-hidden\">\n                                <div className=\"overflow-y-auto flex-1 p-1 custom-scrollbar\">\n                                    {/**\n                                     * BUSINESS LOGIC: Viewer Type Classification\n                                     * Categories are based on Average View Duration as a percentage of Total Video Duration:\n                                     * - Bouncer: < 1%\n                                     * - Trialist: 1.1%  10%\n                                     * - Explorer: 10.1%  30%\n                                     * - Interested: 30.1%  60%\n                                     * - Core: 60.1%  95%\n                                     * - Passive: > 95%\n                                     */}\n                                    {[\n                                        { id: 'bouncer', label: 'Bouncer (< 1%)', icon: ZapOff, color: 'text-red-400', hover: 'group-hover:text-red-400' },\n                                        { id: 'trialist', label: 'Trialist (1.1%  10%)', icon: Zap, color: 'text-orange-400', hover: 'group-hover:text-orange-400' },\n                                        { id: 'explorer', label: 'Explorer (10.1%  30%)', icon: Compass, color: 'text-amber-400', hover: 'group-hover:text-amber-400' },\n                                        { id: 'interested', label: 'Interested (30.1%  60%)', icon: Eye, color: 'text-blue-400', hover: 'group-hover:text-blue-400' },\n                                        { id: 'core', label: 'Core Audience (60.1%  95%)', icon: Target, color: 'text-emerald-400', hover: 'group-hover:text-emerald-400' },\n                                        { id: 'passive', label: 'Passive (> 95%)', icon: Coffee, color: 'text-purple-400', hover: 'group-hover:text-purple-400' },\n                                        { id: 'smart_assistant', label: 'Set by Smart Assistant', icon: Wand2, color: 'text-blue-500', hover: 'group-hover:text-blue-500' },\n                                        { id: 'unknown', label: 'Unset', icon: HelpCircle, color: 'text-text-tertiary', hover: 'group-hover:text-text-primary' }\n                                    ].map(opt => {\n                                        const currentVal = existingFilter?.value;\n                                        const isSelected = Array.isArray(currentVal)\n                                            ? (currentVal as string[]).includes(opt.id)\n                                            : currentVal === opt.id;\n                                        const TypeIcon = opt.icon;\n\n                                        return (\n                                            <div\n                                                key={opt.id}\n                                                onClick={() => {\n                                                    let newVal: string[] = Array.isArray(currentVal) ? [...(currentVal as string[])] : (currentVal ? [currentVal as string] : []);\n\n                                                    if (isSelected) {\n                                                        newVal = newVal.filter(v => v !== opt.id);\n                                                    } else {\n                                                        newVal.push(opt.id);\n                                                    }\n\n                                                    if (newVal.length === 0) {\n                                                        if (existingFilter) onRemoveFilter(existingFilter.id);\n                                                    } else {\n                                                        const label = newVal.length === 1\n                                                            ? `Viewer: ${opt.label}`\n                                                            : `Viewer: ${newVal.length} selected`;\n\n                                                        onAddFilter({\n                                                            type: 'viewerType',\n                                                            operator: 'contains',\n                                                            value: newVal,\n                                                            label\n                                                        });\n                                                    }\n                                                }}\n                                                className=\"px-3 py-2 flex items-center gap-3 cursor-pointer transition-colors rounded-lg text-text-primary text-sm hover:bg-[#2a2a2a] group\"\n                                            >\n                                                <Checkbox checked={isSelected} onChange={() => { }} className=\"flex-shrink-0\" />\n\n                                                <TypeIcon\n                                                    size={12}\n                                                    className={`flex-shrink-0 transition-colors ${isSelected ? opt.color : 'text-text-tertiary'} ${opt.hover}`}\n                                                />\n\n                                                <span className={`flex-1 overflow-hidden text-ellipsis whitespace-nowrap text-xs transition-colors ${isSelected ? 'text-text-primary font-medium' : 'text-text-secondary group-hover:text-text-primary'}`}>\n                                                    {opt.label}\n                                                </span>\n                                            </div>\n                                        );\n                                    })}\n                                </div>\n                            </div>\n                        );\n\n                    case 'trafficType':\n                        return (\n                            <div className=\"flex flex-col h-full overflow-hidden\">\n                                <div className=\"overflow-y-auto flex-1 p-1 custom-scrollbar\">\n                                    {[\n                                        { id: 'autoplay', label: 'Suggested (Autoplay)', icon: Sparkles, color: 'text-purple-400', hover: 'group-hover:text-purple-400' },\n                                        { id: 'user_click', label: 'User Intent (Click)', icon: MousePointerClick, color: 'text-emerald-400', hover: 'group-hover:text-emerald-400' },\n                                        { id: 'smart_assistant', label: 'Set by Smart Assistant', icon: Wand2, color: 'text-blue-500', hover: 'group-hover:text-blue-500' },\n                                        { id: 'unknown', label: 'Unset', icon: HelpCircle, color: 'text-text-tertiary', hover: 'group-hover:text-text-primary' }\n                                    ].map(opt => {\n                                        const currentVal = existingFilter?.value;\n                                        const isSelected = Array.isArray(currentVal)\n                                            ? (currentVal as string[]).includes(opt.id)\n                                            : currentVal === opt.id;\n                                        const TypeIcon = opt.icon;\n\n                                        return (\n                                            <div\n                                                key={opt.id}\n                                                onClick={() => {\n                                                    let newVal: string[] = Array.isArray(currentVal) ? [...(currentVal as string[])] : (currentVal ? [currentVal as string] : []);\n\n                                                    if (isSelected) {\n                                                        newVal = newVal.filter(v => v !== opt.id);\n                                                    } else {\n                                                        newVal.push(opt.id);\n                                                    }\n\n                                                    if (newVal.length === 0) {\n                                                        if (existingFilter) onRemoveFilter(existingFilter.id);\n                                                    } else {\n                                                        const label = newVal.length === 1\n                                                            ? `Type: ${opt.label}`\n                                                            : `Type: ${newVal.length} selected`;\n\n                                                        onAddFilter({\n                                                            type: 'trafficType',\n                                                            operator: 'contains',\n                                                            value: newVal,\n                                                            label\n                                                        });\n                                                    }\n                                                }}\n                                                className=\"px-3 py-2 flex items-center gap-3 cursor-pointer transition-colors rounded-lg text-text-primary text-sm hover:bg-[#2a2a2a] group\"\n                                            >\n                                                <Checkbox checked={isSelected} onChange={() => { }} className=\"flex-shrink-0\" />\n\n                                                <TypeIcon\n                                                    size={12}\n                                                    className={`flex-shrink-0 transition-colors ${isSelected ? opt.color : 'text-text-tertiary'} ${opt.hover}`}\n                                                />\n\n                                                <span className={`flex-1 overflow-hidden text-ellipsis whitespace-nowrap text-xs transition-colors ${isSelected ? 'text-text-primary font-medium' : 'text-text-secondary group-hover:text-text-primary'}`}>\n                                                    {opt.label}\n                                                </span>\n                                            </div>\n                                        );\n                                    })}\n                                </div>\n                            </div>\n                        );\n\n                    default:\n                        // Numeric Filters (Impressions, Views, CTR, AVD)\n                        return (\n                            <div className=\"animate-fade-in\">\n                                <FilterInputNumeric\n                                    initialOperator={existingFilter?.operator || 'gte'}\n                                    initialValue={isRange ? (initialVal as [number, number])[0] : (initialVal as number | undefined)}\n                                    initialMaxValue={isRange ? (initialVal as [number, number])[1] : undefined}\n                                    isDuration={activeView === 'avgViewDuration'}\n                                    // Independent Hide Zero Logic - Apply Based\n                                    initialIsHideZero={\n                                        activeView === 'views'\n                                            ? filters.some(f => f.type === 'hideZeroViews')\n                                            : activeView === 'impressions'\n                                                ? filters.some(f => f.type === 'hideZeroImpressions')\n                                                : undefined\n                                    }\n                                    showHideZeroOption={activeView === 'views' || activeView === 'impressions'}\n                                    metricLabel={activeView === 'views' ? 'Views' : activeView === 'impressions' ? 'Impressions' : undefined}\n                                    onApply={(op, val, max, isHideZero) => {\n                                        // 1. Handle Main Filter\n                                        if (!isNaN(val)) {\n                                            handleApplyFilter(activeView as TrafficFilterType, op, val, max);\n                                        } else {\n                                            // If value is clean (NaN), remove existing main filter if present\n                                            const mainFilter = filters.find(f => f.type === activeView);\n                                            if (mainFilter) {\n                                                onRemoveFilter(mainFilter.id);\n                                            }\n                                        }\n\n                                        // 2. Handle Independent Hide Zero Filter\n                                        if (activeView === 'views' || activeView === 'impressions') {\n                                            const hideType = activeView === 'views' ? 'hideZeroViews' : 'hideZeroImpressions';\n                                            const existingHideFilter = filters.find(f => f.type === hideType);\n\n                                            if (isHideZero && !existingHideFilter) {\n                                                onAddFilter({\n                                                    type: hideType,\n                                                    operator: 'gt',\n                                                    value: 0,\n                                                    label: activeView === 'views' ? 'Hide 0 Views' : 'Hide 0 Impr.'\n                                                });\n                                            } else if (!isHideZero && existingHideFilter) {\n                                                onRemoveFilter(existingHideFilter.id);\n                                            }\n                                        }\n\n                                        onClose();\n                                    }}\n                                    onRemove={existingFilter ? () => {\n                                        onRemoveFilter(existingFilter.id);\n                                        onClose();\n                                    } : undefined}\n                                />\n                            </div>\n                        );\n                }\n            })()}\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficFloatingBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficModals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficPlaylistSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficRow.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12691,12694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12691,12694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef } from 'react';\nimport {\n    ExternalLink, Info, Sparkles, Flag, CircleOff, Layers, Target,\n    MousePointerClick, HelpCircle, Wand2, ZapOff, Zap, Compass, Eye, Coffee, User\n} from 'lucide-react';\nimport type { TrafficSource } from '../../../../../core/types/traffic';\nimport type { TrafficType } from '../../../../../core/types/videoTrafficType';\nimport type { ViewerType } from '../../../../../core/types/viewerType';\nimport { Checkbox } from '../../../../../components/ui/atoms/Checkbox/Checkbox';\nimport { PortalTooltip } from '../../../../../components/Shared/PortalTooltip';\nimport { VideoPreviewTooltip } from '../../../../../components/Shared/VideoPreviewTooltip';\nimport { formatDuration } from '../utils/formatters';\nimport type { CTRRule } from '../../../../../core/services/settingsService';\nimport { useTrafficNicheStore } from '../../../../../core/stores/useTrafficNicheStore';\nimport { TrafficRowBadges } from './TrafficRowBadges';\nimport { useVideoPlayer } from '../../../../../core/hooks/useVideoPlayer';\nimport type { SuggestedTrafficNiche } from '../../../../../core/types/suggestedTrafficNiches';\n\nimport type { VideoDetails } from '../../../../../core/utils/youtubeApi';\n\ninterface TrafficRowProps {\n    item: TrafficSource;\n    index: number;\n    isSelected: boolean;\n    activeSortKey?: string;\n    onRowClick: (id: string, index: number, e: React.MouseEvent) => void;\n    ctrRules?: CTRRule[];\n    gridClassName: string;\n    showPropertyIcon: boolean;\n    videoDetails?: VideoDetails;\n    // Smart Assistant Props\n    suggestedNiche?: SuggestedTrafficNiche;\n    onConfirmSuggestion?: (videoId: string, niche: SuggestedTrafficNiche) => void;\n    // Traffic Type Props\n    trafficType?: TrafficType;\n    trafficSource?: 'manual' | 'smart_assistant';\n    onToggleTrafficType?: (videoId: string, currentType?: TrafficType) => void;\n    // Viewer Type Props\n    viewerType?: ViewerType;\n    viewerSource?: 'manual' | 'smart_assistant';\n    onToggleViewerType?: (videoId: string, currentType?: ViewerType) => void;\n    // Tooltip Control\n    activeTooltipId?: string | null;\n    onTooltipEnter?: (id: string) => void;\n    onTooltipLeave?: () => void;\n}\n\nconst getCtrColor = (ctr: number | string, rules: CTRRule[]): string | undefined => {\n    const val = typeof ctr === 'string' ? parseFloat(ctr) : ctr;\n    if (isNaN(val)) return undefined;\n\n    // Rules are user-defined and ordered via drag-and-drop in the CTR Config UI.\n    // We apply \"first match wins\" logic: iterate through rules in order,\n    // and return the color of the first rule that matches the CTR value.\n    for (const rule of rules) {\n        switch (rule.operator) {\n            case '<': if (val < rule.value) return rule.color; break;\n            case '>': if (val > rule.value) return rule.color; break;\n            case '<=': if (val <= rule.value) return rule.color; break;\n            case '>=': if (val >= rule.value) return rule.color; break;\n            case 'between':\n                if (rule.maxValue !== undefined && val >= rule.value && val <= rule.maxValue) return rule.color;\n                break;\n        }\n    }\n    return undefined;\n};\n\n\nexport const TrafficRow = ({\n    item,\n    index,\n    isSelected,\n    activeSortKey,\n    onRowClick,\n    ctrRules = [],\n    gridClassName,\n    showPropertyIcon,\n    videoDetails,\n    suggestedNiche,\n    onConfirmSuggestion,\n    trafficType,\n    trafficSource,\n    onToggleTrafficType,\n    viewerType,\n    viewerSource,\n    onToggleViewerType,\n    activeTooltipId,\n    onTooltipEnter,\n    onTooltipLeave\n}: TrafficRowProps) => {\n    // Connect to Niche Store\n    const { niches, assignments } = useTrafficNicheStore();\n    const enterTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const wrapperRef = useRef<HTMLDivElement>(null);\n    // Connect to Video Player mainly to check if this video is minimized\n    const { activeVideoId, isMinimized } = useVideoPlayer();\n\n    // Check if THIS specific video is minimized\n    const isThisVideoMinimized = isMinimized && activeVideoId === item.videoId;\n\n    // Traffic Type Icon Logic\n    const { icon: TypeIcon, label: typeLabel, color: typeColor, activeClass: typeActiveClass } = React.useMemo(() => {\n        if (trafficType === 'autoplay') {\n            return {\n                icon: Sparkles,\n                label: 'Suggested (Autoplay)',\n                color: 'text-purple-400',\n                activeClass: 'opacity-100'\n            };\n        }\n        if (trafficType === 'user_click') {\n            return {\n                icon: MousePointerClick,\n                label: 'User Intent (Click)',\n                color: 'text-emerald-400',\n                activeClass: 'opacity-100'\n            };\n        }\n        return {\n            icon: HelpCircle,\n            label: 'Set Traffic Type',\n            color: 'text-white/20',\n            activeClass: 'opacity-0 group-hover:opacity-100' // Only show on hover if unset\n        };\n    }, [trafficType]);\n\n    // Viewer Type Icon Logic\n    const { icon: ViewerIcon, label: viewerLabel, color: viewerColor, activeClass: viewerActiveClass } = React.useMemo(() => {\n        switch (viewerType) {\n            case 'bouncer':\n                return { icon: ZapOff, label: 'Bouncer: < 1% Watch Duration', color: 'text-red-400', activeClass: 'opacity-100' };\n            case 'trialist':\n                return { icon: Zap, label: 'Trialist: 1.1%  10% Watch Duration', color: 'text-orange-400', activeClass: 'opacity-100' };\n            case 'explorer':\n                return { icon: Compass, label: 'Explorer: 10.1%  30% Watch Duration', color: 'text-amber-400', activeClass: 'opacity-100' };\n            case 'interested':\n                return { icon: Eye, label: 'Interested: 30.1%  60% Watch Duration', color: 'text-blue-400', activeClass: 'opacity-100' };\n            case 'core':\n                return { icon: Target, label: 'Core Audience: 60.1%  95% Watch Duration', color: 'text-emerald-400', activeClass: 'opacity-100' };\n            case 'passive':\n                return { icon: Coffee, label: 'Passive: > 95% Watch Duration', color: 'text-purple-400', activeClass: 'opacity-100' };\n            default:\n                return {\n                    icon: User,\n                    label: 'Set Viewer Type',\n                    color: 'text-white/20',\n                    activeClass: 'opacity-0 group-hover:opacity-100'\n                };\n        }\n    }, [viewerType]);\n\n    // Handle Type Click\n    const handleTypeClick = (e: React.MouseEvent) => {\n        e.stopPropagation();\n        if (!item.videoId || !onToggleTrafficType) return;\n        onToggleTrafficType(item.videoId, trafficType);\n    };\n\n    // Handle Viewer Click\n    const handleViewerClick = (e: React.MouseEvent) => {\n        e.stopPropagation();\n        if (!item.videoId || !onToggleViewerType) return;\n        onToggleViewerType(item.videoId, viewerType);\n    };\n\n    // Derived state: find niches assigned to this video\n    const assignedNiches = React.useMemo(() => {\n        if (!item.videoId) return [];\n        const myAssignmentIds = assignments\n            .filter(a => a.videoId === item.videoId)\n            .map(a => a.nicheId);\n        return niches.filter(n => myAssignmentIds.includes(n.id));\n    }, [item.videoId, assignments, niches]);\n\n    // Determine property icon based on priority: Desired > Targeted > Unrelated\n    const { icon: PropertyIcon, label: propertyLabel } = React.useMemo(() => {\n        if (!assignedNiches.length) return { icon: null, label: '' };\n\n        const hasProperty = (p: string) => assignedNiches.some(n => n.property === p);\n\n        if (hasProperty('desired')) return { icon: <Flag size={12} className=\"text-emerald-400\" />, label: 'Desired' };\n        if (hasProperty('targeted')) return { icon: <Target size={12} className=\"text-yellow-400\" />, label: 'Targeted' };\n        if (hasProperty('adjacent')) return { icon: <Layers size={12} className=\"text-blue-400\" />, label: 'Adjacent' };\n        if (hasProperty('unrelated')) return { icon: <CircleOff size={12} className=\"text-red-400\" />, label: 'Unrelated' };\n\n        return { icon: null, label: '' };\n    }, [assignedNiches]);\n\n\n\n    return (\n        <div\n            key={item.videoId || index}\n            onClick={(e) => item.videoId && onRowClick(item.videoId, index, e)}\n            className={`\n                relative h-full grid ${gridClassName} gap-2 px-4 items-center border-b border-white/5 \n                text-xs cursor-pointer group select-none\n                ${index % 2 === 0 ? 'bg-white/[0.035]' : 'bg-transparent'}  \n                hover:bg-white/[0.05]\n            `}\n        >\n            {/* Selection indicator line - Absolute to avoid clipping */}\n            {isSelected && (\n                <div className=\"absolute left-0 top-0 bottom-0 w-[4px] bg-[#3EA6FF] z-10 shadow-[2px_0_8px_rgba(62,166,255,0.4)]\" />\n            )}\n            <div className=\"flex items-center justify-center\">\n                <Checkbox\n                    checked={isSelected}\n                    onChange={() => { }} // Handled by row click\n                />\n            </div>\n\n            {showPropertyIcon && (\n                <div className=\"flex items-center justify-center\">\n                    {PropertyIcon && (\n                        <PortalTooltip content={propertyLabel} enterDelay={300}>\n                            <div className=\"flex items-center justify-center cursor-help\">\n                                {PropertyIcon}\n                            </div>\n                        </PortalTooltip>\n                    )}\n                </div>\n            )}\n\n            <div className=\"min-w-0 flex flex-col justify-center h-full py-1\">\n                <div className=\"flex items-center gap-2 min-w-0 w-full\">\n                    <div className=\"min-w-0 flex-1 flex items-center gap-2 overflow-hidden\">\n                        {/* Title Group: Title + Info Icon */}\n                        <div className=\"min-w-0 flex items-center gap-1.5\">\n                            <span className={`truncate block ${activeSortKey === 'sourceTitle' ? 'text-text-primary font-semibold' : 'text-text-primary font-medium'}`}>\n                                {item.sourceTitle}\n                            </span>\n\n                            {/* Info Icon - Moved here, visible on group hover */}\n                            {item.videoId && !isThisVideoMinimized && (\n                                <div\n                                    ref={wrapperRef}\n                                    className=\"flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity inline-flex -m-2 p-2\"\n                                    onMouseEnter={() => {\n                                        if (enterTimeoutRef.current) clearTimeout(enterTimeoutRef.current);\n                                        enterTimeoutRef.current = setTimeout(() => {\n                                            if (onTooltipEnter) onTooltipEnter(`preview-${item.videoId}`);\n                                        }, 500);\n                                    }}\n                                    onMouseLeave={() => {\n                                        // Tooltip Stability Bridge: Start a grace period in TrafficTable.tsx \n                                        // to handle iframe-induced focus flickers.\n                                        if (enterTimeoutRef.current) {\n                                            clearTimeout(enterTimeoutRef.current);\n                                            enterTimeoutRef.current = null;\n                                        }\n                                        if (onTooltipLeave) onTooltipLeave();\n                                    }}\n                                >\n                                    <PortalTooltip\n                                        content={\n                                            <div\n                                                className=\"pointer-events-auto w-full relative p-6\"\n                                                onMouseEnter={() => {\n                                                    // Maintain open state if hovering content\n                                                    // Note: We don't need delay here because it's already open\n                                                    if (enterTimeoutRef.current) clearTimeout(enterTimeoutRef.current);\n                                                    if (onTooltipEnter) onTooltipEnter(`preview-${item.videoId}`);\n                                                }}\n                                                onMouseLeave={(e: any) => {\n                                                    // IGNORE LEAVE if we are moving back to our own trigger icon\n                                                    // This prevents the \"flicker loop\" where hovering the icon underneath closes the tooltip\n                                                    if (wrapperRef.current && wrapperRef.current.contains(e.relatedTarget as Node)) {\n                                                        return;\n                                                    }\n\n                                                    if (onTooltipLeave) onTooltipLeave();\n                                                }}\n                                            >\n                                                <VideoPreviewTooltip\n                                                    videoId={item.videoId}\n                                                    title={videoDetails?.title || item.sourceTitle}\n                                                    channelTitle={videoDetails?.channelTitle || item.channelTitle}\n                                                    viewCount={videoDetails?.viewCount ? parseInt(videoDetails.viewCount) : undefined}\n                                                    publishedAt={videoDetails?.publishedAt}\n                                                    description={videoDetails?.description}\n                                                    tags={videoDetails?.tags}\n                                                    className=\"w-full\"\n                                                />\n                                            </div>\n                                        }\n                                        enterDelay={0}\n                                        triggerClassName=\"flex items-center justify-center\"\n                                        variant=\"glass\"\n                                        side=\"top\"\n                                        align=\"center\"\n                                        estimatedHeight={480}\n                                        fixedWidth={640}\n                                        className=\"!p-0\"\n                                        forceOpen={activeTooltipId === `preview-${item.videoId}`}\n                                    >\n                                        <div\n                                            className=\"text-text-secondary hover:text-white cursor-pointer transition-colors\"\n                                            onClick={(e) => e.stopPropagation()}\n                                        >\n                                            <Info size={14} />\n                                        </div>\n                                    </PortalTooltip>\n                                </div>\n                            )}\n                        </div>\n                    </div>\n\n                    {/* Niche Badges - Fixed Position (Before External Link) */}\n                    <TrafficRowBadges\n                        niches={assignedNiches}\n                        suggested={suggestedNiche}\n                        onConfirmSuggestion={(niche) => item.videoId && onConfirmSuggestion?.(item.videoId, niche)}\n                    />\n\n                    {/* Actions Group - Appears on Row Hover */}\n                    <div className=\"flex items-center gap-3 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0\">\n                        {item.videoId && (\n                            <>\n                                {/* External Link */}\n                                <a\n                                    href={`https://youtu.be/${item.videoId}`}\n                                    target=\"_blank\"\n                                    rel=\"noreferrer\"\n                                    onClick={(e) => e.stopPropagation()}\n                                    className=\"p-1.5 -m-1.5 text-text-secondary hover:text-white transition-colors flex items-center justify-center\"\n                                >\n                                    <ExternalLink size={14} />\n                                </a>\n                            </>\n                        )}\n                    </div>\n                </div>\n            </div>\n\n            {/* Traffic Type Indicator */}\n            {onToggleTrafficType && (\n                <div className=\"flex items-center justify-center\">\n                    <PortalTooltip\n                        content={typeLabel}\n                        enterDelay={300}\n                        side=\"top\"\n                        className=\"!px-2.5 !py-1 !border-none !shadow-xl !bg-[#1F1F1F]\"\n                    >\n                        <button\n                            onClick={handleTypeClick}\n                            className={`\n                                p-1.5 rounded-full transition-transform duration-200\n                                hover:bg-white/10 active:scale-95\n                                ${typeColor} ${typeActiveClass}\n                            `}\n                        >\n                            <div className=\"relative\">\n                                <TypeIcon size={14} className={trafficType === 'autoplay' ? 'animate-pulse' : ''} />\n                                {trafficSource === 'smart_assistant' && (\n                                    <div className=\"absolute -bottom-1 -right-1\">\n                                        <Wand2 className=\"w-2.5 h-2.5 text-blue-500 fill-blue-500 drop-shadow-[0_0_2px_rgba(0,0,0,0.8)]\" />\n                                    </div>\n                                )}\n                            </div>\n                        </button>\n                    </PortalTooltip>\n                </div>\n            )}\n\n            {/* Viewer Type Indicator */}\n            {onToggleViewerType && (\n                <div className=\"flex items-center justify-center\">\n                    <PortalTooltip\n                        content={viewerLabel}\n                        enterDelay={300}\n                        side=\"top\"\n                        className=\"!px-2.5 !py-1 !border-none !shadow-xl !bg-[#1F1F1F]\"\n                    >\n                        <button\n                            onClick={handleViewerClick}\n                            className={`\n                                p-1.5 rounded-full transition-transform duration-200\n                                hover:bg-white/10 active:scale-95\n                                ${viewerColor} ${viewerActiveClass}\n                            `}\n                        >\n                            <div className=\"relative\">\n                                <ViewerIcon size={14} />\n                                {viewerSource === 'smart_assistant' && (\n                                    <div className=\"absolute -bottom-1 -right-1\">\n                                        <Wand2 className=\"w-2.5 h-2.5 text-blue-500 fill-blue-500 drop-shadow-[0_0_2px_rgba(0,0,0,0.8)]\" />\n                                    </div>\n                                )}\n                            </div>\n                        </button>\n                    </PortalTooltip>\n                </div>\n            )}\n\n            <div className={`text-right ${activeSortKey === 'impressions' ? 'text-text-primary font-medium' : 'text-text-secondary'}`}>\n                {item.impressions.toLocaleString()}\n            </div>\n\n            <div\n                className={`text-right ${activeSortKey === 'ctr' ? 'text-text-primary font-medium' : 'text-text-secondary'}`}\n                style={{ color: getCtrColor(item.ctr, ctrRules) }}\n            >\n                {item.ctr}%\n            </div>\n\n            <div className={`text-right ${activeSortKey === 'views' ? 'text-text-primary font-medium' : 'text-text-secondary'}`}>\n                {item.views.toLocaleString()}\n            </div>\n\n            <div className={`text-right ${activeSortKey === 'avgViewDuration' ? 'text-text-primary font-medium' : 'text-text-secondary'}`}>\n                {formatDuration(item.avgViewDuration)}\n            </div>\n        </div>\n    );\n};\n\nTrafficRow.displayName = 'TrafficRow';\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficRowBadges.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficTable.tsx","messages":[{"ruleId":"react-hooks/incompatible-library","severity":1,"message":"Compilation Skipped: Use of incompatible library\n\nThis API returns functions which cannot be memoized without leading to stale UI. To prevent this, by default React Compiler will skip memoizing this component/hook. However, you may see issues if values from this API are passed to other components/hooks that are memoized.\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficTable.tsx:186:28\n  184 |     }, [data, sortConfig, trafficEdges, viewerEdges]);\n  185 |\n> 186 |     const rowVirtualizer = useVirtualizer({\n      |                            ^^^^^^^^^^^^^^ TanStack Virtual's `useVirtualizer()` API returns functions that cannot be memoized safely\n  187 |         count: sortedData.length,\n  188 |         getScrollElement: () => parentRef.current,\n  189 |         estimateSize: () => TRAFFIC_TABLE.ROW_HEIGHT,","line":186,"column":28,"nodeType":null,"endLine":186,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useRef, useMemo, memo } from 'react';\nimport { useVirtualizer } from '@tanstack/react-virtual';\nimport { ArrowUp, ArrowDown } from 'lucide-react';\nimport type { TrafficSource } from '../../../../../core/types/traffic';\nimport { Checkbox } from '../../../../../components/ui/atoms/Checkbox/Checkbox';\nimport { TrafficRow } from './TrafficRow';\nimport { TrafficEmptyState } from './TrafficEmptyState';\nimport { formatDuration, durationToSeconds } from '../utils/formatters';\nimport { TRAFFIC_TABLE } from '../utils/constants';\nimport type { CTRRule } from '../../../../../core/services/settingsService';\nimport { useTrafficNicheStore } from '../../../../../core/stores/useTrafficNicheStore';\nimport { SmartTrafficTooltip } from './SmartTrafficTooltip';\n\nimport type { SuggestedTrafficNiche } from '../../../../../core/types/suggestedTrafficNiches';\n\nimport type { VideoDetails } from '../../../../../core/utils/youtubeApi';\n\n\nimport type { TrafficType } from '../../../../../core/types/videoTrafficType';\nimport type { ViewerType } from '../../../../../core/types/viewerType';\n\nexport type SortKey = keyof TrafficSource | 'trafficType' | 'viewerType';\nexport interface SortConfig {\n    key: SortKey;\n    direction: 'asc' | 'desc';\n}\n\ninterface TrafficTableProps {\n    data: TrafficSource[];\n    isLoading: boolean;\n    // Selection for grouping\n    selectedIds: Set<string>;\n    onToggleSelection: (id: string) => void;\n    onToggleAll: (ids: string[]) => void;\n\n    // For Drag and Drop Grouping (future) or just Visuals\n    activeGroupId?: string; // If filtering by group\n\n    // Versioning\n    viewingVersion?: number | 'draft';\n    activeVersion: number;\n\n    // Upload for Empty State\n    onUpload: (sources: TrafficSource[], totalRow?: TrafficSource, file?: File) => Promise<void>;\n    hasExistingSnapshot: boolean;\n    hasPreviousSnapshots?: boolean; // Are there snapshots in earlier versions?\n    isFirstSnapshot?: boolean; // Is this the very first snapshot of the current version?\n    isViewingSnapshot?: boolean;\n\n    // CTR Rules\n    ctrRules?: CTRRule[];\n\n    // View mode to determine empty state type\n    viewMode?: 'cumulative' | 'delta';\n\n    // Filters\n    hasActiveFilters?: boolean;\n\n    // View switch\n    onSwitchToTotal?: () => void;\n\n    // Rich Data\n    videos?: VideoDetails[];\n\n    // Sorting (Controlled)\n    sortConfig: SortConfig | null;\n    onSort: (key: SortKey) => void;\n\n    // Smart Assistant\n    getSuggestion?: (videoId: string) => SuggestedTrafficNiche | null;\n    onConfirmSuggestion?: (videoId: string, niche: SuggestedTrafficNiche) => void;\n\n    // Traffic Types\n    trafficEdges?: Record<string, { type: TrafficType; source?: 'manual' | 'smart_assistant' }>;\n    onToggleTrafficType?: (videoId: string, currentType?: TrafficType) => void;\n\n    // Viewer Types\n    viewerEdges?: Record<string, { type: ViewerType; source?: 'manual' | 'smart_assistant' }>;\n    onToggleViewerType?: (videoId: string, currentType?: ViewerType) => void;\n\n    // Discrepancy reporting\n    actualTotalRow?: TrafficSource;\n    trashMetrics?: import('../hooks/useTrafficDataLoader').TrashMetrics;\n    deltaContext?: import('../hooks/useTrafficDataLoader').DeltaContext;\n}\n\nexport const TrafficTable = memo<TrafficTableProps>(({\n    data,\n    selectedIds,\n    onToggleSelection,\n    onToggleAll,\n    isLoading,\n    onUpload,\n    hasExistingSnapshot,\n    hasPreviousSnapshots = false,\n    isFirstSnapshot = false,\n    isViewingSnapshot = false,\n    ctrRules = [],\n    viewMode = 'cumulative',\n    hasActiveFilters = false,\n    onSwitchToTotal,\n    videos = [],\n    sortConfig,\n    onSort,\n    getSuggestion,\n    onConfirmSuggestion,\n    actualTotalRow,\n    trashMetrics,\n    deltaContext,\n    trafficEdges,\n    onToggleTrafficType,\n    viewerEdges,\n    onToggleViewerType\n}) => {\n    // Virtualization refs\n    const parentRef = useRef<HTMLDivElement>(null);\n    // Local sort state removed in favor of props\n\n    // State for controlled tooltips (SmartTrafficTooltip)\n    const [hoveredTooltipId, setHoveredTooltipId] = React.useState<string | null>(null);\n    const tooltipTimeoutRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n\n    const handleTooltipEnter = useCallback((id: string) => {\n        if (tooltipTimeoutRef.current) {\n            clearTimeout(tooltipTimeoutRef.current);\n            tooltipTimeoutRef.current = null;\n        }\n        setHoveredTooltipId(id);\n    }, []);\n\n    const handleTooltipLeave = useCallback(() => {\n        if (tooltipTimeoutRef.current) clearTimeout(tooltipTimeoutRef.current);\n\n        tooltipTimeoutRef.current = setTimeout(() => {\n            setHoveredTooltipId(null);\n            tooltipTimeoutRef.current = null;\n        }, 500); // 500ms Grace Period: Sufficient bridge to survive heavy iframe renders and mouse flickers\n    }, []);\n\n    // Lookup map for rich video details\n    const videoMap = useMemo(() => {\n        const map = new Map<string, VideoDetails>();\n        videos.forEach(v => map.set(v.id, v));\n        return map;\n    }, [videos]);\n\n    const sortedData = useMemo(() => {\n        if (!sortConfig) return data;\n\n        return [...data].sort((a, b) => {\n            let comparison = 0;\n            const { key, direction } = sortConfig;\n\n            if (key === 'trafficType') {\n                const aType = a.videoId && trafficEdges ? (trafficEdges[a.videoId]?.type || '') : '';\n                const bType = b.videoId && trafficEdges ? (trafficEdges[b.videoId]?.type || '') : '';\n                comparison = aType.localeCompare(bType);\n            } else if (key === 'viewerType') {\n                const aType = a.videoId && viewerEdges ? (viewerEdges[a.videoId]?.type || '') : '';\n                const bType = b.videoId && viewerEdges ? (viewerEdges[b.videoId]?.type || '') : '';\n                comparison = aType.localeCompare(bType);\n            } else if (key === 'avgViewDuration') {\n                comparison = durationToSeconds(a.avgViewDuration) - durationToSeconds(b.avgViewDuration);\n            } else {\n                // Key is keyof TrafficSource\n                const aVal = a[key as keyof TrafficSource];\n                const bVal = b[key as keyof TrafficSource];\n\n                if (typeof aVal === 'number' && typeof bVal === 'number') {\n                    comparison = aVal - bVal;\n                } else if (typeof aVal === 'string' && typeof bVal === 'string') {\n                    comparison = aVal.localeCompare(bVal);\n                } else if (aVal != null && bVal != null) {\n                    comparison = String(aVal).localeCompare(String(bVal));\n                } else if (aVal != null) {\n                    comparison = 1;\n                } else if (bVal != null) {\n                    comparison = -1;\n                }\n            }\n\n            return direction === 'asc' ? comparison : -comparison;\n        });\n    }, [data, sortConfig, trafficEdges, viewerEdges]);\n\n    const rowVirtualizer = useVirtualizer({\n        count: sortedData.length,\n        getScrollElement: () => parentRef.current,\n        estimateSize: () => TRAFFIC_TABLE.ROW_HEIGHT,\n        overscan: TRAFFIC_TABLE.OVERSCAN_COUNT,\n    });\n\n    const handleRowClick = useCallback((id: string, _index: number, e: React.MouseEvent) => {\n        // Prevent selection when clicking links or interactive elements\n        if ((e.target as HTMLElement).closest('a') || (e.target as HTMLElement).closest('button')) {\n            return;\n        }\n\n        onToggleSelection(id);\n    }, [onToggleSelection]);\n\n    const handleHeaderCheckbox = useCallback(() => {\n        const allIds = data.map(d => d.videoId).filter(Boolean) as string[];\n        onToggleAll(allIds);\n    }, [data, onToggleAll]);\n\n    // handleSort uses prop now\n    const handleSort = (key: SortKey) => {\n        onSort(key);\n    };\n\n    const isAllSelected = data.length > 0 && data.every(d => d.videoId && selectedIds.has(d.videoId));\n    const isIndeterminate = data.some(d => d.videoId && selectedIds.has(d.videoId)) && !isAllSelected;\n\n\n    const { niches, assignments } = useTrafficNicheStore();\n\n    const showPropertyColumn = useMemo(() => {\n        if (!data.length) return false;\n        return data.some(item => {\n            if (!item.videoId) return false;\n            const myAssignmentIds = assignments\n                .filter(a => a.videoId === item.videoId)\n                .map(a => a.nicheId);\n            const myNiches = niches.filter(n => myAssignmentIds.includes(n.id));\n            return myNiches.some(n => n.property && ['desired', 'targeted', 'unrelated'].includes(n.property));\n        });\n    }, [data, niches, assignments]);\n\n    const gridClassName = showPropertyColumn\n        ? \"grid-cols-[40px_24px_1fr_22px_22px_70px_60px_70px_80px]\"\n        : \"grid-cols-[40px_1fr_22px_22px_70px_60px_70px_80px]\";\n\n    const computedTotal = useMemo(() => {\n        if (data.length === 0) return null;\n\n        const totalImpressions = data.reduce((sum, s) => sum + (s.impressions || 0), 0);\n        const totalViews = data.reduce((sum, s) => sum + (s.views || 0), 0);\n        const totalWatchTimeHours = data.reduce((sum, s) => sum + (s.watchTimeHours || 0), 0);\n        const totalWatchTimeSeconds = totalWatchTimeHours * 3600;\n\n        const avgCtr = totalImpressions > 0 ? (totalViews / totalImpressions) * 100 : 0;\n        const avgDurationSeconds = totalViews > 0 ? totalWatchTimeSeconds / totalViews : 0;\n\n        return {\n            impressions: totalImpressions,\n            views: totalViews,\n            ctr: parseFloat(avgCtr.toFixed(2)),\n            avgViewDuration: Math.round(avgDurationSeconds).toString(),\n        };\n    }, [data]);\n\n    const renderHeaderCell = (label: string, sortKey?: SortKey, align: 'left' | 'right' = 'right') => {\n        const isSorted = sortConfig?.key === sortKey;\n        const canSort = !!sortKey;\n\n        return (\n            <div\n                className={`flex items-center gap-1 ${align === 'right' ? 'justify-end' : 'justify-start'} ${canSort ? 'cursor-pointer hover:text-white transition-colors select-none' : ''}`}\n                onClick={() => canSort && handleSort(sortKey)}\n            >\n                {label}\n                {canSort && (\n                    <div className=\"w-3 flex-shrink-0\">\n                        {isSorted && sortConfig ? (\n                            sortConfig.direction === 'asc' ? <ArrowUp size={12} /> : <ArrowDown size={12} />\n                        ) : (\n                            <ArrowDown size={12} className=\"opacity-0 group-hover:opacity-40 transition-opacity\" />\n                        )}\n                    </div>\n                )}\n            </div>\n        );\n    };\n\n    // Determine if we should show the empty state without table structure\n    // isInitialEmpty: truly no data uploaded yet (no snapshots exist)\n    const isInitialEmpty = !isLoading && data.length === 0 && !hasExistingSnapshot;\n\n    // Check if empty due to filters or delta (when not initial empty)\n    const isFilteredEmpty = !isLoading && data.length === 0 && hasActiveFilters;\n    const isDeltaEmpty = !isLoading && data.length === 0 && !hasActiveFilters && viewMode === 'delta';\n\n    // If initial empty state (no CSV uploaded yet), show empty state without table\n    // IMPORTANT: Only show this if we're certain there are no snapshots\n    if (isInitialEmpty) {\n        return (\n            <TrafficEmptyState\n                onUpload={onUpload}\n                hasExistingSnapshot={hasExistingSnapshot}\n                mode=\"no-data\"\n                onSwitchToTotal={onSwitchToTotal}\n            />\n        );\n    }\n\n    return (\n        <div className=\"w-full h-full flex flex-col bg-bg-secondary/30 rounded-xl border border-white/5 overflow-hidden relative\">\n            {/* Fixed Header - Show when loading OR when there's data OR when filtered/delta empty */}\n            {/* Fixed Header - Show when loading OR when there's data OR when filtered/delta empty */}\n            <div className={`grid ${gridClassName} gap-2 px-4 py-3 bg-white/5 border-b border-white/5 text-xs font-medium text-text-secondary uppercase tracking-wider flex-shrink-0 group`}>\n                <div className=\"flex items-center justify-center\">\n                    <Checkbox\n                        checked={isAllSelected}\n                        indeterminate={isIndeterminate}\n                        onChange={handleHeaderCheckbox}\n                        disabled={isLoading || data.length === 0}\n                    />\n                </div>\n                {showPropertyColumn && <div></div>} {/* Property Icon Column */}\n                <div>Traffic Source</div>\n                {/* Traffic Type Header */}\n                {renderHeaderCell('', 'trafficType', 'left')}\n                {/* Viewer Type Header */}\n                {renderHeaderCell('', 'viewerType', 'left')}\n                {renderHeaderCell('Impr.', 'impressions')}\n                {renderHeaderCell('CTR', 'ctr')}\n                {renderHeaderCell('Views', 'views')}\n                {renderHeaderCell('AVD', 'avgViewDuration')}\n            </div>\n\n            <div\n                ref={parentRef}\n                className=\"flex-1 overflow-y-auto min-h-0 relative custom-scrollbar\"\n            >\n                {isLoading ? (\n                    <div className=\"px-4 py-3 text-xs font-medium text-center bg-clip-text text-transparent flex justify-center items-center\"\n                        style={{\n                            backgroundImage: 'linear-gradient(120deg, var(--text-secondary) 42%, var(--text-primary) 50%, var(--text-secondary) 58%)',\n                            backgroundSize: '200% 100%',\n                            display: 'inline-block',\n                            width: '100%',\n                            animation: 'shimmer-premium 2.5s infinite linear',\n                        }}\n                    >\n                        <style>\n                            {`\n                                @keyframes shimmer-premium {\n                                    0% { background-position: 100% 0; }\n                                    100% { background-position: -100% 0; }\n                                }\n                            `}\n                        </style>\n                        Loading traffic data...\n                    </div>\n                ) : isFilteredEmpty ? (\n                    <TrafficEmptyState\n                        onUpload={onUpload}\n                        hasExistingSnapshot={hasExistingSnapshot}\n                        mode=\"no-matches\"\n                        onSwitchToTotal={onSwitchToTotal}\n                    />\n                ) : isDeltaEmpty ? (\n                    <TrafficEmptyState\n                        onUpload={onUpload}\n                        hasExistingSnapshot={hasExistingSnapshot}\n                        hasPreviousSnapshots={hasPreviousSnapshots}\n                        isFirstSnapshot={isFirstSnapshot}\n                        isViewingSnapshot={isViewingSnapshot}\n                        mode=\"no-new-data\"\n                        onSwitchToTotal={onSwitchToTotal}\n                    />\n                ) : (\n                    <>\n                        {computedTotal && (\n                            <div className={`sticky top-0 z-10 grid ${gridClassName} gap-2 px-4 py-3 border-b border-white/10 bg-video-edit-bg backdrop-blur-md font-bold text-text-primary text-xs select-none shadow-sm`}>\n                                <div />\n                                {showPropertyColumn && <div />}\n                                <div>Total</div>\n                                {/* Traffic Type Total Cell (Empty) */}\n                                <div />\n                                {/* Viewer Type Total Cell (Empty) */}\n                                <div />\n                                <div className={`text-right flex items-center justify-end gap-1.5 ${sortConfig?.key === 'impressions' ? 'text-text-primary font-semibold' : 'text-text-secondary'}`}>\n                                    {actualTotalRow && !hasActiveFilters && Number(actualTotalRow.impressions || 0) > (computedTotal.impressions + 1) && (\n                                        <SmartTrafficTooltip\n                                            actualTotal={Number(actualTotalRow.impressions)}\n                                            tableSum={computedTotal.impressions}\n                                            trashValue={trashMetrics?.impressions}\n                                            deltaContext={deltaContext?.impressions}\n                                            isIncomplete={deltaContext?.isIncomplete}\n                                            forceOpen={hoveredTooltipId === 'total-impressions'}\n                                            onMouseEnter={() => handleTooltipEnter('total-impressions')}\n                                            onMouseLeave={handleTooltipLeave}\n                                        />\n                                    )}\n                                    {computedTotal.impressions.toLocaleString()}\n                                </div>\n                                <div className={`text-right ${sortConfig?.key === 'ctr' ? 'text-text-primary font-semibold' : 'text-text-secondary'}`}>\n                                    {computedTotal.ctr}%\n                                </div>\n                                <div className={`text-right flex items-center justify-end gap-1.5 ${sortConfig?.key === 'views' ? 'text-text-primary font-semibold' : 'text-text-secondary'}`}>\n                                    {actualTotalRow && !hasActiveFilters && Number(actualTotalRow.views || 0) > (computedTotal.views + 1) && (\n                                        <SmartTrafficTooltip\n                                            actualTotal={Number(actualTotalRow.views)}\n                                            tableSum={computedTotal.views}\n                                            trashValue={trashMetrics?.views}\n                                            deltaContext={deltaContext?.views}\n                                            isIncomplete={deltaContext?.isIncomplete}\n                                            forceOpen={hoveredTooltipId === 'total-views'}\n                                            onMouseEnter={() => handleTooltipEnter('total-views')}\n                                            onMouseLeave={handleTooltipLeave}\n                                        />\n                                    )}\n                                    {computedTotal.views.toLocaleString()}\n                                </div>\n                                <div className={`text-right ${sortConfig?.key === 'avgViewDuration' ? 'text-text-primary font-semibold' : 'text-text-secondary'}`}>\n                                    {formatDuration(computedTotal.avgViewDuration)}\n                                </div>\n                            </div>\n                        )}\n\n                        <div\n                            style={{\n                                height: `${rowVirtualizer.getTotalSize()}px`,\n                                width: '100%',\n                                position: 'relative',\n                                paddingBottom: '80px',\n                            }}\n                        >\n                            {rowVirtualizer.getVirtualItems().map((virtualRow) => {\n                                const item = sortedData[virtualRow.index];\n                                const index = virtualRow.index;\n                                const isSelected = item.videoId ? selectedIds.has(item.videoId) : false;\n                                const videoDetails = item.videoId ? videoMap.get(item.videoId) : undefined;\n\n                                // Lookup Traffic Type\n                                const trafficEdge = item.videoId && trafficEdges ? trafficEdges[item.videoId] : undefined;\n\n                                // Lookup Viewer Type\n                                const viewerEdge = item.videoId && viewerEdges ? viewerEdges[item.videoId] : undefined;\n\n                                // Lookup Smart Suggestion\n                                const suggestion = item.videoId && getSuggestion ? getSuggestion(item.videoId) : null;\n\n                                return (\n                                    <div\n                                        key={item.videoId || virtualRow.key}\n                                        style={{\n                                            position: 'absolute',\n                                            top: 0,\n                                            left: 0,\n                                            width: '100%',\n                                            height: `${virtualRow.size}px`,\n                                            transform: `translateY(${virtualRow.start}px)`,\n                                        }}\n                                    >\n                                        <TrafficRow\n                                            item={item}\n                                            index={index}\n                                            isSelected={isSelected}\n                                            activeSortKey={sortConfig?.key}\n                                            onRowClick={handleRowClick}\n                                            ctrRules={ctrRules}\n                                            gridClassName={gridClassName}\n                                            showPropertyIcon={showPropertyColumn}\n                                            videoDetails={videoDetails}\n                                            suggestedNiche={suggestion ? suggestion : undefined}\n                                            onConfirmSuggestion={onConfirmSuggestion}\n                                            trafficType={trafficEdge?.type}\n                                            trafficSource={trafficEdge?.source}\n                                            onToggleTrafficType={onToggleTrafficType}\n                                            viewerType={viewerEdge?.type}\n                                            viewerSource={viewerEdge?.source}\n                                            onToggleViewerType={onToggleViewerType}\n                                            activeTooltipId={hoveredTooltipId}\n                                            onTooltipEnter={handleTooltipEnter}\n                                            onTooltipLeave={handleTooltipLeave}\n                                        />\n                                    </div>\n                                );\n                            })}\n                        </div>\n                    </>\n                )}\n            </div>\n        </div>\n    );\n});\n\nTrafficTable.displayName = 'TrafficTable';\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/TrafficUploader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/components/VersionPills.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useCTRRules.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useCTRRules.ts:22:13\n  20 |     useEffect(() => {\n  21 |         if (trafficSettings?.ctrRules) {\n> 22 |             setLocalRules(trafficSettings.ctrRules);\n     |             ^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  23 |         }\n  24 |     }, [trafficSettings?.ctrRules]);\n  25 |","line":22,"column":13,"nodeType":null,"endLine":22,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\nimport { useAuth } from '../../../../../core/hooks/useAuth';\nimport { useChannelStore } from '../../../../../core/stores/channelStore';\nimport { useSettings } from '../../../../../core/hooks/useSettings';\nimport { PRESET_COLORS } from '../utils/constants';\nimport type { CTRRule } from '../../../../../core/services/settingsService';\n\n/**\n *    CTR .\n */\nexport const useCTRRules = () => {\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { trafficSettings, updateTrafficSettings } = useSettings();\n\n    // Local optimistic state to prevent jitter during drag-and-drop\n    const [localRules, setLocalRules] = useState<CTRRule[]>([]);\n\n    // Sync local state with store on load / external update\n    useEffect(() => {\n        if (trafficSettings?.ctrRules) {\n            setLocalRules(trafficSettings.ctrRules);\n        }\n    }, [trafficSettings?.ctrRules]);\n\n    const hasChanges = false; // Kept for API compatibility, though currently unused\n\n    /**\n     *    Firestore\n     */\n    const saveRules = async (newRules: CTRRule[]) => {\n        // 1. Optimistic Update\n        setLocalRules(newRules);\n\n        if (!user?.uid || !currentChannel?.id) return;\n\n        try {\n            // 2. Persist to Backend\n            await updateTrafficSettings(user.uid, currentChannel.id, { ctrRules: newRules });\n        } catch (e) {\n            console.error(\"Failed to save CTR rules\", e);\n            // Revert on error\n            if (trafficSettings?.ctrRules) {\n                setLocalRules(trafficSettings.ctrRules);\n            }\n        }\n    };\n\n    /**\n     *      \n     */\n    const addRule = () => {\n        const lastRule = localRules[localRules.length - 1];\n        let nextValue = 5;\n        let nextColor = PRESET_COLORS[0];\n\n        if (lastRule) {\n            nextValue = lastRule.value + 1;\n            const colorIndex = PRESET_COLORS.indexOf(lastRule.color);\n            if (colorIndex !== -1) {\n                nextColor = PRESET_COLORS[(colorIndex + 1) % PRESET_COLORS.length];\n            }\n        }\n\n        const newRules = [\n            ...localRules,\n            { id: crypto.randomUUID(), operator: '<' as const, value: nextValue, color: nextColor }\n        ];\n\n        saveRules(newRules);\n    };\n\n    /**\n     *   \n     */\n    const updateRule = (id: string, updates: Partial<CTRRule>) => {\n        const newRules = localRules.map(r => {\n            if (r.id !== id) return r;\n\n            const updated = { ...r, ...updates };\n\n            // : CTR     100%\n            if (updated.value > 100) updated.value = 100;\n            if (updated.maxValue !== undefined && updated.maxValue > 100) {\n                updated.maxValue = 100;\n            }\n\n            return updated;\n        });\n\n        saveRules(newRules);\n    };\n\n    /**\n     *  \n     */\n    const removeRule = (id: string) => {\n        const newRules = localRules.filter(r => r.id !== id);\n        saveRules(newRules);\n    };\n\n    /**\n     *   ( drag-and-drop)\n     */\n    const reorderRules = (newRules: CTRRule[]) => {\n        saveRules(newRules);\n    };\n\n    return {\n        rules: localRules,\n        hasChanges,\n        addRule,\n        updateRule,\n        removeRule,\n        reorderRules\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useMissingTitles.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'trafficData.snapshots'. Either include it or remove the dependency array.","line":252,"column":8,"nodeType":"ArrayExpression","endLine":252,"endColumn":164,"suggestions":[{"desc":"Update the dependencies array to be: [missingCount, unenrichedCount, apiKey, currentSnapshotId, displayedSources, trafficData.snapshots, userId, channelId, cachedVideos, onDataRestored, trafficVideoId, activeVersion]","fix":{"range":[9874,10030],"text":"[missingCount, unenrichedCount, apiKey, currentSnapshotId, displayedSources, trafficData.snapshots, userId, channelId, cachedVideos, onDataRestored, trafficVideoId, activeVersion]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useMemo, useCallback } from 'react';\nimport type { TrafficSource, TrafficData, TrafficSnapshot } from '../../../../../core/types/traffic';\nimport type { VideoDetails } from '../../../../../core/utils/youtubeApi';\nimport { fetchVideosBatch } from '../../../../../core/utils/youtubeApi';\nimport { VideoService } from '../../../../../core/services/videoService';\nimport { TrafficSnapshotService } from '../../../../../core/services/traffic/TrafficSnapshotService';\nimport { generateTrafficCsv } from '../utils/csvGenerator';\nimport { assistantLogger } from '../../../../../core/utils/logger';\n\ninterface UseMissingTitlesProps {\n    displayedSources: TrafficSource[];\n    userId: string;\n    channelId: string;\n    trafficVideoId: string; // The ID of the video whose traffic we are viewing\n    activeVersion: number;\n    apiKey: string;\n    currentSnapshotId?: string | null;\n    cachedVideos?: VideoDetails[];\n    onDataRestored?: (newSources: TrafficSource[], newSnapshotId: string) => void;\n    trafficData?: TrafficData | null;\n}\n\nexport const repairTrafficSources = async (\n    sources: TrafficSource[],\n    userId: string,\n    channelId: string,\n    apiKey: string,\n    cachedVideos: VideoDetails[] = []\n): Promise<TrafficSource[]> => {\n    // 1. Identify missing (either title is missing OR channelId is missing)\n    const missingSources = sources.filter(s => {\n        if (!s.videoId) return false;\n        const missingTitle = !s.sourceTitle || s.sourceTitle.trim() === '';\n        const missingChannelId = !s.channelId;\n        return missingTitle || missingChannelId;\n    });\n\n    if (missingSources.length === 0) {\n        assistantLogger.debug('No sources need repair');\n        return sources;\n    }\n\n    const uniqueVideoIds = Array.from(new Set(missingSources.map(s => s.videoId!)));\n    assistantLogger.info('Identified videos to fetch/enrich', {\n        missingCount: missingSources.length,\n        uniqueCount: uniqueVideoIds.length\n    });\n\n    // 2. Filter out already cached videos (if we already have channelId in cache, we don't need to refetch)\n    const cachedMap = new Map<string, VideoDetails>(cachedVideos.map(v => [v.id, v]));\n    const videoIdsToFetch = uniqueVideoIds.filter((id: string) => {\n        const cached = cachedMap.get(id);\n        if (!cached) return true;\n        // Even if in cache, if it's missing channelId there too, we should try to fetch (unlikely but safe)\n        return !cached.channelId;\n    });\n\n    const fetchedMap = new Map<string, VideoDetails>();\n\n    if (videoIdsToFetch.length > 0) {\n        // 3. Batch Fetch from YouTube\n        const chunks = [];\n        for (let i = 0; i < videoIdsToFetch.length; i += 50) {\n            chunks.push(videoIdsToFetch.slice(i, i + 50));\n        }\n\n        for (const chunk of chunks) {\n            const batch = await fetchVideosBatch(chunk, apiKey);\n            batch.forEach(v => fetchedMap.set(v.id, v));\n        }\n\n        // 4. Persist newly fetched to Firestore (Rich Metadata)\n        const allFetchedVideos = Array.from(fetchedMap.values());\n        const batchWrites = allFetchedVideos.map(video => {\n            const cleanData = JSON.parse(JSON.stringify(video));\n            return {\n                videoId: video.id,\n                data: {\n                    ...cleanData,\n                    lastUpdated: Date.now()\n                }\n            };\n        });\n\n        if (batchWrites.length > 0) {\n            await VideoService.batchUpdateSuggestedVideos(userId, channelId, batchWrites);\n        }\n    }\n\n    // 5. Update Sources (Merging results from YouTube and Cache)\n    return sources.map(source => {\n        if (source.videoId) {\n            // Priority: newly fetched > cached\n            const details = fetchedMap.get(source.videoId) || cachedMap.get(source.videoId);\n            if (details) {\n                // Merge available details back into source to make it \"Smart\"\n                return {\n                    ...source,\n                    sourceTitle: details.title || source.sourceTitle,\n                    channelId: details.channelId || source.channelId,\n                    channelTitle: details.channelTitle || source.channelTitle,\n                    thumbnail: details.thumbnail || source.thumbnail,\n                    publishedAt: details.publishedAt || source.publishedAt\n                };\n            }\n        }\n        return source;\n    });\n};\n\nexport const useMissingTitles = ({\n    displayedSources,\n    userId,\n    channelId,\n    trafficVideoId,\n    activeVersion,\n    apiKey,\n    currentSnapshotId,\n    cachedVideos = [],\n    onDataRestored,\n    trafficData\n}: UseMissingTitlesProps) => {\n    const [isRestoring, setIsRestoring] = useState(false);\n\n    // 1. Detect missing titles (Legacy Check for Dumb CSVs)\n    const missingSources = useMemo(() => {\n        return displayedSources.filter(s => s.videoId && (!s.sourceTitle || s.sourceTitle.trim() === ''));\n    }, [displayedSources]);\n\n    const missingCount = missingSources.length;\n\n    // 2. Detect Unenriched Videos (Missing Channel Data for Smart Assistant)\n    // Only counts videos that are NOT missing titles (since missing titles implies unenriched anyway)\n    // and specifically lack channelId.\n    const unenrichedSources = useMemo(() => {\n        const cachedMap = new Map(cachedVideos.map(v => [v.id, v]));\n\n        const results = displayedSources.filter(s => {\n            if (!s.videoId) return false;\n            // If title is missing, it's already caught by missingCount\n            if (!s.sourceTitle || s.sourceTitle.trim() === '') return false;\n\n            // It IS missing channelId?\n            const hasSourceChannelId = !!s.channelId;\n            // AND we don't have it in cache?\n            const hasCachedChannelId = cachedMap.has(s.videoId) && !!cachedMap.get(s.videoId)?.channelId;\n\n            // If we don't have it in source AND don't have it in cache = UNENRICHED\n            return !hasSourceChannelId && !hasCachedChannelId;\n        });\n\n        assistantLogger.debug('Unenriched calculation', {\n            displayedCount: displayedSources.length,\n            unenrichedCount: results.length,\n            firstUnenriched: results[0]\n        });\n        return results;\n    }, [displayedSources, cachedVideos]);\n\n    const unenrichedCount = unenrichedSources.length;\n\n\n    // 3. Calculate Quota\n    // Combined quota estimation if we ran repair on everything\n    const estimatedQuota = Math.ceil((missingCount + unenrichedCount) / 50) * 7;\n\n    // 4. Action: Fetch & Restore\n    const fetchMissingTitles = useCallback(async () => {\n        if ((missingCount === 0 && unenrichedCount === 0) || !apiKey) return;\n\n        assistantLogger.debug('Starting repair process', {\n            missingCount,\n            unenrichedCount,\n            currentSnapshotId\n        });\n\n        setIsRestoring(true);\n        try {\n            // CRITICAL FIX: Ensure we use the FULL dataset if a snapshot exists.\n            let sourcesToRepair = displayedSources;\n\n            if (currentSnapshotId && trafficData?.snapshots) {\n                const snapshot = trafficData.snapshots.find((s: TrafficSnapshot) => s.id === currentSnapshotId);\n                if (snapshot) {\n                    const { loadSnapshotSources } = await import('../utils/snapshotLoader');\n                    const { sources } = await loadSnapshotSources(snapshot);\n                    if (sources.length > 0) {\n                        sourcesToRepair = sources;\n                        assistantLogger.info('Loaded full snapshot for repair', {\n                            count: sources.length\n                        });\n                    }\n                }\n            }\n\n            // Use the extracted logic - it handles both missing titles and enriching metadata\n            // because `repairTrafficSources` fetches everything not in cache.\n            const updatedSources = await repairTrafficSources(sourcesToRepair, userId, channelId, apiKey, cachedVideos);\n\n            assistantLogger.info('Repaired sources successfully', {\n                originalCount: sourcesToRepair.length,\n                updatedCount: updatedSources.length,\n                difference: updatedSources.length - sourcesToRepair.length\n            });\n\n            // D. Regenerate CSV & Update Snapshot\n            const csvContent = generateTrafficCsv(updatedSources);\n            const csvFile = new File([csvContent], \"repaired_traffic_data.csv\", { type: \"text/csv\" });\n\n            let snapshotId = currentSnapshotId;\n\n            if (currentSnapshotId) {\n                // Update existing snapshot\n                assistantLogger.info('Updating existing snapshot with repaired data', {\n                    currentSnapshotId\n                });\n                await TrafficSnapshotService.update(\n                    userId,\n                    channelId,\n                    trafficVideoId,\n                    currentSnapshotId,\n                    updatedSources,\n                    undefined,\n                    csvFile\n                );\n            } else {\n                // Create new snapshot\n                assistantLogger.info('Creating new snapshot with repaired data');\n                snapshotId = await TrafficSnapshotService.create(\n                    userId,\n                    channelId,\n                    trafficVideoId,\n                    activeVersion,\n                    updatedSources,\n                    undefined,\n                    csvFile\n                );\n            }\n\n            if (onDataRestored && snapshotId) {\n                onDataRestored(updatedSources, snapshotId);\n            }\n\n        } catch (error) {\n            assistantLogger.error('Failed to restore/enrich traffic sources', {\n                error\n            });\n        } finally {\n            setIsRestoring(false);\n        }\n\n    }, [missingCount, unenrichedCount, apiKey, userId, channelId, trafficVideoId, activeVersion, displayedSources, onDataRestored, cachedVideos, currentSnapshotId]);\n\n    return {\n        missingCount,\n        unenrichedCount,\n        estimatedQuota,\n        fetchMissingTitles,\n        isRestoring\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useSmartNicheSuggestions.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'niches'. Either exclude it or remove the dependency array.","line":107,"column":8,"nodeType":"ArrayExpression","endLine":107,"endColumn":46,"suggestions":[{"desc":"Update the dependencies array to be: [sources, assignments, videos]","fix":{"range":[4420,4458],"text":"[sources, assignments, videos]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react';\nimport type { TrafficSource } from '../../../../../core/types/traffic';\nimport type { VideoDetails } from '../../../../../core/utils/youtubeApi';\nimport type { SuggestedTrafficNiche, TrafficNicheAssignment } from '../../../../../core/types/suggestedTrafficNiches';\nimport { assistantLogger } from '../../../../../core/utils/logger';\n\ninterface SmartSuggestion {\n    nicheId: string;\n    targetNiche: SuggestedTrafficNiche;\n    confidence: 'high' | 'medium' | 'low';\n    reason: 'hybrid';\n    score: number;\n}\n\nexport const useSmartNicheSuggestions = (\n    sources: TrafficSource[],\n    assignments: TrafficNicheAssignment[],\n    niches: SuggestedTrafficNiche[],\n    videos: VideoDetails[]\n) => {\n    // 1. Build a map of Preference for each Channel using Hybrid Logic\n    // Logic: Harmonic Decay Score = Sum(1 / (index + 1)) over sorted assignments\n    const channelPreferences = useMemo(() => {\n        const prefs = new Map<string, { nicheId: string; score: number }>();\n        const videoToChannel = new Map<string, string>();\n\n        // Map assignments to channels using RICH Video Details first (reliable), \n        // falling back to Source data if available.\n        videos.forEach(v => {\n            if (v.id && v.channelId) {\n                videoToChannel.set(v.id, v.channelId);\n            }\n        });\n\n        // Fallback to source data if needed (though usually less reliable for channelId)\n        sources.forEach(source => {\n            if (source.videoId && source.channelId) {\n                videoToChannel.set(source.videoId, source.channelId);\n            }\n        });\n\n        // Group assignments by Channel\n        const assignmentsByChannel = new Map<string, TrafficNicheAssignment[]>();\n\n        assignments.forEach(assignment => {\n            // We might not know the channel for EVERY video in history (if it's not in displayed sources),\n            // but for the Smart Assistant to be useful in the current table, we mostly care about\n            // channels that are currently visible or recently loaded. \n            // However, to be robust, we really need the channel ID for ALL assignments.\n            // If `assignments` store doesn't have channelId, we rely on the `sources` lookup.\n            // *Correction*: The user passed `allAssignments` from the store.\n            // The `TrafficNicheAssignment` type DOES NOT have channelId. It only has videoId, nicheId, addedAt.\n            // We can only learn from assignments where we know the Channel ID.\n\n            const channelId = videoToChannel.get(assignment.videoId);\n            if (channelId) {\n                const list = assignmentsByChannel.get(channelId) || [];\n                list.push(assignment);\n                assignmentsByChannel.set(channelId, list);\n            }\n        });\n\n        // Calculate Scores for each Channel\n        assignmentsByChannel.forEach((channelAssignments, channelId) => {\n            // Sort by Date Descending (Newest first)\n            channelAssignments.sort((a, b) => b.addedAt - a.addedAt);\n\n            const nicheScores = new Map<string, number>();\n\n            // Apply Harmonic Decay Scoring\n            channelAssignments.forEach((assignment, index) => {\n                // Score = 1 / (index + 1)\n                // 1st (Newest): 1.0\n                // 2nd: 0.5\n                // 3rd: 0.33\n                // ...\n                // This gives Recency a heavy initial weight, but allows Frequency to win if consistent.\n                const weight = 1 / (index + 1);\n\n                const currentScore = nicheScores.get(assignment.nicheId) || 0;\n                nicheScores.set(assignment.nicheId, currentScore + weight);\n            });\n\n            // Find the Winner\n            let bestNicheId = '';\n            let maxScore = -1;\n\n            nicheScores.forEach((score, nicheId) => {\n                if (score > maxScore) {\n                    maxScore = score;\n                    bestNicheId = nicheId;\n                }\n            });\n\n            if (bestNicheId) {\n                prefs.set(channelId, { nicheId: bestNicheId, score: maxScore });\n            }\n        });\n\n        assistantLogger.debug('Preference calculation', {\n            channelsMapped: assignmentsByChannel.size,\n            preferencesSize: prefs.size,\n            videoToChannelSize: videoToChannel.size\n        });\n\n        return prefs;\n    }, [sources, assignments, videos, niches]);\n\n    // 2. Build a Lookup Map for Video -> Suggestion (Optimization)\n    // This allows O(1) access during virtualization render cycles instead of searching arrays\n    const videoSuggestionMap = useMemo(() => {\n        const map = new Map<string, SmartSuggestion>();\n\n        // We need to map every known video ID to a suggestion if its channel has a preference\n        const processVideo = (videoId: string, channelId?: string) => {\n            if (!videoId || !channelId) return;\n\n            const pref = channelPreferences.get(channelId);\n            if (!pref) return;\n\n            const niche = niches.find(n => n.id === pref.nicheId);\n            if (!niche) return;\n\n            map.set(videoId, {\n                nicheId: pref.nicheId,\n                targetNiche: niche,\n                confidence: pref.score > 1.5 ? 'high' : 'medium',\n                reason: 'hybrid',\n                score: pref.score\n            });\n        };\n\n        // 1. Process Rich Video Details\n        videos.forEach(v => processVideo(v.id, v.channelId));\n\n        // 2. Process Sources (fallback for items not in details)\n        sources.forEach(s => {\n            // Only process if we haven't already (video details take precedence)\n            if (s.videoId && !map.has(s.videoId)) {\n                processVideo(s.videoId, s.channelId);\n            }\n        });\n\n        return map;\n    }, [channelPreferences, videos, sources, niches]);\n\n    // 3. Helper to get suggestion for a video (O(1) lookup)\n    const getSuggestion = (videoId: string): SmartSuggestion | null => {\n        return videoSuggestionMap.get(videoId) || null;\n    };\n\n    return {\n        getSuggestion,\n        channelPreferences\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useSmartTrafficAutoApply.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useSmartViewerTypeAutoApply.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useSuggestedVideos.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useTrafficData.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'showToast'. Either include it or remove the dependency array.","line":108,"column":8,"nodeType":"ArrayExpression","endLine":108,"endColumn":58,"suggestions":[{"desc":"Update the dependencies array to be: [userId, video.id, video.activeVersion, channelId, showToast]","fix":{"range":[4044,4094],"text":"[userId, video.id, video.activeVersion, channelId, showToast]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\nimport { TrafficService } from '../../../../../core/services/traffic';\nimport { useUIStore } from '../../../../../core/stores/uiStore';\nimport type { TrafficData, TrafficSource } from '../../../../../core/types/traffic';\nimport type { VideoDetails } from '../../../../../core/utils/youtubeApi';\n\ninterface UseTrafficDataProps {\n    userId: string;\n    channelId: string;\n    video: VideoDetails;\n}\n\n// Export the hook state interface for use in other components/hooks\nexport interface TrafficHookState {\n    trafficData: TrafficData | null;\n    isLoading: boolean;\n    isSaving: boolean;\n    error: string | null;\n    handleCsvUpload: (sources: TrafficSource[], totalRow?: TrafficSource, file?: File) => Promise<string | null>;\n    handleDeleteSnapshot: (snapshotId: string) => Promise<void>;\n    saveData: (newData: TrafficData) => Promise<void>;\n    updateLocalData: (newData: TrafficData) => void;\n    refetch: () => Promise<void>;\n}\n\nexport const useTrafficData = ({ userId, channelId, video }: UseTrafficDataProps): TrafficHookState => {\n    const [data, setData] = useState<TrafficData | null>(null);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState<string | null>(null);\n    const [isSaving, setIsSaving] = useState(false);\n    const { showToast } = useUIStore();\n\n    // Expose refresh function\n    const refetch = useCallback(async () => {\n        if (!userId || !channelId || !video.id) return;\n        setIsLoading(true);\n        try {\n            const fetched = await TrafficService.fetchTrafficData(userId, channelId, video.id);\n            setData(fetched);\n        } catch (err) {\n            console.error(\"Failed to load traffic data\", err);\n            setError(\"Failed to load traffic data\");\n        } finally {\n            setIsLoading(false);\n        }\n    }, [userId, channelId, video.id]);\n\n    // Fetch on mount\n    useEffect(() => {\n        refetch();\n    }, [refetch]);\n\n    // ... (rest of actions)\n\n\n\n    // Action: Save Data (General)\n    const saveData = useCallback(async (newData: TrafficData) => {\n        setIsSaving(true);\n        try {\n            await TrafficService.saveTrafficData(userId, channelId, video.id, newData);\n            setData(newData);\n        } catch (err) {\n            console.error(err);\n            setError(\"Failed to save changes\");\n        } finally {\n            setIsSaving(false);\n        }\n    }, [userId, channelId, video.id]);\n\n    // Action: Handle New CSV Upload\n    const handleCsvUpload = useCallback(async (sources: TrafficSource[], totalRow?: TrafficSource, file?: File) => {\n        if (!userId || !video.id) return null;\n        setIsSaving(true);\n        try {\n            const effectiveVersion = video.activeVersion === 'draft' ? 0 : (video.activeVersion || 1);\n\n            // 1. Create the snapshot (Hybrid Approach)\n            // This will also update the main traffic document's snapshots array\n            const newSnapshotId = await TrafficService.createVersionSnapshot(\n                userId,\n                channelId,\n                video.id,\n                effectiveVersion as number,\n                sources,\n                totalRow,\n                file\n            );\n\n            // 2. Refetch to get the updated sources and snapshots from Firestore\n            // This is now clean as createVersionSnapshot handles updating the main sources\n            const updatedData = await TrafficService.fetchTrafficData(userId, channelId, video.id);\n            if (updatedData) {\n                setData(updatedData);\n            }\n\n            return newSnapshotId;\n        } catch (err) {\n            console.error('[useTrafficData] CSV upload failed:', err);\n            setError(\"Failed to process CSV\");\n\n            // Premium UX: Show clear error message\n            showToast(\"Failed to process CSV file. Ensure the format is correct.\", \"error\");\n            return null;\n        } finally {\n            setIsSaving(false);\n        }\n    }, [userId, channelId, video.id, video.activeVersion]);\n\n    // Action: Delete Snapshot\n    const handleDeleteSnapshot = useCallback(async (snapshotId: string) => {\n        if (!userId || !video.id) return;\n        setIsSaving(true);\n        try {\n            const updated = await TrafficService.deleteSnapshot(userId, channelId, video.id, snapshotId);\n\n            if (updated) {\n                setData(updated);\n            } else {\n                // Fallback refetch if service didn't return data (shouldn't happen with updated service)\n                await refetch();\n            }\n\n        } catch (err) {\n            console.error('[useTrafficData] Snapshot deletion failed:', err);\n            setError(\"Failed to delete snapshot\");\n        } finally {\n            setIsSaving(false);\n        }\n    }, [userId, channelId, video.id, refetch]);\n\n    // Action: Update Local Data (Optimistic / External)\n    const updateLocalData = useCallback((newData: TrafficData) => {\n        setData(newData);\n    }, []);\n\n    return {\n        trafficData: data,\n        isLoading,\n        isSaving,\n        error,\n        handleCsvUpload,\n        handleDeleteSnapshot,\n        saveData,\n        updateLocalData, // New exposed method\n        refetch\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useTrafficDataLoader.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'trafficData.snapshots'. Either include it or remove the dependency array.","line":296,"column":8,"nodeType":"ArrayExpression","endLine":309,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [selectedSnapshot, viewingVersion, viewingPeriodIndex, viewMode, activeVersion, retryCount, trafficData?.lastUpdated, trafficData.snapshots?.length, trafficData.sources, trafficData.totalRow, packagingHistory, displayedSources.length, trafficData.snapshots]","fix":{"range":[14114,14453],"text":"[selectedSnapshot, viewingVersion, viewingPeriodIndex, viewMode, activeVersion, retryCount, trafficData?.lastUpdated, trafficData.snapshots?.length, trafficData.sources, trafficData.totalRow, packagingHistory, displayedSources.length, trafficData.snapshots]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport type { TrafficData, TrafficSource, TrafficSnapshot, TrafficGroup } from '../../../../../core/types/traffic';\nimport type { PackagingVersion, ActivePeriod } from '../../../../../core/types/versioning';\nimport { TrafficService } from '../../../../../core/services/traffic';\nimport { loadSnapshotSources } from '../utils/snapshotLoader';\nimport { logger } from '../../../../../core/utils/logger';\n\ninterface UseTrafficDataLoaderProps {\n    trafficData: TrafficData | null;\n    viewingVersion?: number | 'draft';\n    viewingPeriodIndex?: number;\n    activeVersion: number;\n    viewMode: 'cumulative' | 'delta';\n    selectedSnapshot?: string | null;\n    packagingHistory: PackagingVersion[];\n    groups?: TrafficGroup[];\n}\n\nexport interface TrashMetrics {\n    impressions: number;\n    views: number;\n}\n\nexport interface MetricDelta {\n    previous: number;\n    current: number;\n    delta: number;\n}\n\nexport interface DeltaContext {\n    impressions?: MetricDelta;\n    views?: MetricDelta;\n    isIncomplete?: boolean;\n}\n\n/**\n * Hook for loading and displaying traffic data.\n */\nexport const useTrafficDataLoader = ({\n    trafficData,\n    viewingVersion,\n    viewingPeriodIndex,\n    activeVersion,\n    viewMode,\n    selectedSnapshot,\n    packagingHistory = [],\n    groups = []\n}: UseTrafficDataLoaderProps) => {\n    const [displayedSources, setDisplayedSources] = useState<TrafficSource[]>([]);\n    const [actualTotalRow, setActualTotalRow] = useState<TrafficSource | undefined>(undefined);\n    const [trashMetrics, setTrashMetrics] = useState<TrashMetrics>({ impressions: 0, views: 0 });\n    const [isLoadingSnapshot, setIsLoadingSnapshot] = useState(false);\n    const [error, setError] = useState<Error | null>(null);\n    const [retryCount, setRetryCount] = useState(0);\n    const lastLoadedKeyRef = useRef<string | null>(null);\n    const lastLoadContextRef = useRef<{ snapshotId?: string | null; viewMode?: string, versionKey?: string } | null>(null);\n\n    // Context for Delta Mode (Previous -> Current)\n    const [deltaContext, setDeltaContext] = useState<DeltaContext | undefined>(undefined);\n\n    // Business Logic: Identify Trash videos - Memoized to prevent infinite loops\n    const trashGroup = useMemo(() => groups.find(g => g.name.trim().toLowerCase() === 'trash'), [groups]);\n    const trashVideoIds = useMemo(() => new Set(trashGroup?.videoIds || []), [trashGroup?.videoIds]);\n\n    const calculateTrashMetrics = useCallback((sources: TrafficSource[]): TrashMetrics => {\n        let trashImpressions = 0;\n        let trashViews = 0;\n\n        sources.forEach(s => {\n            if (s.videoId && trashVideoIds.has(s.videoId)) {\n                trashImpressions += (s.impressions || 0);\n                trashViews += (s.views || 0);\n            }\n        });\n\n        return { impressions: trashImpressions, views: trashViews };\n    }, [trashVideoIds]); // Now stable due to useMemo above\n\n    const retry = () => {\n        logger.info('User initiated retry for traffic data loading', { component: 'useTrafficDataLoader' });\n        setError(null);\n        lastLoadedKeyRef.current = null;\n        setActualTotalRow(undefined);\n        setRetryCount(prev => prev + 1);\n    };\n\n    useEffect(() => {\n        const loadData = async () => {\n            const loadKey = `${selectedSnapshot || ''}-${viewingVersion}-${viewingPeriodIndex}-${viewMode}-${trafficData?.lastUpdated}-${trafficData?.snapshots?.length}`;\n\n            if (loadKey === lastLoadedKeyRef.current && displayedSources.length > 0) {\n                // IMPORTANT: If groups changed but loadKey didn't (size same), we still might need to recalculate trashMetrics\n                // because calculateTrashMetrics depends on trashVideoIds closure.\n                // But usually size changes when assignments change for Trash.\n                return;\n            }\n\n            // Determine if this is a \"soft update\" (only trash metrics/context changed)\n            // or a \"hard update\" (snapshot switched, version switched, etc.)\n            const currentContext = {\n                snapshotId: selectedSnapshot,\n                viewMode,\n                versionKey: `${viewingVersion}-${viewingPeriodIndex}`\n            };\n\n            const isSoftUpdate = lastLoadContextRef.current &&\n                lastLoadContextRef.current.snapshotId === currentContext.snapshotId &&\n                lastLoadContextRef.current.viewMode === currentContext.viewMode &&\n                lastLoadContextRef.current.versionKey === currentContext.versionKey &&\n                displayedSources.length > 0;\n\n            setError(null);\n\n            if (!trafficData?.sources) {\n                setDisplayedSources([]);\n                setActualTotalRow(undefined);\n                setTrashMetrics({ impressions: 0, views: 0 });\n                return;\n            }\n\n            // Priority 1: Specific snapshot selected\n            if (selectedSnapshot) {\n                if (!isSoftUpdate) setIsLoadingSnapshot(true);\n                try {\n                    const snapshot = trafficData.snapshots?.find((s: TrafficSnapshot) => s.id === selectedSnapshot);\n                    if (snapshot) {\n                        const { sources: currentSources, totalRow: currentTotal } = await loadSnapshotSources(snapshot);\n\n                        if (viewMode === 'delta' && currentSources.length > 0) {\n                            const result = await calculateSnapshotDelta(\n                                currentSources,\n                                currentTotal,\n                                selectedSnapshot,\n                                trafficData.snapshots || []\n                            );\n\n                            // For Delta mode, trash metrics MUST be calculated from DELTA sources\n                            // setTrashMetrics removed here to avoid dependency loop\n                            setDisplayedSources(result.sources);\n                            setActualTotalRow(result.totalRow);\n                            setDeltaContext(result.deltaContext);\n                        } else {\n                            // Cumulative mode\n                            // setTrashMetrics removed here\n                            setDisplayedSources(currentSources);\n                            setActualTotalRow(currentTotal || trafficData.totalRow);\n                            setDeltaContext(undefined);\n                        }\n                        lastLoadedKeyRef.current = loadKey;\n                        lastLoadContextRef.current = currentContext;\n                    } else {\n                        setDisplayedSources([]);\n                        setActualTotalRow(undefined);\n                        setTrashMetrics({ impressions: 0, views: 0 });\n                        lastLoadedKeyRef.current = loadKey;\n                        lastLoadContextRef.current = currentContext;\n                    }\n                } catch (err) {\n                    logger.error('Failed to load snapshot', { component: 'useTrafficDataLoader', error: err, selectedSnapshot });\n                    setError(err instanceof Error ? err : new Error('Unknown error loading snapshot'));\n                    setDisplayedSources([]);\n                    setActualTotalRow(undefined);\n                } finally {\n                    if (!isSoftUpdate) setIsLoadingSnapshot(false);\n                }\n                return;\n            }\n\n            // Priority 2: Active version\n            if (viewingVersion === 'draft' || viewingVersion === activeVersion) {\n                const versionSnapshots = (trafficData.snapshots || []).filter(\n                    (s: TrafficSnapshot) => s.version === viewingVersion\n                );\n\n                if (versionSnapshots.length > 0) {\n                    if (!isSoftUpdate) setIsLoadingSnapshot(true);\n                    try {\n                        const versionData = packagingHistory.find(v => v.versionNumber === viewingVersion);\n                        let targetPeriodIndex = viewingPeriodIndex;\n\n                        if (targetPeriodIndex === undefined && versionData?.activePeriods) {\n                            const openPeriodIndex = versionData.activePeriods.findIndex((p: ActivePeriod) => !p.endDate);\n                            targetPeriodIndex = openPeriodIndex !== -1 ? openPeriodIndex : 0;\n                        }\n\n                        const finalIndex = targetPeriodIndex ?? 0;\n                        const period = versionData?.activePeriods?.[finalIndex];\n                        const periodStart = period?.startDate ?? Date.now();\n                        const periodEnd = (finalIndex === 0) ? null : period?.endDate;\n\n                        const periodSnapshots = versionSnapshots.filter(s =>\n                            s.timestamp >= periodStart && (!periodEnd || s.timestamp <= periodEnd)\n                        ).sort((a, b) => b.timestamp - a.timestamp);\n\n                        if (viewMode === 'delta' && periodSnapshots.length > 0) {\n                            const latestSnap = periodSnapshots[0];\n                            const { sources: currentSources, totalRow: currentTotal } = await loadSnapshotSources(latestSnap);\n\n                            const result = await calculateSnapshotDelta(\n                                currentSources,\n                                currentTotal,\n                                latestSnap.id,\n                                trafficData.snapshots || []\n                            );\n\n                            // setTrashMetrics removed here\n                            setDisplayedSources(result.sources);\n                            setActualTotalRow(result.totalRow);\n                            setDeltaContext(result.deltaContext);\n                        } else {\n                            const { sources, totalRow: currentTotal } = await TrafficService.getVersionSources(\n                                viewingVersion as number,\n                                trafficData.snapshots || [],\n                                periodStart,\n                                periodEnd\n                            );\n\n                            // setTrashMetrics removed here\n                            setDisplayedSources(sources);\n                            setActualTotalRow(currentTotal || trafficData.totalRow);\n                            setDeltaContext(undefined);\n                        }\n                        lastLoadedKeyRef.current = loadKey;\n                        lastLoadContextRef.current = currentContext;\n                    } catch (err) {\n                        logger.error('Failed to load active version sources', { component: 'useTrafficDataLoader', error: err, viewingVersion });\n                        setError(err instanceof Error ? err : new Error('Unknown error loading active version'));\n                        setDisplayedSources(trafficData.sources || []);\n                        setActualTotalRow(trafficData.totalRow);\n                    } finally {\n                        if (!isSoftUpdate) setIsLoadingSnapshot(false);\n                    }\n                    return;\n                }\n            }\n\n            // Priority 3: Historical Version\n            if (!isSoftUpdate) setIsLoadingSnapshot(true);\n            try {\n                const versionData = packagingHistory.find(v => v.versionNumber === viewingVersion);\n                const finalIndex = viewingPeriodIndex || 0;\n                const period = versionData?.activePeriods?.[finalIndex];\n                const periodStart = period?.startDate;\n                const periodEnd = (finalIndex === 0) ? null : period?.endDate;\n\n                const versionSnapshots = (trafficData.snapshots || []).filter(\n                    (s: TrafficSnapshot) => s.version === viewingVersion\n                );\n\n                const periodSnapshots = versionSnapshots.filter(s =>\n                    (periodStart === undefined || s.timestamp >= periodStart) &&\n                    (!periodEnd || s.timestamp <= periodEnd)\n                ).sort((a, b) => b.timestamp - a.timestamp);\n\n                if (viewMode === 'delta' && periodSnapshots.length > 0) {\n                    const latestSnap = periodSnapshots[0];\n                    const { sources: currentSources, totalRow: currentTotal } = await loadSnapshotSources(latestSnap);\n\n                    const result = await calculateSnapshotDelta(\n                        currentSources,\n                        currentTotal,\n                        latestSnap.id,\n                        trafficData.snapshots || []\n                    );\n\n                    // setTrashMetrics removed here\n                    setDisplayedSources(result.sources);\n                    setActualTotalRow(result.totalRow);\n                    setDeltaContext(result.deltaContext);\n                } else {\n                    const { sources, totalRow: currentTotal } = await TrafficService.getVersionSources(\n                        viewingVersion as number,\n                        trafficData.snapshots || [],\n                        periodStart,\n                        periodEnd\n                    );\n\n                    // setTrashMetrics removed here\n                    setDisplayedSources(sources);\n                    setActualTotalRow(currentTotal || trafficData.totalRow);\n                    setDeltaContext(undefined);\n                }\n                lastLoadedKeyRef.current = loadKey;\n                lastLoadContextRef.current = currentContext;\n            } catch (err) {\n                logger.error('Failed to load historical version sources', { component: 'useTrafficDataLoader', error: err, viewingVersion });\n                setError(err instanceof Error ? err : new Error('Unknown error loading historical version'));\n                setDisplayedSources([]);\n                setActualTotalRow(undefined);\n            } finally {\n                if (!isSoftUpdate) setIsLoadingSnapshot(false);\n            }\n        };\n\n        loadData();\n    }, [\n        selectedSnapshot,\n        viewingVersion,\n        viewingPeriodIndex,\n        viewMode,\n        activeVersion,\n        retryCount,\n        trafficData?.lastUpdated,\n        trafficData?.snapshots?.length,\n        trafficData?.sources,\n        trafficData?.totalRow,\n        packagingHistory,\n        displayedSources.length\n    ]);\n\n    // Separate Effect for Trash Metrics to prevent Loading Loop\n    useEffect(() => {\n        if (displayedSources.length > 0) {\n            const metrics = calculateTrashMetrics(displayedSources);\n            setTrashMetrics((prev) => {\n                if (prev.impressions === metrics.impressions && prev.views === metrics.views) return prev;\n                return metrics;\n            });\n        }\n    }, [displayedSources, calculateTrashMetrics]);\n\n    return { displayedSources, actualTotalRow, trashMetrics, isLoadingSnapshot, error, retry, deltaContext };\n};\n\n/**\n * Helper function to calculate delta between snapshots.\n */\nconst calculateSnapshotDelta = async (\n    currentSources: TrafficSource[],\n    currentTotal: TrafficSource | undefined,\n    currentSnapshotId: string,\n    snapshots: TrafficSnapshot[]\n): Promise<{ sources: TrafficSource[], totalRow?: TrafficSource, deltaContext?: DeltaContext }> => {\n    const sortedSnapshots = [...snapshots].sort((a, b) => a.timestamp - b.timestamp);\n    const currentIndex = sortedSnapshots.findIndex(s => s.id === currentSnapshotId);\n\n    if (currentIndex <= 0) {\n        return { sources: [], totalRow: undefined };\n    }\n\n    const prevSnapshot = sortedSnapshots[currentIndex - 1];\n    const { sources: prevSources, totalRow: prevTotal } = await loadSnapshotSources(prevSnapshot);\n\n    if (prevSources.length === 0) {\n        return { sources: [], totalRow: undefined };\n    }\n\n\n\n    const prevData = new Map<string, { views: number; impressions: number, watchTime: number }>();\n    prevSources.forEach(s => {\n        if (s.videoId) {\n            prevData.set(s.videoId, {\n                views: s.views || 0,\n                impressions: s.impressions || 0,\n                watchTime: s.watchTimeHours || 0\n            });\n        }\n    });\n\n    const sources = currentSources\n        .map(source => {\n            if (!source.videoId) return source;\n            const prev = prevData.get(source.videoId) || { views: 0, impressions: 0, watchTime: 0 };\n\n            const viewsDelta = Math.max(0, source.views - prev.views);\n            const impressionsDelta = Math.max(0, (source.impressions || 0) - prev.impressions);\n            const watchTimeDelta = Math.max(0, (source.watchTimeHours || 0) - prev.watchTime);\n\n            const ctrDelta = impressionsDelta > 0 ? (viewsDelta / impressionsDelta) * 100 : 0;\n\n            return {\n                ...source,\n                views: viewsDelta,\n                impressions: impressionsDelta,\n                watchTimeHours: watchTimeDelta,\n                ctr: parseFloat(ctrDelta.toFixed(2))\n            };\n        })\n        .filter(source => !source.videoId || source.views > 0 || source.impressions > 0);\n\n    let totalRow: TrafficSource | undefined = currentTotal;\n    let deltaContext: DeltaContext | undefined = undefined;\n\n    // Ensure we have both totals to calculate context\n    if (currentTotal && prevTotal) {\n        // Calculate Total Delta\n        const viewsDelta = Math.max(0, currentTotal.views - prevTotal.views);\n        const impressionsDelta = Math.max(0, (currentTotal.impressions || 0) - (prevTotal.impressions || 0));\n        const watchTimeDelta = Math.max(0, (currentTotal.watchTimeHours || 0) - (prevTotal.watchTimeHours || 0));\n        const ctrDelta = impressionsDelta > 0 ? (viewsDelta / impressionsDelta) * 100 : 0;\n\n        totalRow = {\n            ...currentTotal,\n            views: viewsDelta,\n            impressions: impressionsDelta,\n            watchTimeHours: watchTimeDelta,\n            ctr: parseFloat(ctrDelta.toFixed(2))\n        };\n\n        // Populate Delta Context for Tooltip\n        deltaContext = {\n            impressions: {\n                previous: prevTotal.impressions || 0,\n                current: currentTotal.impressions || 0,\n                delta: impressionsDelta\n            },\n            views: {\n                previous: prevTotal.views || 0,\n                current: currentTotal.views || 0,\n                delta: viewsDelta\n            }\n        };\n    } else {\n        // Explicitly signal that we cannot calculate context due to missing Total row\n        deltaContext = {\n            isIncomplete: true\n        };\n        logger.warn('Missing total row for delta context calculation', {\n            component: 'useTrafficDataLoader',\n            hasCurrentTotal: !!currentTotal,\n            hasPrevTotal: !!prevTotal\n        });\n    }\n\n    return { sources, totalRow, deltaContext };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useTrafficFilters.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'filters' logical expression could make the dependencies of useCallback Hook (at line 53) change on every render. To fix this, wrap the initialization of 'filters' in its own useMemo() Hook.","line":38,"column":11,"nodeType":"VariableDeclarator","endLine":38,"endColumn":55},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'filters' logical expression could make the dependencies of useCallback Hook (at line 61) change on every render. To fix this, wrap the initialization of 'filters' in its own useMemo() Hook.","line":38,"column":11,"nodeType":"VariableDeclarator","endLine":38,"endColumn":55},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'filters' logical expression could make the dependencies of useCallback Hook (at line 220) change on every render. To fix this, wrap the initialization of 'filters' in its own useMemo() Hook.","line":38,"column":11,"nodeType":"VariableDeclarator","endLine":38,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":187,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8416,8419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8416,8419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport type { TrafficSource, TrafficFilter, TrafficFilterType, EnrichedTrafficSource } from '../../../../../core/types/traffic';\nimport { durationToSeconds } from '../utils/formatters';\nimport { useTrafficFilterStore } from '../../../../../core/stores/trafficFilterStore';\n\n/**\n * BUSINESS LOGIC: Traffic Filters Hook\n * \n * This hook provides filter management for the Traffic tab with automatic persistence.\n * \n * KEY FEATURES:\n * 1. Context-Aware Persistence: Filters are saved per version/period/snapshot\n * 2. Automatic State Sync: Filters load automatically when context changes\n * 3. Single Filter Per Type: Adding a filter replaces any existing filter of the same type\n * \n * CONTEXT DETERMINATION:\n * - If viewing a snapshot: contextKey = `snapshot-${snapshotId}`\n * - If viewing a version period: contextKey = `version-${versionNumber}-period-${periodIndex}`\n * \n * This ensures that:\n * - Each snapshot maintains its own filter state\n * - Each version period maintains its own filter state\n * - Filters persist across page reloads and navigation\n * - Only explicit user actions (remove/clear) delete filters\n */\n\ninterface UseTrafficFiltersProps {\n    /**\n     * Current viewing context to determine which filters to load/save.\n     * Format: `snapshot-${id}` or `version-${v}-period-${p}`\n     */\n    contextKey: string;\n}\n\nexport const useTrafficFilters = ({ contextKey }: UseTrafficFiltersProps) => {\n    // Get store actions and current filters for this context\n    const { filtersByContext, setFilters: setStoreFilters, clearFilters: clearStoreFilters } = useTrafficFilterStore();\n    const filters = filtersByContext[contextKey] || [];\n\n    /**\n     * Add or update a filter for the current context.\n     * If a filter of the same type exists, it will be replaced.\n     */\n    const addFilter = useCallback((filter: Omit<TrafficFilter, 'id'>) => {\n        const id = `${filter.type}-${Date.now()}`;\n\n        // Remove existing filter of same type (single filter per type policy)\n        const others = filters.filter(f => f.type !== filter.type);\n        const newFilters = [...others, { ...filter, id }];\n\n        // Persist to store\n        setStoreFilters(contextKey, newFilters);\n    }, [contextKey, filters, setStoreFilters]);\n\n    /**\n     * Remove a specific filter by ID.\n     */\n    const removeFilter = useCallback((id: string) => {\n        const newFilters = filters.filter(f => f.id !== id);\n        setStoreFilters(contextKey, newFilters);\n    }, [contextKey, filters, setStoreFilters]);\n\n    /**\n     * Clear all filters for the current context.\n     */\n    const clearFilters = useCallback(() => {\n        clearStoreFilters(contextKey);\n    }, [contextKey, clearStoreFilters]);\n\n    /**\n     * Apply active filters to a list of traffic sources.\n     * Returns filtered array based on all active filter criteria.\n     * \n     * @param sources List of traffic sources to filter\n     * @param groups Optional list of groups (niches) needed for 'niche' filter\n     */\n    const applyFilters = useCallback((sources: TrafficSource[], groups?: import('../../../../../core/types/traffic').TrafficGroup[]) => {\n        if (filters.length === 0) return sources;\n\n        // Pre-compute VideoID -> Set<NicheID> map if Niche filter is active, for O(1) lookup\n        // Pre-compute VideoID -> Set<NicheID> map if Niche or NicheProperty filter is active\n        const nicheFilter = filters.find(f => f.type === 'niche');\n        const nichePropertyFilter = filters.find(f => f.type === 'nicheProperty');\n        let videoIdToGroupIds: Map<string, Set<string>> | undefined;\n\n        if ((nicheFilter || nichePropertyFilter) && groups) {\n            videoIdToGroupIds = new Map();\n            groups.forEach(g => {\n                g.videoIds.forEach(vid => {\n                    const set = videoIdToGroupIds!.get(vid) || new Set();\n                    set.add(g.id);\n                    videoIdToGroupIds!.set(vid, set);\n                });\n            });\n        }\n\n        return sources.filter(source => {\n            return filters.every(filter => {\n                // Special handling for independent Hide Zero filters\n                if (filter.type === 'hideZeroViews') {\n                    return (source.views || 0) > 0;\n                }\n                if (filter.type === 'hideZeroImpressions') {\n                    return (source.impressions || 0) > 0;\n                }\n\n                if (filter.type === 'niche') {\n                    // Logic: source.videoId must belong to one of the selected niches\n                    // UNASSIGNED handling: if 'UNASSIGNED' is selected, include sources with no videoId OR videoId not in any group.\n                    if (!groups || !videoIdToGroupIds || !Array.isArray(filter.value)) return true; // Can't filter without groups or value\n\n                    const selectedIds = filter.value as string[];\n                    const sourceVideoId = source.videoId;\n\n                    // Is source Unassigned?\n                    const isUnassigned = !sourceVideoId || !videoIdToGroupIds.has(sourceVideoId);\n\n                    // If source is unassigned and UNASSIGNED is selected -> keep\n                    if (isUnassigned && selectedIds.includes('UNASSIGNED')) return true;\n\n                    // If source is assigned, check if its group is selected\n                    if (!isUnassigned && sourceVideoId) {\n                        const sourceGroupIds = videoIdToGroupIds.get(sourceVideoId);\n                        if (sourceGroupIds) {\n                            // Does source belong to ANY selected group?\n                            for (const gid of sourceGroupIds) {\n                                if (selectedIds.includes(gid)) return true;\n                            }\n                        }\n                    }\n\n                    return false;\n                }\n\n                if (filter.type === 'trafficType' || filter.type === 'viewerType') {\n                    // Inject property check (Source is actually EnrichedTrafficSource)\n                    const enrichedSource = source as EnrichedTrafficSource;\n\n                    const actualType = filter.type === 'trafficType'\n                        ? enrichedSource.trafficType\n                        : enrichedSource.viewerType;\n\n                    const actualSource = filter.type === 'trafficType'\n                        ? enrichedSource.trafficSource\n                        : enrichedSource.viewerSource;\n\n                    const selectedValues = Array.isArray(filter.value) ? filter.value : [filter.value];\n\n                    // Split checking: \"Smart Assistant\" refers to SOURCE, others refer to TYPE\n                    const isSmartAssistantSelected = selectedValues.includes('smart_assistant');\n                    const selectedMainTypes = selectedValues.filter((v: string | number) => v !== 'smart_assistant');\n\n                    // 1. Check Source Match\n                    if (isSmartAssistantSelected && actualSource === 'smart_assistant') {\n                        return true;\n                    }\n\n                    // 2. Check Type Match\n                    if (selectedMainTypes.includes(actualType || 'unknown')) {\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                if (filter.type === 'nicheProperty') {\n                    if (!groups || !videoIdToGroupIds) return true; // Can't filter without context\n\n                    const selectedProperties = Array.isArray(filter.value) ? filter.value : [filter.value];\n                    const sourceVideoId = source.videoId;\n\n                    if (!sourceVideoId) return false;\n\n                    const sourceGroupIds = videoIdToGroupIds.get(sourceVideoId);\n                    if (!sourceGroupIds) return false; // Not in any niche -> no property property\n\n                    // Check if *any* of the assigned niches has one of the selected properties\n                    for (const gid of sourceGroupIds) {\n                        const group = groups.find(g => g.id === gid);\n                        if (group && group.property && selectedProperties.includes(group.property)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n\n                let itemValue: any = source[filter.type as keyof TrafficSource];\n\n                // Special handling for AVD (string \"HH:MM:SS\" -> seconds)\n                if (filter.type === 'avgViewDuration' && typeof itemValue === 'string') {\n                    itemValue = durationToSeconds(itemValue);\n                }\n\n                // Numeric comparisons\n                if (typeof filter.value === 'number') {\n                    const numValue = Number(itemValue);\n                    if (isNaN(numValue)) return false;\n\n                    switch (filter.operator) {\n                        case 'gt': return numValue > filter.value;\n                        case 'gte': return numValue >= filter.value;\n                        case 'lt': return numValue < filter.value;\n                        case 'lte': return numValue <= filter.value;\n                        case 'equals': return numValue === filter.value;\n                        default: return true;\n                    }\n                }\n\n                // Range comparisons (between)\n                if (Array.isArray(filter.value) && filter.operator === 'between') {\n                    const [min, max] = filter.value as [number, number];\n                    const numValue = Number(itemValue);\n                    if (isNaN(numValue)) return false;\n                    return numValue >= min && numValue <= max;\n                }\n\n                return true;\n            });\n        });\n    }, [filters]);\n\n    return {\n        filters,\n        addFilter,\n        removeFilter,\n        clearFilters,\n        applyFilters\n    };\n};\n\n// Re-export types for convenience\nexport type { TrafficFilter, TrafficFilterType };\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/hooks/useTrafficSelection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/modals/ColumnMapperModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/modals/DataRepairModal.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useEffect has missing dependencies: 'estimatedQuota' and 'missingCount'. Either include them or remove the dependency array. If 'setFrozenMissingCount' needs the current value of 'missingCount', you can also switch to useReducer instead of useState and read 'missingCount' in the reducer.","line":35,"column":8,"nodeType":"ArrayExpression","endLine":35,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [estimatedQuota, isOpen, missingCount]","fix":{"range":[1094,1102],"text":"[estimatedQuota, isOpen, missingCount]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { createPortal } from 'react-dom';\nimport { CloudDownload, X, Info } from 'lucide-react';\nimport { Button } from '../../../../../components/ui/atoms/Button/Button';\n\ninterface DataRepairModalProps {\n    isOpen: boolean;\n    missingCount: number;\n    estimatedQuota: number;\n    onConfirm: () => void;\n    onClose: () => void;\n    isRestoring: boolean;\n    variant?: 'sync' | 'assistant';\n}\n\nexport const DataRepairModal: React.FC<DataRepairModalProps> = ({\n    isOpen,\n    missingCount,\n    estimatedQuota,\n    onConfirm,\n    onClose,\n    isRestoring,\n    variant = 'sync'\n}) => {\n    // Frozen values to prevent UI jumping while syncing\n    const [frozenMissingCount, setFrozenMissingCount] = React.useState<number>(missingCount);\n    const [frozenEstimatedQuota, setFrozenEstimatedQuota] = React.useState<number>(estimatedQuota);\n\n    // Update frozen values ONLY when the modal is opened\n    React.useEffect(() => {\n        if (isOpen) {\n            setFrozenMissingCount(missingCount);\n            setFrozenEstimatedQuota(estimatedQuota);\n        }\n    }, [isOpen]); // We purposefully omit missingCount/estimatedQuota to only update on open\n\n    if (!isOpen) return null;\n\n    const isAssistant = variant === 'assistant';\n\n    return createPortal(\n        <div\n            className=\"fixed inset-0 z-[2000] flex items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in\"\n            onClick={onClose}\n        >\n            <div\n                className=\"bg-bg-secondary rounded-xl w-[500px] max-w-[90vw] flex flex-col overflow-hidden animate-scale-in border border-border shadow-2xl\"\n                onClick={e => e.stopPropagation()}\n            >\n                {/* Header */}\n                <div className=\"px-6 py-4 flex items-center justify-between border-b border-border\">\n                    <h2 className=\"text-xl font-bold text-text-primary m-0\">\n                        {isAssistant ? 'Smart Assistant Needs Data' : 'Update missing data'}\n                    </h2>\n                    {!isRestoring && (\n                        <button\n                            onClick={onClose}\n                            className=\"bg-transparent border-none text-text-primary cursor-pointer hover:opacity-70 transition-opacity\"\n                        >\n                            <X size={24} />\n                        </button>\n                    )}\n                </div>\n\n                {/* Content */}\n                <div className=\"p-6 flex flex-col gap-6\">\n                    <div className=\"px-1\">\n                        <p className=\"text-sm text-text-secondary leading-relaxed\">\n                            {isAssistant ? (\n                                <>\n                                    Smart Assistant works best with rich data (channel's info for each video). <span className=\"font-semibold text-text-primary\">{frozenMissingCount} videos</span> are missing these and other details.\n                                    <br /><br />\n                                    Sync with YouTube to enable intelligent niche prediction.\n                                </>\n                            ) : (\n                                <>\n                                    This snapshot contains <span className=\"font-semibold text-text-primary\">{frozenMissingCount} videos</span> without titles.\n                                    Syncing with YouTube will enable full insights and detailed tooltips.\n                                </>\n                            )}\n                        </p>\n                    </div>\n\n                    {/* Usage Info - Yellow Box */}\n                    <div className=\"flex items-center gap-3 px-4 py-3 bg-yellow-500/10 rounded-lg\">\n                        <div className=\"w-8 h-8 rounded-full bg-yellow-500/10 flex items-center justify-center shrink-0\">\n                            <Info size={16} className=\"text-yellow-500\" />\n                        </div>\n                        <div className=\"flex-1\">\n                            <p className=\"text-[10px] text-yellow-600/80 dark:text-yellow-500/80 uppercase tracking-widest font-bold mb-0.5\">ESTIMATED USAGE OF YT API QUOTA</p>\n                            <p className=\"text-sm text-text-primary font-medium\">\n                                {frozenEstimatedQuota} <span className=\"text-text-secondary font-normal\">of 10,000 daily units</span>\n                            </p>\n                        </div>\n                    </div>\n\n                    {/* Consequence text */}\n                    <div className=\"px-1\">\n                        <p className=\"text-sm text-text-secondary leading-relaxed\">\n                            {isAssistant\n                                ? \"If you skip sync, Smart Assistant won't be able to make niche suggestions for these videos.\"\n                                : \"If you skip sync, these videos will have empty titles in the table.\"\n                            }\n                        </p>\n                    </div>\n                </div>\n\n                {/* Footer */}\n                <div className=\"px-6 py-4 flex items-center justify-end gap-3 border-t border-border bg-bg-secondary/30\">\n                    <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={onClose}\n                        disabled={isRestoring}\n                        className=\"text-text-secondary hover:text-text-primary\"\n                    >\n                        Skip\n                    </Button>\n                    <Button\n                        variant=\"primary\"\n                        size=\"sm\"\n                        onClick={onConfirm}\n                        isLoading={isRestoring}\n                        leftIcon={<CloudDownload size={16} />}\n                    >\n                        {isRestoring ? 'Updating...' : 'Sync'}\n                    </Button>\n                </div>\n            </div>\n        </div>,\n        document.body\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/modals/SnapshotRequestModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/modals/VersionFreezeModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/utils/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/utils/csvGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/utils/csvParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/utils/dateUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/utils/formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/tabs/Traffic/utils/snapshotLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/DetailsPage/types/versionManagement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/LoginPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Header/FilterInputNiche.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useLayoutEffect has a missing dependency: 'fixedWidth'. Either include it or remove the dependency array.","line":40,"column":8,"nodeType":"ArrayExpression","endLine":40,"endColumn":10,"suggestions":[{"desc":"Update the dependencies array to be: [fixedWidth]","fix":{"range":[1497,1499],"text":"[fixedWidth]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useLayoutEffect, useRef, useState } from 'react';\nimport { Check, Globe, Home, Search, CheckCheck, CircleOff } from 'lucide-react';\nimport { useTrendStore } from '../../../core/stores/trendStore';\n\n// Special ID for \"Unassigned\" filter option\nexport const UNASSIGNED_NICHE_ID = 'UNASSIGNED';\n\ninterface FilterInputNicheProps {\n    initialSelected: string[];\n    onApply: (selectedIds: string[]) => void;\n}\n\nconst formatViewCount = (num?: number) => {\n    if (!num) return '0';\n    return new Intl.NumberFormat('en-US', {\n        notation: \"compact\",\n        maximumFractionDigits: 1\n    }).format(num);\n};\n\nexport const FilterInputNiche: React.FC<FilterInputNicheProps> = ({\n    initialSelected,\n    onApply\n}) => {\n    const { niches, videos, videoNicheAssignments, selectedChannelId } = useTrendStore();\n    const [selectedIds, setSelectedIds] = useState<string[]>(initialSelected);\n    const [searchQuery, setSearchQuery] = useState('');\n\n    // Width fixing\n    const containerRef = useRef<HTMLDivElement>(null);\n    const [fixedWidth, setFixedWidth] = useState<number | undefined>(undefined);\n\n    useLayoutEffect(() => {\n        if (containerRef.current && !fixedWidth) {\n            // Measure the natural width with all content initially rendered\n            // We use getBoundingClientRect to be precise, or offsetWidth.\n            // We want to lock this width so it doesn't shrink.\n            setFixedWidth(containerRef.current.offsetWidth);\n        }\n    }, []); // Run once on mount\n\n    const toggleNiche = (id: string) => {\n        const newSelection = selectedIds.includes(id)\n            ? selectedIds.filter(s => s !== id)\n            : [...selectedIds, id];\n\n        setSelectedIds(newSelection);\n        onApply(newSelection);\n    };\n\n    // Filter niches by channel: global + local matching current channel\n    const channelFilteredNiches = useMemo(() => {\n        return niches.filter(niche => {\n            // Global niches are always available\n            if (niche.type === 'global') return true;\n\n            // Local niches are available if they match the selected channel\n            if (niche.type === 'local' && niche.channelId && selectedChannelId) {\n                return niche.channelId === selectedChannelId;\n            }\n\n            // If no channel selected (main trends), show all local niches\n            if (!selectedChannelId && niche.type === 'local') return true;\n\n            return false;\n        });\n    }, [niches, selectedChannelId]);\n\n    // 1. Calculate View Counts dynamically\n    const nicheViewCounts = useMemo(() => {\n        const counts = new Map<string, number>();\n        videos.forEach(v => {\n            const assignments = videoNicheAssignments[v.id] || [];\n            const nicheIds = assignments.length > 0\n                ? assignments.map(a => a.nicheId)\n                : (v.nicheId ? [v.nicheId] : []);\n\n            nicheIds.forEach(nicheId => {\n                counts.set(nicheId, (counts.get(nicheId) || 0) + v.viewCount);\n            });\n        });\n        return counts;\n    }, [videos, videoNicheAssignments]);\n\n    // Calculate unassigned video count (videos with no niche)\n    const unassignedViewCount = useMemo(() => {\n        let count = 0;\n        videos.forEach(v => {\n            const assignments = videoNicheAssignments[v.id] || [];\n            if (assignments.length === 0 && !v.nicheId) {\n                count += v.viewCount;\n            }\n        });\n        return count;\n    }, [videos, videoNicheAssignments]);\n\n    // 2. Sort niches: View Count (desc), then Name (asc)\n    const sortedNiches = useMemo(() => {\n        return [...channelFilteredNiches].sort((a, b) => {\n            const countA = nicheViewCounts.get(a.id) || 0;\n            const countB = nicheViewCounts.get(b.id) || 0;\n            if (countA !== countB) return countB - countA;\n            return a.name.localeCompare(b.name);\n        });\n    }, [channelFilteredNiches, nicheViewCounts]);\n\n    // 3. Filter by search query\n    const filteredNiches = useMemo(() => {\n        if (!searchQuery.trim()) return sortedNiches;\n        const lowerQuery = searchQuery.toLowerCase();\n        return sortedNiches.filter(n => n.name.toLowerCase().includes(lowerQuery));\n    }, [sortedNiches, searchQuery]);\n\n    // Check if \"Unassigned\" matches search query\n    const showUnassigned = useMemo(() => {\n        if (!searchQuery.trim()) return true;\n        return 'unassigned'.includes(searchQuery.toLowerCase());\n    }, [searchQuery]);\n\n    const handleSelectAll = () => {\n        // Select all CURRENTLY VISIBLE (filtered) niches\n        // If some are already selected, we just add the missing ones.\n        // If ALL visible are already selected, maybe deselect them? \n        // User asked for \"select all icon\", let's assume additive or toggle all visible.\n        // \"Select all visible niches\".\n\n        const visibleIds = filteredNiches.map(n => n.id);\n        const allVisibleSelected = visibleIds.every(id => selectedIds.includes(id));\n\n        let newSelection: string[];\n        if (allVisibleSelected) {\n            // Deselect visible\n            newSelection = selectedIds.filter(id => !visibleIds.includes(id));\n        } else {\n            // Select all visible (merge unique)\n            newSelection = Array.from(new Set([...selectedIds, ...visibleIds]));\n        }\n\n        setSelectedIds(newSelection);\n        onApply(newSelection);\n    };\n\n    return (\n        <div\n            ref={containerRef}\n            className=\"flex flex-col max-h-[300px] transition-[width]\"\n            style={{ width: fixedWidth ? `${fixedWidth}px` : 'auto', minWidth: '200px' }}\n        >\n            {/* Search Input Header */}\n            <div className=\"px-3 py-2 border-b border-border sticky top-0 bg-[#1F1F1F] z-10 flex items-center gap-2\">\n                <div className=\"relative flex-1\">\n                    <Search size={14} className=\"absolute left-2 top-1/2 -translate-y-1/2 text-text-tertiary\" />\n                    <input\n                        type=\"text\"\n                        value={searchQuery}\n                        onChange={(e) => setSearchQuery(e.target.value)}\n                        placeholder=\"Search niches...\"\n                        className=\"w-full bg-bg-secondary border border-transparent focus:border-border rounded-md py-1.5 pl-8 pr-3 text-xs text-text-primary placeholder-text-tertiary outline-none transition-colors\"\n                        autoFocus\n                    />\n                </div>\n                {/* Select All Icon */}\n                <button\n                    onClick={handleSelectAll}\n                    className=\"p-1.5 text-text-tertiary hover:text-text-primary hover:bg-white/5 rounded transition-colors\"\n                    title=\"Select all visible\"\n                >\n                    <CheckCheck size={16} />\n                </button>\n            </div>\n\n            <div className=\"overflow-y-auto flex-1 p-1\">\n                {/* Unassigned option */}\n                {showUnassigned && (\n                    <div\n                        onClick={() => toggleNiche(UNASSIGNED_NICHE_ID)}\n                        className=\"px-3 py-2 flex items-center gap-3 cursor-pointer transition-colors rounded-lg text-text-primary text-sm hover:bg-hover-bg group border-b border-white/20 mb-1\"\n                    >\n                        {/* Checkbox */}\n                        <div\n                            className={`w-[16px] h-[16px] rounded border flex items-center justify-center flex-shrink-0 transition-colors ${selectedIds.includes(UNASSIGNED_NICHE_ID)\n                                ? 'bg-text-primary border-text-primary'\n                                : 'bg-transparent border-text-secondary group-hover:border-text-primary'\n                                }`}\n                        >\n                            {selectedIds.includes(UNASSIGNED_NICHE_ID) && <Check size={10} className=\"text-bg-primary\" strokeWidth={3} />}\n                        </div>\n\n                        {/* Icon */}\n                        <CircleOff size={12} className=\"text-text-tertiary flex-shrink-0\" />\n\n                        {/* Name */}\n                        <span className=\"flex-1 overflow-hidden text-ellipsis whitespace-nowrap text-xs\">\n                            Unassigned\n                        </span>\n\n                        {/* View Count */}\n                        <span className=\"text-[10px] text-text-tertiary font-medium opacity-60\">\n                            {formatViewCount(unassignedViewCount)}\n                        </span>\n                    </div>\n                )}\n\n                {filteredNiches.length === 0 && !showUnassigned ? (\n                    <div className=\"px-4 py-8 text-center text-text-tertiary text-xs\">\n                        No niches found\n                    </div>\n                ) : (\n                    filteredNiches.map(niche => {\n                        const isSelected = selectedIds.includes(niche.id);\n                        const viewCount = nicheViewCounts.get(niche.id) || 0;\n                        const formattedViews = formatViewCount(viewCount);\n\n                        return (\n                            <div\n                                key={niche.id}\n                                onClick={() => toggleNiche(niche.id)}\n                                className=\"px-3 py-2 flex items-center gap-3 cursor-pointer transition-colors rounded-lg text-text-primary text-sm hover:bg-hover-bg group\"\n                            >\n                                {/* Checkbox */}\n                                <div\n                                    className={`w-[16px] h-[16px] rounded border flex items-center justify-center flex-shrink-0 transition-colors ${isSelected\n                                        ? 'bg-text-primary border-text-primary'\n                                        : 'bg-transparent border-text-secondary group-hover:border-text-primary'\n                                        }`}\n                                >\n                                    {isSelected && <Check size={10} className=\"text-bg-primary\" strokeWidth={3} />}\n                                </div>\n\n                                {/* Color dot */}\n                                <div\n                                    className=\"w-2.5 h-2.5 rounded-full flex-shrink-0\"\n                                    style={{ backgroundColor: niche.color }}\n                                />\n\n                                {/* Name */}\n                                <span className=\"flex-1 overflow-hidden text-ellipsis whitespace-nowrap text-xs\">\n                                    {niche.name}\n                                </span>\n\n                                {/* View Count */}\n                                <span className=\"text-[10px] text-text-tertiary font-medium opacity-60\">\n                                    {formattedViews}\n                                </span>\n\n                                {/* Globe/Home Icon */}\n                                {niche.type === 'global' ? (\n                                    <Globe size={12} className=\"text-text-tertiary flex-shrink-0 opacity-60\" />\n                                ) : (\n                                    <Home size={12} className=\"text-text-tertiary flex-shrink-0 opacity-60\" />\n                                )}\n                            </div>\n                        );\n                    })\n                )}\n            </div>\n\n            <div className=\"p-2 border-t border-border flex justify-between items-center text-[10px] text-text-tertiary\">\n                <span>{selectedIds.length} selected</span>\n                {selectedIds.length > 1 && (\n                    <button\n                        onClick={() => {\n                            setSelectedIds([]);\n                            onApply([]);\n                        }}\n                        className=\"text-text-primary hover:underline hover:text-red-400 transition-colors\"\n                    >\n                        Clear selection\n                    </button>\n                )}\n            </div>\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Header/ScalingTooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Header/TrendsFilterButton.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3274,3277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3274,3277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3471,3474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3471,3474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\nimport { Filter, ChevronRight, X, Calendar, Eye, ChevronLeft, BarChart3, Layers } from 'lucide-react';\nimport { createPortal } from 'react-dom';\nimport { useTrendStore, type PercentileGroup } from '../../../core/stores/trendStore';\nimport { FilterInputDate } from '../../../components/Shared/FilterInputs/FilterInputDate';\nimport { FilterInputNumeric } from '../../../components/Shared/FilterInputs/FilterInputNumeric';\nimport { FilterInputPercentile } from '../../../components/Shared/FilterInputs/FilterInputPercentile';\nimport type { FilterOperator } from '../../../core/stores/filterStore';\nimport { FilterInputNiche } from './FilterInputNiche';\n\ntype TrendsFilterType = 'date' | 'views' | 'percentile' | 'niche';\n\ninterface TrendsFilterButtonProps {\n    availableMinDate?: number;\n    availableMaxDate?: number;\n}\n\nexport const TrendsFilterButton: React.FC<TrendsFilterButtonProps> = ({ availableMinDate, availableMaxDate }) => {\n    const [isOpen, setIsOpen] = useState(false);\n    const buttonRef = useRef<HTMLButtonElement>(null);\n    const dropdownRef = useRef<HTMLDivElement>(null);\n    const [position, setPosition] = useState<{ top: number; right: number } | null>(null);\n\n    // State for Navigation (Main vs Submenu)\n    const [activeView, setActiveView] = useState<TrendsFilterType | 'main'>('main');\n\n    const { addTrendsFilter, removeTrendsFilter, trendsFilters, filterMode, setFilterMode, niches } = useTrendStore();\n\n    // Check if \"Untracked\" (TRASH) niche is active\n    const isTrashMode = React.useMemo(() => {\n        const nicheFilter = trendsFilters.find(f => f.type === 'niche');\n        return nicheFilter && Array.isArray(nicheFilter.value) && nicheFilter.value.includes('TRASH');\n    }, [trendsFilters]);\n\n    useEffect(() => {\n        if (isOpen && buttonRef.current) {\n            const rect = buttonRef.current.getBoundingClientRect();\n            setPosition({\n                top: rect.bottom + 8,\n                right: window.innerWidth - rect.right\n            });\n        } else {\n            // Reset view when closed\n            const timeout = setTimeout(() => setActiveView('main'), 200);\n            return () => clearTimeout(timeout);\n        }\n    }, [isOpen]);\n\n    useEffect(() => {\n        const handleClickOutside = (event: MouseEvent) => {\n            const target = event.target as Element;\n            if (target.closest('#custom-select-dropdown')) {\n                return;\n            }\n\n            if (\n                dropdownRef.current &&\n                !dropdownRef.current.contains(event.target as Node) &&\n                buttonRef.current &&\n                !buttonRef.current.contains(event.target as Node)\n            ) {\n                setIsOpen(false);\n            }\n        };\n\n        if (isOpen) {\n            document.addEventListener('mousedown', handleClickOutside);\n            window.addEventListener('resize', () => setIsOpen(false));\n        }\n\n        return () => {\n            document.removeEventListener('mousedown', handleClickOutside);\n            window.removeEventListener('resize', () => setIsOpen(false));\n        };\n    }, [isOpen]);\n\n    const handleAddFilter = (type: TrendsFilterType, operator: FilterOperator, value: any, label: string) => {\n        addTrendsFilter({ type, operator, value, label });\n        setIsOpen(false);\n    };\n\n    const filterTypes: { type: TrendsFilterType; label: string; icon: React.FC<any> }[] = [\n        { type: 'date', label: 'Publish Date', icon: Calendar },\n        { type: 'views', label: 'Views', icon: Eye },\n        { type: 'percentile', label: 'Percentile', icon: BarChart3 },\n        { type: 'niche', label: 'Niche', icon: Layers },\n    ];\n\n    const getTitleForView = (view: TrendsFilterType) => {\n        const match = filterTypes.find(t => t.type === view);\n        return match ? match.label : 'Filter';\n    };\n\n    return (\n        <>\n            <button\n                ref={buttonRef}\n                className={`w-[34px] h-[34px] rounded-full flex items-center justify-center transition-colors border-none cursor-pointer relative flex-shrink-0 ${isOpen ? 'bg-text-primary text-bg-primary' : 'bg-transparent text-text-primary hover:bg-hover-bg'}`}\n                onClick={() => setIsOpen(!isOpen)}\n                title=\"Filter\"\n            >\n                <Filter size={20} />\n                {trendsFilters.length > 0 && (\n                    <span className=\"absolute top-0 right-0 w-3 h-3 bg-red-500 rounded-full border-2 border-bg-primary\" />\n                )}\n            </button>\n\n            {isOpen && position && createPortal(\n                <div\n                    ref={dropdownRef}\n                    className=\"fixed z-[1000] bg-[#1F1F1F] rounded-xl shadow-2xl overflow-hidden animate-scale-in flex flex-col\"\n                    style={{\n                        top: position.top,\n                        right: position.right,\n                        width: activeView === 'date' ? '288px' : 'auto'\n                    }}\n                >\n                    {/* Header for Submenus */}\n                    {activeView !== 'main' && (\n                        <div className=\"flex items-center justify-between px-2 py-2 border-b border-[#333333]\">\n                            <button\n                                onClick={() => setActiveView('main')}\n                                className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                                <ChevronLeft size={20} />\n                            </button>\n                            <span className=\"text-sm font-bold text-text-primary\">{getTitleForView(activeView)}</span>\n                            <button\n                                onClick={() => setIsOpen(false)}\n                                className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                                <X size={20} />\n                            </button>\n                        </div>\n                    )}\n\n                    {/* Content Area */}\n                    <div className=\"flex flex-col\">\n                        {activeView === 'main' ? (\n                            <div className=\"py-2\">\n                                <div className=\"px-4 py-3 mb-1 border-b border-[#2a2a2a]\">\n                                    <div className=\"flex items-center justify-between mb-2\">\n                                        <span className=\"text-[11px] font-medium text-text-tertiary uppercase tracking-wider\">Context</span>\n                                    </div>\n                                    {/* Segmented Toggle - Disabled in Trash Mode */}\n                                    <div className={`relative flex bg-[#1a1a1a] rounded-lg p-0.5 ${isTrashMode ? 'opacity-50 cursor-not-allowed' : ''}`}>\n                                        {/* Sliding Indicator */}\n                                        <div\n                                            className=\"absolute top-0.5 bottom-0.5 w-[calc(50%-2px)] bg-gradient-to-r from-[#2d2d2d] to-[#333333] rounded-md shadow-sm transition-all duration-200 ease-out\"\n                                            style={{ left: filterMode === 'global' ? '2px' : 'calc(50% + 0px)' }}\n                                        />\n                                        <button\n                                            onClick={() => !isTrashMode && setFilterMode('global')}\n                                            disabled={!!isTrashMode}\n                                            className={`relative z-10 flex-1 flex items-center justify-center gap-1.5 py-1.5 px-3 rounded-md text-xs font-medium transition-colors duration-200 border-none bg-transparent ${isTrashMode ? 'cursor-not-allowed' : 'cursor-pointer'} ${filterMode === 'global'\n                                                ? 'text-text-primary'\n                                                : 'text-text-tertiary hover:text-text-secondary'\n                                                }`}\n                                        >\n                                            Global\n                                        </button>\n                                        <button\n                                            onClick={() => !isTrashMode && setFilterMode('filtered')}\n                                            disabled={!!isTrashMode}\n                                            className={`relative z-10 flex-1 flex items-center justify-center gap-1.5 py-1.5 px-3 rounded-md text-xs font-medium transition-colors duration-200 border-none bg-transparent ${isTrashMode ? 'cursor-not-allowed' : 'cursor-pointer'} ${filterMode === 'filtered'\n                                                ? 'text-text-primary'\n                                                : 'text-text-tertiary hover:text-text-secondary'\n                                                }`}\n                                        >\n                                            Filtered\n                                        </button>\n                                    </div>\n                                    <div className=\"mt-2 text-[10px] text-text-tertiary leading-relaxed grid\">\n                                        <span className={`col-start-1 row-start-1 transition-opacity duration-150 ${filterMode === 'global' ? 'opacity-100' : 'opacity-0'}`}>\n                                            Maintain original scale when filtering\n                                        </span>\n                                        <span className={`col-start-1 row-start-1 transition-opacity duration-150 ${filterMode === 'filtered' ? 'opacity-100' : 'opacity-0'}`}>\n                                            Rescale to fit visible data\n                                        </span>\n                                    </div>\n                                </div>\n\n                                {filterTypes.map(({ type, label, icon: Icon }) => (\n                                    <button\n                                        key={type}\n                                        onClick={() => setActiveView(type)}\n                                        className=\"w-full text-left px-4 py-3 text-sm font-medium flex items-center justify-between gap-8 transition-colors border-none cursor-pointer text-text-primary hover:bg-[#161616] bg-transparent\"\n                                    >\n                                        <div className=\"flex items-center gap-3\">\n                                            <Icon size={18} className=\"text-text-secondary\" />\n                                            {label}\n                                        </div>\n                                        <ChevronRight size={16} className=\"text-text-secondary\" />\n                                    </button>\n                                ))}\n                            </div>\n                        ) : (\n                            <div className=\"animate-fade-in\">\n                                {activeView === 'views' && (() => {\n                                    const existingFilter = trendsFilters.find(f => f.type === 'views');\n                                    const initialVal = existingFilter?.value;\n                                    const isRange = Array.isArray(initialVal);\n\n                                    return (\n                                        <FilterInputNumeric\n                                            initialOperator={existingFilter?.operator || 'gte'}\n                                            initialValue={isRange ? initialVal[0] : initialVal}\n                                            initialMaxValue={isRange ? initialVal[1] : undefined}\n                                            onApply={(op, val, max) => {\n                                                // Check for removal (empty/invalid) - though FilterInputNumeric handles validation, \n                                                // we might want to allow explicit clearing if value is empty?\n                                                // Actually FilterInputNumeric controls validation.\n                                                // Let's modify FilterInputNumeric to allow passing undefined to signal removal?\n                                                // Start with simple add/replace.\n\n                                                // Remove existing first\n                                                if (existingFilter) {\n                                                    removeTrendsFilter(existingFilter.id);\n                                                }\n\n                                                // If we have valid value (FilterInputNumeric enforces valid numbers before calling onApply), add it.\n                                                // Wait, we need a way to clear. \n                                                // Let's rely on FilterInputNumeric sending us data.\n\n                                                const opLabel = op === 'between' ? `${val}-${max}` : `${op === 'gte' ? '>=' : op === 'lte' ? '<=' : op === 'gt' ? '>' : op === 'lt' ? '<' : '='} ${val}`;\n                                                handleAddFilter('views', op, op === 'between' ? [val, max] : val, `Views ${opLabel}`);\n                                            }}\n                                            onRemove={() => {\n                                                if (existingFilter) {\n                                                    removeTrendsFilter(existingFilter.id);\n                                                    setIsOpen(false);\n                                                }\n                                            }}\n                                        />\n                                    );\n                                })()}\n                                {activeView === 'date' && (() => {\n                                    const existingFilter = trendsFilters.find(f => f.type === 'date');\n                                    const initialVal = existingFilter?.value; // [start, end]\n\n                                    return (\n                                        <FilterInputDate\n                                            availableMinDate={availableMinDate}\n                                            availableMaxDate={availableMaxDate}\n                                            initialStartDate={initialVal ? initialVal[0] : undefined}\n                                            initialEndDate={initialVal ? initialVal[1] : undefined}\n                                            onApply={(start, end) => {\n                                                if (existingFilter) {\n                                                    removeTrendsFilter(existingFilter.id);\n                                                }\n                                                const startStr = new Date(start).toLocaleDateString();\n                                                const endStr = new Date(end).toLocaleDateString();\n                                                const label = start === end ? `Date: ${startStr}` : `Date: ${startStr} - ${endStr}`;\n                                                handleAddFilter('date', 'between', [start, end], label);\n                                            }}\n                                            onRemove={() => {\n                                                if (existingFilter) {\n                                                    removeTrendsFilter(existingFilter.id);\n                                                    setIsOpen(false);\n                                                }\n                                            }}\n                                            onClose={() => setIsOpen(false)}\n                                        />\n                                    );\n                                })()}\n                                {activeView === 'percentile' && (\n                                    <FilterInputPercentile\n                                        initialExcluded={trendsFilters.find(f => f.type === 'percentile')?.value || []}\n                                        onApply={(excluded: PercentileGroup[]) => {\n                                            // Remove existing percentile filter first\n                                            const existingFilter = trendsFilters.find(f => f.type === 'percentile');\n                                            if (existingFilter) {\n                                                removeTrendsFilter(existingFilter.id);\n                                            }\n                                            // Add new filter with updated exclusions (if any)\n                                            if (excluded.length > 0) {\n                                                const label = excluded.length === 1\n                                                    ? `Hide: ${excluded[0]}`\n                                                    : `Hide: ${excluded.length} groups`;\n                                                addTrendsFilter({ type: 'percentile', operator: 'equals', value: excluded, label });\n                                            }\n                                            setIsOpen(false);\n                                        }}\n                                    />\n                                )}\n                                {activeView === 'niche' && (\n                                    <FilterInputNiche\n                                        initialSelected={trendsFilters.find(f => f.type === 'niche')?.value || []}\n                                        onApply={(selectedIds) => {\n                                            const existingFilter = trendsFilters.find(f => f.type === 'niche');\n                                            if (existingFilter) {\n                                                removeTrendsFilter(existingFilter.id);\n                                            }\n                                            if (selectedIds.length > 0) {\n                                                // Format label - include Unassigned if selected\n                                                const nicheNames = niches\n                                                    .filter(n => selectedIds.includes(n.id))\n                                                    .map(n => n.name);\n\n                                                const hasUnassigned = selectedIds.includes('UNASSIGNED');\n                                                const names = hasUnassigned\n                                                    ? [...nicheNames, 'Unassigned']\n                                                    : nicheNames;\n\n                                                const label = names.length === 1\n                                                    ? `Niche: ${names[0]}`\n                                                    : `Niche: ${names.length} selected`; // Simple label\n\n                                                addTrendsFilter({\n                                                    type: 'niche',\n                                                    operator: 'contains', // Logic is \"Video niches CONTAINS one of selectedIds\" effectively\n                                                    value: selectedIds,\n                                                    label\n                                                });\n                                            }\n                                            // If selectedIds is empty, we effectively removed the filter above.\n                                            // We usually close the dropdown if we applied something?\n                                            // But for multi-select (niche), maybe keeping it open is better?\n                                            // FilterInputPercentile closes on apply.\n                                            // FilterInputNiche calls onApply on every toggle.\n                                            // We probably want to keep it open until user manually closes header?\n                                            // But this function is inside `onApply`.\n                                            // Wait, if FilterInputNiche calls onApply on every toggle, then we shouldn't close it here.\n                                            // We rely on the generic close button in header.\n                                        }}\n                                    />\n                                )}\n                            </div>\n                        )}\n                    </div>\n                </div>,\n                document.body\n            )}\n        </>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Header/TrendsFilterChips.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Header/TrendsHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Header/TrendsSettings.tsx","messages":[{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Header/TrendsSettings.tsx:79:27\n  77 |                 isOpen={isSettingsOpen}\n  78 |                 onClose={handleClose}\n> 79 |                 anchorEl={settingsButtonRef.current}\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  80 |                 width={280}\n  81 |                 className=\"text-text-primary\"\n  82 |             >","line":79,"column":27,"nodeType":null,"endLine":79,"endColumn":52}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef } from 'react';\nimport { Settings, Maximize2, Check, ChevronLeft, X } from 'lucide-react';\nimport type { TimelineConfig } from '../../../core/types/trends';\nimport { ScalingTooltip } from './ScalingTooltip';\nimport { Dropdown } from '../../../components/Shared/Dropdown';\nimport { SegmentedControl } from '../../../components/ui/molecules/SegmentedControl';\n\ninterface TrendsSettingsProps {\n    timelineConfig: TimelineConfig;\n    setTimelineConfig: (config: Partial<TimelineConfig>) => void;\n    availableMinDate?: number;\n    availableMaxDate?: number;\n}\n\nexport const TrendsSettings: React.FC<TrendsSettingsProps> = ({\n    timelineConfig,\n    setTimelineConfig,\n    availableMinDate,\n    availableMaxDate\n}) => {\n    // Calculate safe maximum window (1/3 of total duration)\n    // If undefined, default to 90 (no clamping)\n    const maxSensibleDays = (availableMinDate && availableMaxDate)\n        ? Math.floor(((availableMaxDate - availableMinDate) / (1000 * 60 * 60 * 24)) / 3)\n        : 90;\n\n    // Settings Dropdown State\n    const [isSettingsOpen, setIsSettingsOpen] = useState(false);\n    const [settingsView, setSettingsView] = useState<'main' | 'scaling' | 'baseline'>('main');\n    const settingsButtonRef = useRef<HTMLButtonElement>(null);\n\n    // Tooltip State\n    const [hoveredScalingMode, setHoveredScalingMode] = useState<'linear' | 'log' | 'sqrt' | 'percentile' | null>(null);\n    const [hoveredBaselineMode, setHoveredBaselineMode] = useState<'dynamic' | 'global' | null>(null);\n    const [hoveredItemRect, setHoveredItemRect] = useState<DOMRect | null>(null);\n\n    const handleMouseEnter = (mode: string, type: 'scaling' | 'baseline', e: React.MouseEvent) => {\n        const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n        if (type === 'scaling') {\n            setHoveredScalingMode(mode as TimelineConfig['scalingMode']);\n            setHoveredBaselineMode(null);\n        } else {\n            setHoveredBaselineMode(mode as TimelineConfig['baselineMode'] & string);\n            setHoveredScalingMode(null);\n        }\n        setHoveredItemRect(rect);\n    };\n\n    const handleMouseLeave = () => {\n        setHoveredScalingMode(null);\n        setHoveredBaselineMode(null);\n        setHoveredItemRect(null);\n    };\n\n    const handleClose = () => {\n        setIsSettingsOpen(false);\n        setTimeout(() => setSettingsView('main'), 200); // Reset on close\n    };\n\n    return (\n        <div className=\"relative\">\n            <button\n                ref={settingsButtonRef}\n                onClick={() => {\n                    if (isSettingsOpen) {\n                        handleClose();\n                    } else {\n                        setIsSettingsOpen(true);\n                    }\n                }}\n                className={`p-2 rounded-lg transition-colors ${isSettingsOpen ? 'bg-bg-secondary text-text-primary' : 'text-text-secondary hover:text-text-primary hover:bg-bg-secondary'} `}\n            >\n                <Settings size={20} />\n            </button>\n\n            <Dropdown\n                isOpen={isSettingsOpen}\n                onClose={handleClose}\n                anchorEl={settingsButtonRef.current}\n                width={280}\n                className=\"text-text-primary\"\n            >\n                {settingsView === 'main' ? (\n                    <div className=\"py-2\">\n                        {/* Size Scaling Menu Item */}\n                        <div\n                            onClick={() => setSettingsView('scaling')}\n                            className=\"px-4 py-2.5 flex items-center justify-between cursor-pointer hover:bg-hover-bg transition-colors\"\n                        >\n                            <div className=\"flex items-center gap-3\">\n                                <div className=\"w-5 h-5 flex items-center justify-center\">\n                                    <Maximize2 size={20} />\n                                </div>\n                                <span className=\"text-sm\">Scaling: {\n                                    { linear: 'Linear', log: 'Logarithmic', sqrt: 'Square Root', percentile: 'Percentile' }[timelineConfig.scalingMode]\n                                }</span>\n                            </div>\n                            <svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\" fill=\"currentColor\" className=\"text-text-secondary\"><path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\" /></svg>\n                        </div>\n\n                        {/* Baseline Menu Item */}\n                        <div\n                            onClick={() => setSettingsView('baseline')}\n                            className=\"px-4 py-2.5 flex items-center justify-between cursor-pointer hover:bg-hover-bg transition-colors\"\n                        >\n                            <div className=\"flex items-center gap-3\">\n                                <div className=\"w-5 h-5 flex items-center justify-center\">\n                                    <svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\"><path d=\"M3 12h18\" /><path d=\"M3 6h18\" strokeDasharray=\"4 4\" opacity=\"0.5\" /></svg>\n                                </div>\n                                <span className=\"text-sm\">Baseline: {\n                                    !timelineConfig.showAverageBaseline ? 'Hidden' :\n                                        (timelineConfig.baselineMode === 'dynamic' ? 'Dynamic' : 'Global')\n                                }</span>\n                            </div>\n                            <svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\" fill=\"currentColor\" className=\"text-text-secondary\"><path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\" /></svg>\n                        </div>\n                    </div>\n                ) : settingsView === 'scaling' ? (\n                    /* Scaling Submenu */\n                    <div className=\"pb-2\">\n                        <div className=\"flex items-center justify-between px-2 py-2 border-b border-[#333333] mb-2\">\n                            <button\n                                onClick={() => setSettingsView('main')}\n                                className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                                <ChevronLeft size={20} />\n                            </button>\n                            <span className=\"text-sm font-bold text-text-primary\">Size Scaling</span>\n                            <button\n                                onClick={handleClose}\n                                className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                                <X size={20} />\n                            </button>\n                        </div>\n\n                        <div className=\"px-4 py-2 text-xs text-text-secondary\">\n                            Adjust how video thumbnails are sized\n                        </div>\n\n                        <div\n                            onClick={() => setTimelineConfig({ scalingMode: 'linear' })}\n                            onMouseEnter={(e) => handleMouseEnter('linear', 'scaling', e)}\n                            onMouseLeave={handleMouseLeave}\n                            className=\"px-4 py-2.5 flex items-center justify-between cursor-pointer hover:bg-hover-bg transition-colors relative\"\n                        >\n                            <div className=\"flex flex-col\">\n                                <span className=\"text-sm text-text-primary\">Linear</span>\n                                <span className=\"text-xs text-text-secondary\">Raw view counts</span>\n                            </div>\n                            {timelineConfig.scalingMode === 'linear' && <Check size={20} className=\"text-text-primary\" />}\n                        </div>\n\n                        <div\n                            onClick={() => setTimelineConfig({ scalingMode: 'sqrt' })}\n                            onMouseEnter={(e) => handleMouseEnter('sqrt', 'scaling', e)}\n                            onMouseLeave={handleMouseLeave}\n                            className=\"px-4 py-2.5 flex items-center justify-between cursor-pointer hover:bg-hover-bg transition-colors relative\"\n                        >\n                            <div className=\"flex flex-col\">\n                                <span className=\"text-sm text-text-primary\">Square Root</span>\n                                <span className=\"text-xs text-text-secondary\">Emphasizes top performers</span>\n                            </div>\n                            {timelineConfig.scalingMode === 'sqrt' && <Check size={20} className=\"text-text-primary\" />}\n                        </div>\n\n                        <div\n                            onClick={() => setTimelineConfig({ scalingMode: 'log' })}\n                            onMouseEnter={(e) => handleMouseEnter('log', 'scaling', e)}\n                            onMouseLeave={handleMouseLeave}\n                            className=\"px-4 py-2.5 flex items-center justify-between cursor-pointer hover:bg-hover-bg transition-colors relative\"\n                        >\n                            <div className=\"flex flex-col\">\n                                <span className=\"text-sm text-text-primary\">Logarithmic</span>\n                                <span className=\"text-xs text-text-secondary\">Balanced distribution</span>\n                            </div>\n                            {timelineConfig.scalingMode === 'log' && <Check size={20} className=\"text-text-primary\" />}\n                        </div>\n\n                        <div className=\"h-px bg-border my-1 mx-4 opacity-50\" />\n\n                        <div\n                            onClick={() => setTimelineConfig({ scalingMode: 'percentile' })}\n                            onMouseEnter={(e) => handleMouseEnter('percentile', 'scaling', e)}\n                            onMouseLeave={handleMouseLeave}\n                            className=\"px-4 py-2.5 flex items-center justify-between cursor-pointer hover:bg-hover-bg transition-colors relative\"\n                        >\n                            <div className=\"flex flex-col\">\n                                <span className=\"text-sm text-text-primary\">Percentile</span>\n                                <span className=\"text-xs text-text-secondary\">Rank-based sizing</span>\n                            </div>\n                            {timelineConfig.scalingMode === 'percentile' && <Check size={20} className=\"text-text-primary\" />}\n                        </div>\n                    </div>\n                ) : (\n                    /* Baseline Submenu */\n                    <div className=\"pb-2\">\n                        <div className=\"flex items-center justify-between px-2 py-2 border-b border-[#333333] mb-2\">\n                            <button\n                                onClick={() => setSettingsView('main')}\n                                className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                                <ChevronLeft size={20} />\n                            </button>\n                            <span className=\"text-sm font-bold text-text-primary\">Avg. Baseline</span>\n                            <button\n                                onClick={handleClose}\n                                className=\"p-2 hover:bg-[#333333] rounded-full text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                                <X size={20} />\n                            </button>\n                        </div>\n\n                        {/* Master Toggle */}\n                        <div\n                            onClick={() => setTimelineConfig({ showAverageBaseline: !timelineConfig.showAverageBaseline })}\n                            className=\"px-4 py-2.5 flex items-center justify-between cursor-pointer hover:bg-hover-bg transition-colors relative\"\n                        >\n                            <span className=\"text-sm text-text-primary\">Show Baseline</span>\n                            {/* Simple simulated switch */}\n                            <div className={`w-9 h-5 rounded-full relative transition-colors ${timelineConfig.showAverageBaseline ? 'bg-text-primary' : 'bg-border'}`}>\n                                <div className={`absolute top-1 w-3 h-3 rounded-full bg-bg-primary transition-all ${timelineConfig.showAverageBaseline ? 'left-5' : 'left-1'}`} />\n                            </div>\n                        </div>\n\n                        <div className={`transition-all duration-300 ${!timelineConfig.showAverageBaseline ? 'opacity-30 pointer-events-none' : ''}`}>\n                            <div className=\"h-px bg-border my-1 mx-4 opacity-50\" />\n\n                            <div className=\"px-4 py-3\">\n                                <div className=\"flex items-center justify-between mb-2\">\n                                    <span className=\"text-[11px] font-medium text-text-tertiary uppercase tracking-wider\">\n                                        Baseline Mode\n                                    </span>\n                                </div>\n                                <SegmentedControl\n                                    options={[\n                                        { label: 'Dynamic', value: 'dynamic' },\n                                        { label: 'Global', value: 'global' }\n                                    ]}\n                                    value={timelineConfig.baselineMode || 'dynamic'}\n                                    onChange={(v: 'dynamic' | 'global') => setTimelineConfig({ baselineMode: v })}\n                                    disabled={!timelineConfig.showAverageBaseline}\n                                />\n                                <div className=\"mt-2 text-[10px] text-text-tertiary leading-relaxed grid\">\n                                    <span className={`col-start-1 row-start-1 transition-opacity duration-150 ${timelineConfig.baselineMode === 'dynamic' ? 'opacity-100' : 'opacity-0'}`}>\n                                        Shows how channel performance evolves over time (rolling window)\n                                    </span>\n                                    <span className={`col-start-1 row-start-1 transition-opacity duration-150 ${timelineConfig.baselineMode === 'global' ? 'opacity-100' : 'opacity-0'}`}>\n                                        Single flat line representing the average views of all displayed videos\n                                    </span>\n                                </div>\n                            </div>\n\n                            {/* Window Size Switcher (Only visible in Dynamic mode) */}\n                            <div className={`px-4 pb-3 transition-opacity duration-200 ${timelineConfig.baselineMode === 'dynamic' ? 'opacity-100' : 'opacity-30 pointer-events-none'}`}>\n                                <div className=\"flex items-center justify-between mb-2\">\n                                    <span className=\"text-[11px] font-medium text-text-tertiary uppercase tracking-wider\">\n                                        Rolling Window\n                                    </span>\n                                </div>\n                                {(() => {\n                                    // Smart Button Logic\n                                    // 1. SafeMax: The ceiling (capped at 90)\n                                    const safeMax = Math.max(1, Math.min(90, maxSensibleDays));\n                                    // 2. SafeFast: Always 7, unless SafeMax pulls it down\n                                    const safeFast = Math.min(7, safeMax);\n                                    // 3. SafeMid: If Max is 90, keep 30. Else midpoint.\n                                    const safeMid = safeMax === 90 ? 30 : Math.round((safeFast + safeMax) / 2);\n\n                                    return (\n                                        <SegmentedControl\n                                            options={[\n                                                { label: `${safeFast}d`, value: safeFast, disabled: safeMax < safeFast },\n                                                { label: `${safeMid}d`, value: safeMid, disabled: safeMax < safeMid },\n                                                { label: `${safeMax}d`, value: safeMax, disabled: false } // Max is always available as \"Max\"\n                                            ]}\n                                            value={timelineConfig.baselineWindowSize || 30}\n                                            onChange={(v) => setTimelineConfig({ baselineWindowSize: v })}\n                                            disabled={!timelineConfig.showAverageBaseline || timelineConfig.baselineMode !== 'dynamic'}\n                                        />\n                                    )\n                                })()}\n                                <div className=\"mt-2 px-1 text-[10px] text-text-tertiary\">\n                                    {(timelineConfig.baselineWindowSize || 30) === 7 ? 'High sensitivity. Shows short-term hype.' :\n                                        (timelineConfig.baselineWindowSize || 30) === 90 ? `Low sensitivity. ${maxSensibleDays < 90 ? `Limited by data (max ${Math.max(1, Math.min(90, maxSensibleDays))}d).` : 'Shows long-term stability.'}` :\n                                            'Balanced. Midpoint smoothing.'}\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                )}\n            </Dropdown>\n\n            {/* Tooltips */}\n            {isSettingsOpen && hoveredScalingMode === 'linear' && (\n                <ScalingTooltip\n                    title=\"Linear Scaling\"\n                    description=\"The raw reality. See exactly how much bigger viral videos are compared to the rest. The gaps here are massive.\"\n                    example=\"1M views is 10x larger than 100K views.\"\n                    parentRect={hoveredItemRect}\n                />\n            )}\n            {isSettingsOpen && hoveredScalingMode === 'sqrt' && (\n                <ScalingTooltip\n                    title=\"Square Root Scaling\"\n                    description=\"Heavy emphasis on top performers. Reduces the extreme gaps of Linear, but viral hits still clearly dominate the chart.\"\n                    example=\"1M views is ~3.2x larger than 100K views.\"\n                    parentRect={hoveredItemRect}\n                />\n            )}\n            {isSettingsOpen && hoveredScalingMode === 'log' && (\n                <ScalingTooltip\n                    title=\"Logarithmic Scaling\"\n                    description=\"The great equalizer. Spreads out all videos evenly so you can see patterns across small, medium, and huge channels.\"\n                    example=\"1M views is only ~1.2x larger than 100K views.\"\n                    parentRect={hoveredItemRect}\n                />\n            )}\n            {isSettingsOpen && hoveredScalingMode === 'percentile' && (\n                <ScalingTooltip\n                    title=\"Percentile Scaling\"\n                    description=\"Rank-based sizing. Ignores absolute view counts to simply show which videos performed best relative to others.\"\n                    example=\"1M (Top 1%) is max size. 100K is sized by rank, ignoring the 10x gap.\"\n                    parentRect={hoveredItemRect}\n                />\n            )}\n\n            {/* Baseline Tooltips */}\n            {isSettingsOpen && hoveredBaselineMode === 'dynamic' && (\n                <ScalingTooltip\n                    title=\"Dynamic Baseline\"\n                    description=\"Adaptable moving average. Shows how channel performance evolves over time (30-day rolling window).\"\n                    example=\"Best for: Seeing trends, growth, or decline periods.\"\n                    parentRect={hoveredItemRect}\n                />\n            )}\n            {isSettingsOpen && hoveredBaselineMode === 'global' && (\n                <ScalingTooltip\n                    title=\"Global Baseline\"\n                    description=\"Fixed historic average. A single flat line representing the average views of all displayed videos.\"\n                    example=\"Best for: Comparing against all-time performance standard.\"\n                    parentRect={hoveredItemRect}\n                />\n            )}\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Header/TrendsStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Shared/MergeNichesModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Shared/NicheContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Shared/NicheItemBase.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Shared/SliderPopover.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2514,2517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2514,2517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, forwardRef } from 'react';\nimport { createPortal } from 'react-dom';\n\ninterface SliderPopoverProps {\n    isOpen: boolean;\n    anchorRef: React.RefObject<HTMLButtonElement | null>;\n    value: number;\n    label: string;\n    onChange: (value: number) => void;\n}\n\n// Slider Popover component rendered via portal for proper backdrop-blur\nexport const SliderPopover = forwardRef<HTMLDivElement, SliderPopoverProps>(({ isOpen, anchorRef, value, label, onChange }, ref) => {\n    const [position, setPosition] = useState({ x: 0, y: 0 });\n\n    useEffect(() => {\n        if (isOpen && anchorRef.current) {\n            const rect = anchorRef.current.getBoundingClientRect();\n            setPosition({\n                x: rect.left + rect.width / 2,\n                y: rect.top - 12 // 12px gap above the button\n            });\n        }\n    }, [isOpen, anchorRef]);\n\n    if (!isOpen) return null;\n\n    return createPortal(\n        <div\n            ref={ref}\n            className=\"fixed z-[1000] pointer-events-auto\"\n            style={{\n                left: position.x,\n                top: position.y,\n                transform: 'translate(-50%, -100%)'\n            }}\n        >\n            <div className=\"bg-bg-secondary/90 backdrop-blur-md border border-border rounded-full p-2 flex flex-col items-center gap-2 shadow-xl animate-fade-in-up\">\n                <span className=\"text-[10px] font-mono text-text-secondary w-8 text-center\">{label}</span>\n                <div className=\"h-32 w-6 flex items-center justify-center relative\">\n                    <div className=\"absolute w-1 h-full bg-border rounded-full pointer-events-none\" />\n                    <div\n                        className=\"absolute w-1 bg-text-secondary rounded-full bottom-0 pointer-events-none transition-all duration-75\"\n                        style={{ height: `${value}%` }}\n                    />\n                    <input\n                        type=\"range\"\n                        min=\"0\"\n                        max=\"100\"\n                        // @ts-expect-error - orient is not a standard HTML attribute but used in some browsers for vertical sliders\n                        orient=\"vertical\"\n                        value={value}\n                        onChange={(e) => onChange(parseInt(e.target.value))}\n                        className=\"absolute inset-0 w-full h-full opacity-0 cursor-pointer appearance-none z-10\"\n                        style={{ WebkitAppearance: 'slider-vertical' } as any}\n                    />\n                    <div\n                        className=\"absolute w-3 h-3 bg-white rounded-full shadow-md pointer-events-none transition-all duration-75\"\n                        style={{ bottom: `calc(${value}% - 6px)` }}\n                    />\n                </div>\n            </div>\n        </div>,\n        document.body\n    );\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Shared/SplitNicheModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/AddChannelModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/CollapsibleNicheList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/CopyChannelModal/CopyChannelModal.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useEffect has a missing dependency: 'handleClose'. Either include it or remove the dependency array.","line":55,"column":8,"nodeType":"ArrayExpression","endLine":55,"endColumn":19,"suggestions":[{"desc":"Update the dependencies array to be: [copyState, handleClose]","fix":{"range":[1472,1483],"text":"[copyState, handleClose]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { createPortal } from 'react-dom';\nimport { X, Copy, AlertTriangle, Check, Loader2, User } from 'lucide-react';\nimport { useCopyChannel } from './useCopyChannel';\nimport type { TrendChannel } from '../../../../core/types/trends';\nimport type { Channel } from '../../../../core/services/channelService';\n\ninterface CopyChannelModalProps {\n    isOpen: boolean;\n    onClose: () => void;\n    trendChannel: TrendChannel | null;\n}\n\n/**\n * Modal for copying a TrendChannel to another User Channel.\n * \n * Flow:\n * 1. selecting: User picks target channel\n * 2. conflict: TrendChannel exists in target  ask Merge/Cancel\n * 3. copying: In progress\n * 4. success: Done, auto-close\n */\nexport const CopyChannelModal: React.FC<CopyChannelModalProps> = ({\n    isOpen,\n    onClose,\n    trendChannel\n}) => {\n    const {\n        copyState,\n        targetChannelId,\n        availableTargets,\n        error,\n        nichesToCopy,\n        videosCount,\n        hiddenVideosCount,\n        setTargetChannel,\n        checkAndCopy,\n        confirmMerge,\n        cancel,\n        reset\n    } = useCopyChannel(trendChannel);\n\n    // Close and reset state\n    const handleClose = () => {\n        reset();\n        onClose();\n    };\n\n    // Auto-close on success after brief delay\n    React.useEffect(() => {\n        if (copyState === 'success') {\n            const timer = setTimeout(handleClose, 1500);\n            return () => clearTimeout(timer);\n        }\n    }, [copyState]);\n\n    if (!isOpen || !trendChannel) return null;\n\n    const selectedTarget = availableTargets.find(c => c.id === targetChannelId);\n\n    return createPortal(\n        <div\n            className=\"fixed inset-0 z-[2000] flex items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in\"\n            onClick={handleClose}\n        >\n            <div\n                className=\"bg-bg-secondary rounded-xl w-[440px] max-w-[90vw] flex flex-col overflow-hidden animate-scale-in border border-border shadow-2xl\"\n                onClick={e => e.stopPropagation()}\n            >\n                {/* Header */}\n                <div className=\"px-6 py-4 flex items-center justify-between border-b border-border\">\n                    <div className=\"flex items-center gap-3\">\n                        <Copy size={20} className=\"text-[#3ea6ff]\" />\n                        <h2 className=\"text-lg font-bold text-text-primary m-0\">\n                            Copy to Channel\n                        </h2>\n                    </div>\n                    <button\n                        onClick={handleClose}\n                        className=\"p-1 rounded-full text-text-secondary hover:text-text-primary hover:bg-white/10 transition-colors\"\n                    >\n                        <X size={20} />\n                    </button>\n                </div>\n\n                {/* Content */}\n                <div className=\"p-6\">\n                    {/* Source Channel Info */}\n                    <div className=\"flex items-center gap-3 p-3 rounded-lg bg-white/5 mb-6\">\n                        <img\n                            src={trendChannel.avatarUrl}\n                            alt={trendChannel.title}\n                            className=\"w-10 h.10 rounded-full\"\n                            referrerPolicy=\"no-referrer\"\n                        />\n                        <div className=\"flex-1 min-w-0\">\n                            <div className=\"text-text-primary font-medium truncate\">\n                                {trendChannel.title}\n                            </div>\n                            <div className=\"text-xs text-text-tertiary\">\n                                {nichesToCopy.length} niches  {videosCount} videos\n                                {hiddenVideosCount > 0 && `  ${hiddenVideosCount} hidden`}\n                            </div>\n                        </div>\n                    </div>\n\n                    {/* State: Selecting */}\n                    {copyState === 'selecting' && (\n                        <>\n                            <label className=\"block text-sm text-text-secondary mb-2\">\n                                Copy to:\n                            </label>\n                            {availableTargets.length === 0 ? (\n                                <div className=\"text-text-tertiary text-sm p-4 text-center rounded-lg border border-dashed border-border\">\n                                    No other channels available.\n                                    <br />\n                                    Create another channel first.\n                                </div>\n                            ) : (\n                                <div className=\"space-y-2 max-h-[200px] overflow-y-auto\">\n                                    {availableTargets.map(channel => (\n                                        <ChannelOption\n                                            key={channel.id}\n                                            channel={channel}\n                                            isSelected={targetChannelId === channel.id}\n                                            onClick={() => setTargetChannel(channel.id)}\n                                        />\n                                    ))}\n                                </div>\n                            )}\n                        </>\n                    )}\n\n                    {/* State: Conflict */}\n                    {copyState === 'conflict' && (\n                        <div className=\"space-y-4\">\n                            <div className=\"flex items-start gap-3 p-4 rounded-lg bg-amber-500/10 border border-amber-500/30\">\n                                <AlertTriangle size={20} className=\"text-amber-500 shrink-0 mt-0.5\" />\n                                <div>\n                                    <div className=\"text-text-primary font-medium mb-1\">\n                                        Channel Already Exists\n                                    </div>\n                                    <div className=\"text-sm text-text-secondary\">\n                                        <strong>{trendChannel.title}</strong> is already tracked in{' '}\n                                        <strong>{selectedTarget?.name}</strong>.\n                                        <br />\n                                        Merge will add new niches and video assignments.\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                    )}\n\n                    {/* State: Copying */}\n                    {copyState === 'copying' && (\n                        <div className=\"flex flex-col items-center justify-center py-8\">\n                            <Loader2 size={32} className=\"text-[#3ea6ff] animate-spin mb-3\" />\n                            <div className=\"text-text-secondary\">Copying data...</div>\n                        </div>\n                    )}\n\n                    {/* State: Success */}\n                    {copyState === 'success' && (\n                        <div className=\"flex flex-col items-center justify-center py-8\">\n                            <div className=\"w-12 h-12 rounded-full bg-emerald-500/20 flex items-center justify-center mb-3\">\n                                <Check size={24} className=\"text-emerald-500\" />\n                            </div>\n                            <div className=\"text-text-primary font-medium\">Copied successfully!</div>\n                        </div>\n                    )}\n\n                    {/* State: Error */}\n                    {copyState === 'error' && (\n                        <div className=\"p-4 rounded-lg bg-red-500/10 border border-red-500/30 text-red-400\">\n                            {error || 'Something went wrong'}\n                        </div>\n                    )}\n                </div>\n\n                {/* Footer */}\n                {(copyState === 'selecting' || copyState === 'conflict' || copyState === 'error') && (\n                    <div className=\"px-6 py-4 flex justify-end gap-3 border-t border-border bg-bg-secondary/30\">\n                        <button\n                            onClick={copyState === 'conflict' ? cancel : handleClose}\n                            className=\"px-4 py-2 rounded-lg font-medium text-text-secondary hover:text-text-primary transition-colors bg-transparent border-none cursor-pointer\"\n                        >\n                            Cancel\n                        </button>\n\n                        {copyState === 'selecting' && (\n                            <button\n                                onClick={checkAndCopy}\n                                disabled={!targetChannelId || availableTargets.length === 0}\n                                className=\"px-4 py-2 rounded-lg font-bold text-white bg-[#3ea6ff] hover:bg-[#3ea6ff]/90 transition-colors border-none cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed\"\n                            >\n                                Copy\n                            </button>\n                        )}\n\n                        {copyState === 'conflict' && (\n                            <button\n                                onClick={confirmMerge}\n                                className=\"px-4 py-2 rounded-lg font-bold text-white bg-amber-600 hover:bg-amber-700 transition-colors border-none cursor-pointer\"\n                            >\n                                Merge\n                            </button>\n                        )}\n\n                        {copyState === 'error' && (\n                            <button\n                                onClick={reset}\n                                className=\"px-4 py-2 rounded-lg font-bold text-white bg-[#3ea6ff] hover:bg-[#3ea6ff]/90 transition-colors border-none cursor-pointer\"\n                            >\n                                Try Again\n                            </button>\n                        )}\n                    </div>\n                )}\n            </div>\n        </div>,\n        document.body\n    );\n};\n\n// Sub-component for channel selection option\nconst ChannelOption: React.FC<{\n    channel: Channel;\n    isSelected: boolean;\n    onClick: () => void;\n}> = ({ channel, isSelected, onClick }) => (\n    <button\n        onClick={onClick}\n        className={`w-full flex items-center gap-3 p-3 rounded-lg border transition-all cursor-pointer ${isSelected\n            ? 'border-[#3ea6ff] bg-[#3ea6ff]/10'\n            : 'border-border bg-white/5 hover:bg-white/10'\n            }`}\n    >\n        <div className=\"w-8 h-8 rounded-full bg-purple-600 flex items-center justify-center overflow-hidden shrink-0\">\n            {channel.avatar ? (\n                <img src={channel.avatar} alt={channel.name} className=\"w-full h-full object-cover\" />\n            ) : (\n                <User size={16} color=\"white\" />\n            )}\n        </div>\n        <span className=\"text-text-primary truncate flex-1 text-left\">{channel.name}</span>\n        {isSelected && <Check size={16} className=\"text-[#3ea6ff] shrink-0\" />}\n    </button>\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/CopyChannelModal/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/CopyChannelModal/useCopyChannel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/TrendNicheItem.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/TrendNicheItem.tsx:132:13\n  130 |     useEffect(() => {\n  131 |         if (isDragging) {\n> 132 |             setIsNameHovered(false);\n      |             ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  133 |         }\n  134 |     }, [isDragging]);\n  135 |","line":132,"column":13,"nodeType":null,"endLine":132,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { useDroppable } from '@dnd-kit/core';\nimport { MoreVertical, Check, Trash2, Target } from 'lucide-react';\nimport type { TrendNiche } from '../../../core/types/trends';\nimport { useTrendStore, MANUAL_NICHE_PALETTE } from '../../../core/stores/trendStore';\nimport { useChannelStore } from '../../../core/stores/channelStore';\nimport { ConfirmationModal } from '../../../components/Shared/ConfirmationModal';\nimport { NicheContextMenu } from '../Shared/NicheContextMenu';\n\ninterface TrendNicheItemProps {\n    niche: TrendNiche;\n    isActive: boolean;\n    onClick: (id: string) => void;\n    isTrash?: boolean;\n}\n\nconst formatViewCount = (num?: number) => {\n    if (!num) return '0';\n    return new Intl.NumberFormat('en-US', {\n        notation: \"compact\",\n        maximumFractionDigits: 1\n    }).format(num);\n};\n\nexport const TrendNicheItem: React.FC<TrendNicheItemProps> = ({\n    niche,\n    isActive,\n    onClick,\n    isTrash = false\n}) => {\n    const { updateNiche, deleteNiche, isDragging } = useTrendStore();\n    const { currentChannel } = useChannelStore();\n    const [isMenuOpen, setIsMenuOpen] = useState(false);\n    const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);\n    const [isEditing, setIsEditing] = useState(false);\n    const [editName, setEditName] = useState(niche.name);\n    const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);\n\n    // Check if this niche is targeted for the current USER channel (from ChannelDropdown)\n    const isTargeted = !isTrash && (currentChannel?.targetNicheIds?.includes(niche.id) ?? false);\n\n    // DnD: Make this niche a drop target (only for non-trash items)\n    const { setNodeRef, isOver } = useDroppable({\n        id: niche.id,\n        disabled: isTrash\n    });\n\n    const menuRef = useRef<HTMLDivElement>(null);\n    const menuButtonRef = useRef<HTMLButtonElement>(null);\n    const colorPickerRef = useRef<HTMLDivElement>(null);\n    const inputRef = useRef<HTMLInputElement>(null);\n    const nameRef = useRef<HTMLSpanElement>(null);\n    const [isNameHovered, setIsNameHovered] = useState(false);\n    const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });\n    const [isTruncated, setIsTruncated] = useState(false);\n    const [menuPosition, setMenuPosition] = useState({ x: 0, y: 0 });\n\n    // Use manually exported palette for user picker\n    const PRESET_COLORS = MANUAL_NICHE_PALETTE;\n\n    // Close dropdowns on outside click\n    useEffect(() => {\n        const handleClickOutside = (e: MouseEvent) => {\n            // NOTE: isMenuOpen check removed here because NicheContextMenu uses a portal with a backdrop\n            // which handles closing on click outside. The old check on 'mousedown' was causing the menu\n            // to close before the click event could propagate to the portal buttons.\n\n            if (isColorPickerOpen && colorPickerRef.current && !colorPickerRef.current.contains(e.target as Node)) {\n                setIsColorPickerOpen(false);\n            }\n        };\n\n        if (isMenuOpen || isColorPickerOpen) {\n            document.addEventListener('mousedown', handleClickOutside);\n            return () => document.removeEventListener('mousedown', handleClickOutside);\n        }\n    }, [isMenuOpen, isColorPickerOpen]);\n\n    // Focus input when entering edit mode\n    useEffect(() => {\n        if (isEditing && inputRef.current) {\n            inputRef.current.focus();\n            inputRef.current.select();\n        }\n    }, [isEditing]);\n\n    // Detect text truncation for fade effect\n    useEffect(() => {\n        const el = nameRef.current;\n        if (!el) return;\n        const check = () => setIsTruncated(el.scrollWidth > el.clientWidth);\n        check();\n        const ro = new ResizeObserver(check);\n        ro.observe(el);\n        return () => ro.disconnect();\n    }, [niche.name]);\n\n    const handleNameSubmit = () => {\n        const trimmedName = editName.trim();\n        if (trimmedName && trimmedName !== niche.name) {\n            updateNiche(niche.id, { name: trimmedName });\n        }\n        setIsEditing(false);\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n        if (e.key === 'Enter') {\n            handleNameSubmit();\n        } else if (e.key === 'Escape') {\n            setEditName(niche.name);\n            setIsEditing(false);\n        }\n    };\n\n    const isInteracting = isMenuOpen || isColorPickerOpen;\n\n    // Premium: When dragging video over this niche, show highlight\n    const isDragTarget = isOver && !isTrash;\n\n    // Ensure tooltip position is set when drag target becomes active\n    useEffect(() => {\n        if (isDragTarget && nameRef.current) {\n            const rect = nameRef.current.getBoundingClientRect();\n            setTooltipPos({ x: rect.left, y: rect.top - 4 });\n        }\n    }, [isDragTarget]);\n\n    // Ensure tooltip is hidden if drag starts while hovering\n    useEffect(() => {\n        if (isDragging) {\n            setIsNameHovered(false);\n        }\n    }, [isDragging]);\n\n    return (\n        <div\n            ref={setNodeRef}\n            className={`relative group/niche ml-8 ${isDragTarget ? 'z-[10001]' : isInteracting ? 'z-20' : ''}`}\n        >\n            <div\n                onClick={() => !isEditing && onClick(niche.id)}\n                className={`\n                    flex items-center pl-2 pr-2 py-1.5 cursor-pointer transition-all rounded-lg\n                    ${isDragTarget\n                        ? 'bg-white/20 text-white'\n                        : isActive\n                            ? 'bg-white/10 text-white'\n                            : isInteracting\n                                ? 'bg-white/5 text-white'\n                                : 'text-text-secondary hover:text-white hover:bg-white/5'\n                    }\n                `}\n            >\n                {/* Icon Wrapper */}\n                <div className=\"mr-1 shrink-0 flex items-center justify-center w-4\">\n                    {isTrash ? (\n                        <Trash2 size={14} className={`${isActive ? 'text-white' : 'text-gray-400'} translate-y-[-2px]`} />\n                    ) : (\n                        <div\n                            ref={colorPickerRef}\n                            className=\"relative\"\n                        >\n                            <div\n                                role=\"button\"\n                                onClick={(e) => {\n                                    e.stopPropagation();\n                                    setIsColorPickerOpen(!isColorPickerOpen);\n                                    setIsMenuOpen(false);\n                                }}\n                                className=\"w-2.5 h-2.5 rounded-full transition-all hover:scale-125 hover:ring-2 hover:ring-white/20 cursor-pointer\"\n                                style={{ backgroundColor: niche.color }}\n                            />\n\n                            {/* Color Picker */}\n                            {isColorPickerOpen && (\n                                <div\n                                    className=\"absolute left-0 top-6 z-50 bg-[#1a1a1a] border border-white/10 rounded-xl p-3 shadow-xl animate-fade-in\"\n                                    onClick={(e) => e.stopPropagation()}\n                                >\n                                    <div\n                                        className=\"grid gap-2\"\n                                        style={{ gridTemplateColumns: 'repeat(5, min-content)' }}\n                                    >\n                                        {PRESET_COLORS.map(color => (\n                                            <button\n                                                key={color}\n                                                onClick={(e) => {\n                                                    e.stopPropagation();\n                                                    updateNiche(niche.id, { color });\n                                                    setIsColorPickerOpen(false);\n                                                }}\n                                                className=\"w-6 h-6 rounded-full transition-shadow relative hover:ring-2 hover:ring-white/50 ring-offset-1 ring-offset-[#1a1a1a]\"\n                                                style={{ backgroundColor: color }}\n                                            >\n                                                {niche.color === color && (\n                                                    <Check size={12} className=\"absolute inset-0 m-auto text-white drop-shadow-sm\" strokeWidth={3} />\n                                                )}\n                                            </button>\n                                        ))}\n                                    </div>\n                                </div>\n                            )}\n                        </div>\n                    )}\n                </div>\n\n                {/* Target Icon (for targeted niches) */}\n                {isTargeted && (\n                    <Target size={11} className=\"text-emerald-400 mr-1 shrink-0\" />\n                )}\n\n                {/* Name (Editable on double-click) */}\n                <div className=\"flex-1 min-w-0 relative flex items-center\">\n                    <span\n                        ref={nameRef}\n                        className={`text-xs overflow-hidden whitespace-nowrap transition-colors leading-none translate-y-[-1px] ${isEditing ? 'opacity-0' : ''} ${isTargeted ? 'text-emerald-400' : ''}`}\n                        style={isTruncated ? {\n                            // Fade truncation always applied (name visible via tooltip when isDragTarget)\n                            maskImage: 'linear-gradient(to right, black 50%, transparent 100%)',\n                            WebkitMaskImage: 'linear-gradient(to right, black 50%, transparent 100%)'\n                        } : undefined}\n                        onMouseEnter={() => {\n                            if (isDragging) return; // Prevent normal tooltip during drag\n                            if (nameRef.current) {\n                                const rect = nameRef.current.getBoundingClientRect();\n                                setTooltipPos({ x: rect.left, y: rect.top - 4 });\n                            }\n                            setIsNameHovered(true);\n                        }}\n                        onMouseLeave={() => setIsNameHovered(false)}\n                    >\n                        {niche.name}\n                    </span>\n                    {isEditing && !isTrash && (\n                        <input\n                            ref={inputRef}\n                            type=\"text\"\n                            value={editName}\n                            onChange={(e) => setEditName(e.target.value)}\n                            onBlur={handleNameSubmit}\n                            onKeyDown={handleKeyDown}\n                            onClick={(e) => e.stopPropagation()}\n                            className=\"absolute inset-y-0 left-0 right-0 text-xs bg-[#1a1a1a] border-0 border-b border-white/40 outline-none text-white z-10\"\n                        />\n                    )}\n                </div>\n\n                {/* Portal Tooltip */}\n                {((isNameHovered && !isDragging) || isDragTarget) && !isEditing && createPortal(\n                    <div\n                        className=\"fixed z-[9999] px-2 py-1 bg-[#1a1a1a] border border-white/10 rounded-md shadow-xl text-xs text-white whitespace-nowrap pointer-events-none animate-fade-in\"\n                        style={{ left: tooltipPos.x, top: tooltipPos.y, transform: 'translateY(-100%)' }}\n                    >\n                        {niche.name}\n                    </div>,\n                    document.body\n                )}\n\n                {/* View Count & Actions block */}\n                <div className=\"ml-2 flex items-center gap-0.5 shrink-0\">\n                    {/* View Count */}\n                    <span className=\"text-[10px] text-text-tertiary leading-none\">\n                        {formatViewCount(niche.viewCount)}\n                    </span>\n\n                    {/* Actions Trigger (Hidden unless hovered/active) */}\n                    {!isTrash && (\n                        <div ref={menuRef} className=\"relative\">\n                            <button\n                                ref={menuButtonRef}\n                                onClick={(e) => {\n                                    e.stopPropagation();\n                                    if (!isMenuOpen) {\n                                        // Calculate position for portal\n                                        const rect = e.currentTarget.getBoundingClientRect();\n                                        setMenuPosition({\n                                            x: rect.right + 5, // Open to the right slightly\n                                            y: rect.top\n                                        });\n                                    }\n                                    setIsMenuOpen(!isMenuOpen);\n                                    setIsColorPickerOpen(false);\n                                }}\n                                className={`\n                                    p-0.5 rounded-full transition-opacity\n                                    ${isInteracting ? 'opacity-100' : 'opacity-0 group-hover/niche:opacity-100'}\n                                    ${isMenuOpen ? 'opacity-100 bg-white/10' : 'hover:bg-white/10'}\n                                    relative after:absolute after:-inset-2 after:content-['']\n                                `}\n                            >\n                                <MoreVertical size={12} />\n                            </button>\n\n                            {/* Shared Context Menu */}\n                            <NicheContextMenu\n                                niche={niche}\n                                isOpen={isMenuOpen}\n                                onClose={() => setIsMenuOpen(false)}\n                                position={menuPosition}\n                                onRename={() => {\n                                    setIsEditing(true);\n                                    setEditName(niche.name);\n                                    setIsMenuOpen(false);\n                                }}\n                                onDelete={() => {\n                                    setIsDeleteConfirmOpen(true);\n                                    setIsMenuOpen(false);\n                                }}\n                                hideFilterOption={true}\n                            />\n                        </div>\n                    )}\n                </div>\n            </div>\n\n            <ConfirmationModal\n                isOpen={isDeleteConfirmOpen}\n                onClose={() => setIsDeleteConfirmOpen(false)}\n                onConfirm={() => {\n                    deleteNiche(niche.id);\n                    setIsDeleteConfirmOpen(false);\n                }}\n                title=\"Delete Niche\"\n                message={`Are you sure you want to delete \"${niche.name}\"? This will remove all video assignments.`}\n                confirmLabel=\"Delete\"\n            />\n        </div >\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/TrendsChannelItem.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/TrendsChannelItem.tsx:61:9\n  59 |     // Reset avatar error state when avatarUrl changes (e.g., after sync refresh)\n  60 |     useEffect(() => {\n> 61 |         setAvatarError(false);\n     |         ^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  62 |     }, [channel.avatarUrl]);\n  63 |\n  64 |     const handleAvatarError = () => {","line":61,"column":9,"nodeType":null,"endLine":61,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Eye, EyeOff, MoreVertical, ChevronDown, ChevronRight } from 'lucide-react';\nimport type { TrendChannel, TrendNiche } from '../../../core/types/trends';\nimport { CollapsibleNicheList } from './CollapsibleNicheList';\nimport { useTrendStore } from '../../../core/stores/trendStore';\n\ninterface TrendsChannelItemProps {\n    channel: TrendChannel;\n    isActive: boolean;\n    onChannelClick: (id: string) => void;\n    onToggleVisibility: (e: React.MouseEvent, id: string, isVisible: boolean) => void;\n    onOpenMenu: (e: React.MouseEvent, channelId: string) => void;\n    niches?: TrendNiche[];\n    activeNicheIds?: string[];\n    onNicheClick?: (id: string, channelId?: string) => void;\n    trashCount?: number;\n    viewCount?: number;\n    isMenuOpen?: boolean;\n}\n\nconst formatViewCount = (num?: number) => {\n    if (!num) return '0';\n    return new Intl.NumberFormat('en-US', {\n        notation: \"compact\",\n        maximumFractionDigits: 1\n    }).format(num);\n};\n\n// LocalStorage key prefix for channel collapse state\nconst CHANNEL_EXPANDED_KEY = 'trends-channel-expanded-';\n\nexport const TrendsChannelItem: React.FC<TrendsChannelItemProps> = ({\n    channel,\n    isActive,\n    onChannelClick,\n    onToggleVisibility,\n    onOpenMenu,\n    niches = [],\n    activeNicheIds = [],\n    onNicheClick,\n    trashCount = 0,\n    viewCount = 0,\n    isMenuOpen = false\n}) => {\n    // Persist channel niche section collapse state per-channel\n    const [isExpanded, setIsExpanded] = useState(() => {\n        const saved = localStorage.getItem(CHANNEL_EXPANDED_KEY + channel.id);\n        return saved !== null ? saved === 'true' : true; // Default expanded\n    });\n    useEffect(() => {\n        localStorage.setItem(CHANNEL_EXPANDED_KEY + channel.id, String(isExpanded));\n    }, [isExpanded, channel.id]);\n\n    // Track avatar loading errors to show fallback\n    const [avatarError, setAvatarError] = useState(false);\n    const markAvatarBroken = useTrendStore(state => state.markAvatarBroken);\n\n    // Reset avatar error state when avatarUrl changes (e.g., after sync refresh)\n    useEffect(() => {\n        setAvatarError(false);\n    }, [channel.avatarUrl]);\n\n    const handleAvatarError = () => {\n        setAvatarError(true);\n        markAvatarBroken(channel.id);\n    };\n\n    // Tooltip State\n    const [showTooltip, setShowTooltip] = useState(false);\n    const [isHovered, setIsHovered] = useState(false);\n    const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });\n    const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const nameRef = useRef<HTMLSpanElement>(null);\n\n    const hasContent = niches.length > 0 || trashCount > 0;\n\n    const handleMouseEnter = () => {\n        timerRef.current = setTimeout(() => {\n            if (nameRef.current) {\n                const rect = nameRef.current.getBoundingClientRect();\n                setTooltipPos({ x: rect.left, y: rect.top - 8 });\n                setShowTooltip(true);\n            }\n        }, 500);\n    };\n\n    const handleMouseLeave = () => {\n        if (timerRef.current) clearTimeout(timerRef.current);\n        setShowTooltip(false);\n        setIsHovered(false);\n    };\n\n    const handleSpanMouseLeave = () => {\n        if (timerRef.current) clearTimeout(timerRef.current);\n        setShowTooltip(false);\n    };\n\n    // Detect text truncation\n    const [isTruncated, setIsTruncated] = useState(false);\n    useEffect(() => {\n        const el = nameRef.current;\n        if (!el) return;\n        const check = () => setIsTruncated(el.scrollWidth > el.clientWidth);\n        check();\n        const ro = new ResizeObserver(check);\n        ro.observe(el);\n        return () => ro.disconnect();\n    }, [channel.title]);\n\n    return (\n        <React.Fragment>\n            <li\n                onClick={() => onChannelClick(channel.id)}\n                onMouseEnter={() => setIsHovered(true)}\n                onMouseLeave={handleMouseLeave}\n                className={`flex items-center group cursor-pointer p-2 rounded-lg transition-all duration-200 select-none ${isActive\n                    ? 'bg-white/10'\n                    : isMenuOpen ? 'bg-white/5' : 'hover:bg-white/5'\n                    }`}\n            >\n                {channel.avatarUrl && !avatarError ? (\n                    <img\n                        src={channel.avatarUrl}\n                        alt={channel.title}\n                        referrerPolicy=\"no-referrer\"\n                        onError={handleAvatarError}\n                        className={`w-6 h-6 rounded-full mr-3 ring-2 transition-all ${!channel.isVisible ? 'grayscale opacity-50' : ''\n                            } ${isActive ? 'ring-white/30' : 'ring-transparent'}`}\n                    />\n                ) : (\n                    <div className={`w-6 h-6 rounded-full mr-3 ring-2 flex items-center justify-center bg-white/10 text-text-secondary text-xs font-medium transition-all ${!channel.isVisible ? 'opacity-50' : ''\n                        } ${isActive ? 'ring-white/30' : 'ring-transparent'}`}>\n                        {channel.title.charAt(0).toUpperCase()}\n                    </div>\n                )}\n\n                {/* Expand Toggle */}\n                {hasContent && (\n                    <button\n                        onClick={(e) => {\n                            e.stopPropagation();\n                            setIsExpanded(!isExpanded);\n                        }}\n                        className=\"p-2 -m-1.5 mr-0 text-text-tertiary hover:text-white transition-colors\"\n                    >\n                        {isExpanded ? <ChevronDown size={12} /> : <ChevronRight size={12} />}\n                    </button>\n                )}\n\n                <span\n                    ref={nameRef}\n                    onMouseEnter={handleMouseEnter}\n                    onMouseLeave={handleSpanMouseLeave}\n                    className={`text-sm flex-1 overflow-hidden whitespace-nowrap transition-colors ${isActive ? 'text-text-primary font-medium' : 'text-text-secondary'\n                        }`}\n                    style={isTruncated ? {\n                        maskImage: `linear-gradient(to right, black ${isActive || isHovered ? '60%' : '80%'}, transparent 100%)`,\n                        WebkitMaskImage: `linear-gradient(to right, black ${isActive || isHovered ? '60%' : '80%'}, transparent 100%)`\n                    } : undefined}>\n                    {channel.title}\n                </span>\n\n                {/* Portal Tooltip */}\n                {showTooltip && createPortal(\n                    <div\n                        className=\"fixed z-[9999] px-2 py-1 bg-[#1a1a1a] border border-white/10 rounded-md shadow-xl text-xs text-white whitespace-nowrap pointer-events-none animate-fade-in\"\n                        style={{ left: tooltipPos.x, top: tooltipPos.y, transform: 'translateY(-100%)' }}\n                    >\n                        {channel.title}\n                    </div>,\n                    document.body\n                )}\n\n                {/* View Count & Actions block */}\n                {(isActive || isHovered || isMenuOpen || !channel.isVisible) && (\n                    <div className={`ml-1 flex items-center gap-0.5 shrink-0 transition-opacity animate-fade-in`}>\n                        {(isActive || isHovered) && (\n                            <span className={`text-[10px] text-text-tertiary shrink-0 leading-none transition-opacity duration-200`}>\n                                {formatViewCount(viewCount)}\n                            </span>\n                        )}\n                        <div className={`flex items-center gap-0.5 ${!channel.isVisible || isMenuOpen ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'} transition-opacity`}>\n                            <button\n                                onClick={(e) => {\n                                    e.stopPropagation();\n                                    onToggleVisibility(e, channel.id, channel.isVisible);\n                                }}\n                                className={`p-0.5 rounded-full transition-all ${channel.isVisible\n                                    ? 'text-text-secondary hover:text-text-primary hover:bg-white/10'\n                                    : 'text-text-tertiary bg-white/5 hover:text-red-400 hover:bg-red-500/10'\n                                    } relative after:absolute after:-inset-2 after:content-['']`}\n                                title={channel.isVisible ? \"Hide channel\" : \"Show channel\"}\n                            >\n                                {channel.isVisible ? <Eye size={14} /> : <EyeOff size={14} />}\n                            </button>\n                            <button\n                                onClick={(e) => {\n                                    e.stopPropagation();\n                                    onOpenMenu(e, channel.id);\n                                }}\n                                className=\"p-0.5 text-text-secondary hover:text-white hover:bg-white/10 rounded-full transition-colors relative after:absolute after:-inset-2 after:content-['']\"\n                                title=\"More options\"\n                            >\n                                <MoreVertical size={14} />\n                            </button>\n                        </div>\n                    </div>\n                )}\n            </li>\n            {isExpanded && hasContent && (\n                <li className=\"mb-1\">\n                    <CollapsibleNicheList\n                        niches={niches}\n                        activeNicheIds={activeNicheIds}\n                        onNicheClick={(id) => id && onNicheClick?.(id, channel.id)}\n                        trashCount={trashCount}\n                        storageKey={channel.id}\n                    />\n                </li>\n            )}\n        </React.Fragment>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/TrendsChannelSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/TrendsSidebarSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Sidebar/hooks/useTrendsSidebar.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6758,6761],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6758,6761],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport { useTrendStore } from '../../../../core/stores/trendStore';\nimport { TrendService } from '../../../../core/services/trendService';\nimport { useAuth } from '../../../../core/hooks/useAuth';\nimport { useChannelStore } from '../../../../core/stores/channelStore';\nimport { useChannels } from '../../../../core/hooks/useChannels';\nimport { useApiKey } from '../../../../core/hooks/useApiKey';\nimport { useUIStore } from '../../../../core/stores/uiStore';\nimport { useNotificationStore } from '../../../../core/stores/notificationStore';\nimport type { TrendChannel } from '../../../../core/types/trends';\n\ninterface MenuState {\n    anchorEl: HTMLElement | null;\n    channelId: string | null;\n}\n\nexport const useTrendsSidebar = () => {\n    const { channels, selectedChannelId, setSelectedChannelId, setAddChannelModalOpen, isLoadingChannels, trendsFilters, removeTrendsFilter, setChannelRootFilters, setTrendsFilters, setNicheFilters } = useTrendStore();\n    const { user, isLoading: isAuthLoading } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { isLoading: isChannelsLoading } = useChannels(user?.uid || '');\n    const { apiKey, hasApiKey } = useApiKey();\n    const { showToast } = useUIStore();\n    const { addNotification } = useNotificationStore();\n    const navigate = useNavigate();\n    const location = useLocation();\n\n    const [menuState, setMenuState] = useState<MenuState>({ anchorEl: null, channelId: null });\n    const [channelToDelete, setChannelToDelete] = useState<TrendChannel | null>(null);\n\n    const isOnTrendsPage = location.pathname === '/trends';\n\n    const handleTrendsClick = () => {\n        // Clear any active niche filters when going to main trends\n        const nicheFilter = trendsFilters.find(f => f.type === 'niche');\n        if (nicheFilter) {\n            removeTrendsFilter(nicheFilter.id);\n        }\n        setSelectedChannelId(null);\n        navigate('/trends');\n    };\n\n    /**\n     * Handle channel click in sidebar.\n     * \n     * BEHAVIORS:\n     * - Click any channel: ALWAYS go to ROOT (from channelRootFilters)\n     * - Click same channel from ROOT: Reset to empty (clear all filters)\n     * \n     * TRASH is ONLY accessible via clicking \"Untracked\" niche.\n     */\n    const handleChannelClick = (channelId: string) => {\n        // Step 1: Save current state before switching\n        const currentNicheFilter = trendsFilters.find(f => f.type === 'niche');\n        const isUnassigned = currentNicheFilter && (currentNicheFilter.value as string[]).includes('UNASSIGNED');\n\n        if (currentNicheFilter && !isUnassigned) {\n            // In a real niche (including TRASH)  save to nicheFilters\n            const activeIds = currentNicheFilter.value as string[];\n            if (activeIds.length === 1) {\n                setNicheFilters(activeIds[0], trendsFilters);\n            }\n        } else if (selectedChannelId) {\n            // In ROOT or UNASSIGNED  save to channelRootFilters\n            setChannelRootFilters(selectedChannelId, trendsFilters);\n        }\n\n        // Step 2: Switch channel\n        setSelectedChannelId(channelId);\n\n        // Step 3: ALWAYS restore ROOT for target channel\n        if (selectedChannelId === channelId) {\n            // Same channel: check if coming from niche or already in ROOT\n            const wasInRealNiche = currentNicheFilter && !isUnassigned;\n            if (wasInRealNiche) {\n                // Coming from niche  restore ROOT filters\n                const rootFilters = useTrendStore.getState().channelRootFilters[channelId];\n                setTrendsFilters(rootFilters?.length > 0 ? rootFilters : []);\n            } else {\n                // Already in ROOT  reset to empty\n                setTrendsFilters([]);\n            }\n        } else {\n            // Different channel: restore ROOT filters for target channel\n            const rootFilters = useTrendStore.getState().channelRootFilters[channelId];\n            setTrendsFilters(rootFilters?.length > 0 ? rootFilters : []);\n        }\n\n        navigate('/trends');\n    };\n\n    const handleToggleVisibility = async (e: React.MouseEvent, channelId: string, currentVisibility: boolean) => {\n        e.stopPropagation();\n        if (user && currentChannel) {\n            await TrendService.toggleVisibility(user.uid, currentChannel.id, channelId, !currentVisibility);\n        }\n    };\n\n    const handleRemoveChannel = async () => {\n        if (user && currentChannel && channelToDelete) {\n            await TrendService.removeTrendChannel(user.uid, currentChannel.id, channelToDelete.id);\n            if (selectedChannelId === channelToDelete.id) {\n                setSelectedChannelId(null);\n                navigate('/trends');\n            }\n            setChannelToDelete(null);\n        }\n    };\n\n    const handleSyncChannel = async () => {\n        const channelId = menuState.channelId;\n        setMenuState({ anchorEl: null, channelId: null });\n\n        if (!user || !currentChannel || !channelId) return;\n\n        const channel = channels.find(c => c.id === channelId);\n        if (!channel) return;\n\n        if (!hasApiKey) {\n            showToast('API Key not found. Please set it in Settings.', 'error');\n            return;\n        }\n\n        // Check if this channel has a broken avatar that needs refresh\n        const brokenAvatarChannelIds = useTrendStore.getState().brokenAvatarChannelIds;\n        const needsAvatarRefresh = brokenAvatarChannelIds.has(channelId);\n\n        showToast(`Syncing all videos for ${channel.title}...`, 'success');\n\n        try {\n            // Force full sync (true) to update view counts for existing videos\n            // Also refresh avatar if it was broken\n            const { totalNewVideos, totalQuotaUsed, quotaBreakdown, newAvatarUrl } = await TrendService.syncChannelVideos(\n                user.uid,\n                currentChannel.id,\n                channel,\n                apiKey,\n                true,\n                needsAvatarRefresh\n            );\n\n            // Clear broken avatar flag if we got a new avatar\n            if (newAvatarUrl) {\n                useTrendStore.getState().clearBrokenAvatar(channelId);\n            }\n\n            showToast(`${channel.title} sync complete. Processed ${totalNewVideos} videos.`, 'success');\n\n            await addNotification({\n                title: `${channel.title} Visual Data Updated`,\n                message: `Updated ${totalNewVideos} videos.`,\n                type: 'success',\n                meta: totalQuotaUsed.toString(),\n                avatarUrl: newAvatarUrl || channel.avatarUrl,\n                quotaBreakdown\n            });\n        } catch (error: any) {\n            console.error('Sync failed:', error);\n            showToast(`Sync failed: ${error.message}`, 'error');\n        }\n    };\n\n    // Show skeleton while any loading is in progress\n    // Same pattern as Header: auth loading OR (user exists AND channels still loading)\n    const isLoading = isAuthLoading || (!!user && isChannelsLoading && !currentChannel) || isLoadingChannels;\n\n    // Background Migration: Ensure all channels have totalViewCount\n    useEffect(() => {\n        if (!user || !currentChannel || channels.length === 0) return;\n\n        channels.forEach(channel => {\n            if (channel.totalViewCount === undefined) {\n                // Determine if we should trigger migration\n                // We fire-and-forget this async task. \n                // It updates Firestore, which will push a new update to 'channels', \n                // causing this effect to re-run (but then totalViewCount will be defined).\n                console.log(`[useTrendsSidebar] Migrating stats for ${channel.title}...`);\n                TrendService.recalcChannelStats(user.uid, currentChannel.id, channel.id)\n                    .catch(err => console.error('Migration failed:', err));\n            }\n        });\n    }, [channels, user, currentChannel]);\n\n    return {\n        // State\n        channels,\n        selectedChannelId,\n        isOnTrendsPage,\n        menuState,\n        channelToDelete,\n        isLoadingChannels: isLoading,\n\n        // Actions\n        setMenuState,\n        setChannelToDelete,\n        setAddChannelModalOpen,\n\n        // Handlers\n        handleTrendsClick,\n        handleChannelClick,\n        handleToggleVisibility,\n        handleRemoveChannel,\n        handleSyncChannel\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx","messages":[{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx:133:39\n  131 |                             className=\"fixed z-[9999] bg-[#1a1a1a] border border-white/10 rounded-xl p-3 shadow-xl animate-fade-in\"\n  132 |                             style={{\n> 133 |                                 left: colorPickerRef.current?.getBoundingClientRect().left,\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  134 |                                 top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n  135 |                             }}\n  136 |                             onClick={(e) => e.stopPropagation()}","line":133,"column":39,"nodeType":null,"endLine":133,"endColumn":61},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx:133:39\n  131 |                             className=\"fixed z-[9999] bg-[#1a1a1a] border border-white/10 rounded-xl p-3 shadow-xl animate-fade-in\"\n  132 |                             style={{\n> 133 |                                 left: colorPickerRef.current?.getBoundingClientRect().left,\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  134 |                                 top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n  135 |                             }}\n  136 |                             onClick={(e) => e.stopPropagation()}","line":133,"column":39,"nodeType":null,"endLine":133,"endColumn":84},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx:133:39\n  131 |                             className=\"fixed z-[9999] bg-[#1a1a1a] border border-white/10 rounded-xl p-3 shadow-xl animate-fade-in\"\n  132 |                             style={{\n> 133 |                                 left: colorPickerRef.current?.getBoundingClientRect().left,\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^ Passing a ref to a function may read its value during render\n  134 |                                 top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n  135 |                             }}\n  136 |                             onClick={(e) => e.stopPropagation()}","line":133,"column":39,"nodeType":null,"endLine":133,"endColumn":61},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx:133:39\n  131 |                             className=\"fixed z-[9999] bg-[#1a1a1a] border border-white/10 rounded-xl p-3 shadow-xl animate-fade-in\"\n  132 |                             style={{\n> 133 |                                 left: colorPickerRef.current?.getBoundingClientRect().left,\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Passing a ref to a function may read its value during render\n  134 |                                 top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n  135 |                             }}\n  136 |                             onClick={(e) => e.stopPropagation()}","line":133,"column":39,"nodeType":null,"endLine":133,"endColumn":84},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx:134:39\n  132 |                             style={{\n  133 |                                 left: colorPickerRef.current?.getBoundingClientRect().left,\n> 134 |                                 top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  135 |                             }}\n  136 |                             onClick={(e) => e.stopPropagation()}\n  137 |                         >","line":134,"column":39,"nodeType":null,"endLine":134,"endColumn":61},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx:134:39\n  132 |                             style={{\n  133 |                                 left: colorPickerRef.current?.getBoundingClientRect().left,\n> 134 |                                 top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  135 |                             }}\n  136 |                             onClick={(e) => e.stopPropagation()}\n  137 |                         >","line":134,"column":39,"nodeType":null,"endLine":134,"endColumn":84},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx:134:39\n  132 |                             style={{\n  133 |                                 left: colorPickerRef.current?.getBoundingClientRect().left,\n> 134 |                                 top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^ Passing a ref to a function may read its value during render\n  135 |                             }}\n  136 |                             onClick={(e) => e.stopPropagation()}\n  137 |                         >","line":134,"column":39,"nodeType":null,"endLine":134,"endColumn":61},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/FloatingNicheItem.tsx:134:39\n  132 |                             style={{\n  133 |                                 left: colorPickerRef.current?.getBoundingClientRect().left,\n> 134 |                                 top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n      |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Passing a ref to a function may read its value during render\n  135 |                             }}\n  136 |                             onClick={(e) => e.stopPropagation()}\n  137 |                         >","line":134,"column":39,"nodeType":null,"endLine":134,"endColumn":84}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useLayoutEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { MoreVertical, Check, Globe } from 'lucide-react';\nimport type { TrendNiche } from '../../../core/types/trends';\nimport { useTrendStore, MANUAL_NICHE_PALETTE } from '../../../core/stores/trendStore';\nimport { ConfirmationModal } from '../../../components/Shared/ConfirmationModal';\nimport { NicheContextMenu } from '../../Trends/Shared/NicheContextMenu';\n\ninterface FloatingNicheItemProps {\n    niche: TrendNiche;\n    isAssigned: boolean;\n    isActive: boolean; // Controls whether this item's menu is open\n    isHighlighted?: boolean; // For keyboard navigation\n    onToggle: () => void;\n    onToggleMenu: () => void;\n    onCloseMenu: () => void;\n}\n\nexport const FloatingNicheItem: React.FC<FloatingNicheItemProps> = ({\n    niche,\n    isAssigned,\n    isActive,\n    isHighlighted = false,\n    onToggle,\n    onToggleMenu,\n    onCloseMenu\n}) => {\n    const { updateNiche, deleteNiche } = useTrendStore();\n    const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);\n    const [isEditing, setIsEditing] = useState(false);\n    const [editName, setEditName] = useState(niche.name);\n    const [menuPosition, setMenuPosition] = useState<{ x: number, y: number }>({ x: 0, y: 0 });\n    const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);\n\n    const menuButtonRef = useRef<HTMLButtonElement>(null);\n    const colorPickerRef = useRef<HTMLDivElement>(null);\n    const inputRef = useRef<HTMLInputElement>(null);\n\n    const PRESET_COLORS = MANUAL_NICHE_PALETTE;\n\n    const handleSaveName = () => {\n        const trimmed = editName.trim();\n        if (trimmed && trimmed !== niche.name) {\n            updateNiche(niche.id, { name: trimmed });\n        }\n        setIsEditing(false);\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n        if (e.key === 'Enter') handleSaveName();\n        if (e.key === 'Escape') {\n            setEditName(niche.name);\n            setIsEditing(false);\n        }\n    };\n\n    // Calculate menu position when opening\n    useLayoutEffect(() => {\n        if (isActive && menuButtonRef.current) {\n            const rect = menuButtonRef.current.getBoundingClientRect();\n            const MENU_WIDTH = 140; // Approx min-width\n            const GAP = 8;\n            const screenW = window.innerWidth;\n\n            // Default: position to the right\n            let left = rect.right + GAP;\n\n            // If it clips right edge, flip to left\n            if (left + MENU_WIDTH > screenW - GAP) {\n                left = rect.left - MENU_WIDTH - GAP;\n            }\n\n            setMenuPosition({\n                x: left,\n                y: rect.top\n            });\n        }\n    }, [isActive]);\n\n\n    // Close on click outside (handled partially by parent check, but good to have fallback)\n    React.useEffect(() => {\n        const handleClickOutside = (e: MouseEvent) => {\n            // Close color picker\n            if (isColorPickerOpen && colorPickerRef.current && !colorPickerRef.current.contains(e.target as Node)) {\n                setIsColorPickerOpen(false);\n            }\n        };\n\n        if (isColorPickerOpen) {\n            document.addEventListener('mousedown', handleClickOutside);\n            return () => document.removeEventListener('mousedown', handleClickOutside);\n        }\n    }, [isColorPickerOpen]);\n\n    // Focus input on edit\n    React.useEffect(() => {\n        if (isEditing && inputRef.current) {\n            inputRef.current.focus();\n            inputRef.current.select();\n        }\n    }, [isEditing]);\n\n    const isInteracting = isActive || isColorPickerOpen;\n\n    return (\n        <div\n            className={`\n                group relative w-full text-left px-3 py-2 text-xs rounded-lg flex items-center justify-between transition-colors scroll-mt-1\n                ${isAssigned ? 'text-white' : 'text-text-secondary hover:text-white'}\n                ${isInteracting ? 'bg-white/5 z-20' : isHighlighted ? 'bg-white/10 text-white' : 'hover:bg-white/5'}\n            `}\n            // Only toggle on main area click if not editing/interacting\n            onClick={() => !isEditing && !isInteracting && onToggle()}\n        >\n            <div className=\"flex items-center gap-2 flex-1 min-w-0\">\n                {/* Color Dot / Picker Trigger */}\n                <div ref={colorPickerRef} className=\"relative shrink-0\">\n                    <div\n                        role=\"button\"\n                        onClick={(e) => {\n                            e.stopPropagation();\n                            setIsColorPickerOpen(!isColorPickerOpen);\n                            onCloseMenu();\n                        }}\n                        className=\"w-2 h-2 rounded-full cursor-pointer hover:scale-125 transition-transform hover:ring-2 hover:ring-white/20\"\n                        style={{ backgroundColor: niche.color }}\n                    />\n                    {isColorPickerOpen && createPortal(\n                        <div\n                            className=\"fixed z-[9999] bg-[#1a1a1a] border border-white/10 rounded-xl p-3 shadow-xl animate-fade-in\"\n                            style={{\n                                left: colorPickerRef.current?.getBoundingClientRect().left,\n                                top: (colorPickerRef.current?.getBoundingClientRect().bottom || 0) + 8,\n                            }}\n                            onClick={(e) => e.stopPropagation()}\n                        >\n                            <div className=\"grid gap-2\" style={{ gridTemplateColumns: 'repeat(5, min-content)' }}>\n                                {PRESET_COLORS.map(color => (\n                                    <button\n                                        key={color}\n                                        onClick={() => {\n                                            updateNiche(niche.id, { color });\n                                            setIsColorPickerOpen(false);\n                                        }}\n                                        className=\"w-6 h-6 rounded-full transition-shadow relative hover:ring-2 hover:ring-white/50 ring-offset-1 ring-offset-[#1a1a1a]\"\n                                        style={{ backgroundColor: color }}\n                                    >\n                                        {niche.color === color && (\n                                            <Check size={12} className=\"absolute inset-0 m-auto text-white drop-shadow-sm\" strokeWidth={3} />\n                                        )}\n                                    </button>\n                                ))}\n                            </div>\n                        </div>,\n                        document.body\n                    )}\n                </div>\n\n                {/* Name */}\n                {isEditing ? (\n                    <input\n                        ref={inputRef}\n                        type=\"text\"\n                        value={editName}\n                        onChange={(e) => setEditName(e.target.value)}\n                        onBlur={handleSaveName}\n                        onKeyDown={handleKeyDown}\n                        onClick={(e) => e.stopPropagation()}\n                        className=\"bg-transparent border-b border-white/40 outline-none text-white w-full\"\n                    />\n                ) : (\n                    <span className=\"truncate\">{niche.name}</span>\n                )}\n\n                {niche.type === 'global' && <Globe size={10} className=\"text-text-tertiary flex-shrink-0\" />}\n            </div>\n\n            <div className=\"flex items-center gap-1\">\n                {/* Assigned Check */}\n                {isAssigned && <Check size={12} className=\"text-green-400 flex-shrink-0\" />}\n\n                {/* More Menu */}\n                <div className=\"relative\">\n                    <button\n                        ref={menuButtonRef}\n                        onClick={(e) => {\n                            e.stopPropagation();\n                            onToggleMenu();\n                            setIsColorPickerOpen(false);\n                        }}\n                        className={`\n                            p-1 rounded ml-1 transition-opacity\n                            ${isInteracting ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'}\n                            ${isActive ? 'bg-white/10' : 'hover:bg-white/10'}\n                        `}\n                    >\n                        <MoreVertical size={12} />\n                    </button>\n\n                    <NicheContextMenu\n                        niche={niche}\n                        isOpen={isActive}\n                        onClose={onCloseMenu}\n                        position={menuPosition}\n                        onRename={() => {\n                            setIsEditing(true);\n                            setEditName(niche.name);\n                            onCloseMenu();\n                        }}\n                        onDelete={() => {\n                            setIsDeleteConfirmOpen(true);\n                            onCloseMenu();\n                        }}\n                    />\n                </div>\n            </div>\n\n            <ConfirmationModal\n                isOpen={isDeleteConfirmOpen}\n                onClose={() => setIsDeleteConfirmOpen(false)}\n                onConfirm={() => {\n                    deleteNiche(niche.id);\n                    setIsDeleteConfirmOpen(false);\n                }}\n                title=\"Delete Niche\"\n                message={`Are you sure you want to delete \"${niche.name}\"? This will remove all video assignments.`}\n                confirmLabel=\"Delete\"\n            />\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimeDistributionControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineBackground.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineCanvas.tsx","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `dockFloatingBar`, but the source dependencies were []. Inferred dependency not present in source.\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineCanvas.tsx:218:47\n  216 |             if (!active) forceCloseTooltip();\n  217 |         }, [forceCloseTooltip]),\n> 218 |         onInteractionStart: React.useCallback(() => {\n      |                                               ^^^^^^^\n> 219 |             // Dock the floating bar on any interaction (zoom/pan) if we have a selection\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 220 |             dockFloatingBar();\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 221 |         }, [])\n      | ^^^^^^^^^^ Could not preserve existing manual memoization\n  222 |     });\n  223 |\n  224 |     const { isPanning, selectionRect, smoothToTransform } = interaction;","line":218,"column":47,"nodeType":null,"endLine":221,"endColumn":10},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useCallback has a missing dependency: 'dockFloatingBar'. Either include it or remove the dependency array.","line":221,"column":12,"nodeType":"ArrayExpression","endLine":221,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [dockFloatingBar]","fix":{"range":[7675,7677],"text":"[dockFloatingBar]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useEffect } from 'react';\nimport { useTrendStore } from '../../../core/stores/trendStore';\nimport { TrendTooltip } from './TrendTooltip';\nimport { TimelineDateHeader } from './TimelineDateHeader';\nimport { TimelineViewAxis } from './TimelineViewAxis';\nimport { TimelineBackground } from './TimelineBackground';\nimport { TimelineVideoLayer, type TimelineVideoLayerHandle } from './layers/TimelineVideoLayer';\nimport { TimelineDotsLayer } from './layers/TimelineDotsLayer';\nimport { TimelineControls } from './TimelineControls';\nimport { TimelineSkeleton } from './TimelineSkeleton';\nimport { TimelineEmptyState } from './TimelineEmptyState';\nimport { TimelineSelectionOverlay } from './TimelineSelectionOverlay';\nimport type { TrendVideo, TimelineStats } from '../../../core/types/trends';\nimport { TimelineAverageLine } from './layers/TimelineAverageLine';\n\n// Hooks\nimport { useTimelineStructure } from './hooks/useTimelineStructure';\nimport { useTimelinePositions } from './hooks/useTimelinePositions';\nimport { useTimelineControlHandlers } from './hooks/useTimelineControlHandlers';\nimport { useTimelineTransform } from './hooks/useTimelineTransform';\nimport { useTimelineInteraction } from './hooks/useTimelineInteraction';\nimport { useTimelineHotkeys } from './hooks/useTimelineHotkeys';\nimport { useTimelineAutoUpdate } from './hooks/useTimelineAutoUpdate';\nimport { useTimelineTooltip } from './hooks/useTimelineTooltip';\nimport { useSelectionState } from './hooks/useSelectionState';\nimport { LOD_SHOW_THUMBNAIL } from './utils/timelineConstants';\n\n// Constants\nconst HEADER_HEIGHT = 48;\nconst PADDING_LEFT = 64;\nconst PADDING_RIGHT = 12;\nconst PADDING_TOP = 12;\nconst PADDING_BOTTOM = 12;\n\n\n\nimport { TrendsFloatingBar } from './TrendsFloatingBar';\n\ninterface TimelineCanvasProps {\n    videos: TrendVideo[];\n    /** Full set of videos for current context (used for consistent density) */\n    allVideos?: TrendVideo[];\n    isLoading?: boolean;\n    percentileMap?: Map<string, string>;\n    /** Frozen stats from parent (used when shouldAutoFit is false) */\n    frozenStats?: TimelineStats;\n    /** Real-time stats from parent (used for initial fit) */\n    currentStats?: TimelineStats;\n    /** If true, calculate stats from videos; if false, use frozenStats */\n    shouldAutoFit?: boolean;\n    onRequestStatsRefresh?: () => void;\n    /** If true, skip auto-fit on next structure update (for filterMode toggle) */\n    skipAutoFitRef?: React.RefObject<boolean>;\n    filterHash?: string;\n    /** True when on main page and all channels have visibility toggled off */\n    allChannelsHidden?: boolean;\n}\n\nexport const TimelineCanvas: React.FC<TimelineCanvasProps> = ({\n    videos,\n    allVideos = [],\n    isLoading = false,\n    percentileMap,\n    frozenStats,\n    currentStats,\n    shouldAutoFit = false,\n    onRequestStatsRefresh,\n    skipAutoFitRef,\n    filterHash,\n    allChannelsHidden = false\n}) => {\n    const { timelineConfig, setTimelineConfig, setAddChannelModalOpen, clearTrendsFilters, savedConfigs, saveConfigForHash } = useTrendStore();\n    const { scalingMode, verticalSpread, timeLinearity, showAverageBaseline } = timelineConfig;\n\n    // Determine effective stats for triggering updates. \n    // In Filtered mode (shouldAutoFit=true), we use undefined to signal real-time Scaling.\n    // In Global/Stable mode, we use frozenStats to detect context shifts.\n    const triggeringStats = shouldAutoFit ? undefined : frozenStats;\n\n    // 1. Structure Auto-Update Logic\n    const { structureVersion, forceStructureUpdate, shouldAutoFit: hookShouldAutoFit } = useTimelineAutoUpdate({\n        videos,\n        forcedStats: triggeringStats,\n        skipAutoFitRef,\n        filterHash\n    });\n\n    // Determine stats specifically for current structure calculation.\n    // If we are currently triggering a fit (hookShouldAutoFit), we MUST use currentStats \n    // to ensure the jump is accurate, even if we are in a \"frozen\" context.\n    const statsForStructure = (shouldAutoFit || hookShouldAutoFit) ? currentStats : frozenStats;\n\n    // 2. Structure Logic\n    const {\n        worldWidth,\n        stats,\n        monthLayouts,\n        monthRegions,\n        yearMarkers\n    } = useTimelineStructure({\n        videos,\n        allVideos,\n        stats: statsForStructure,\n        structureVersion,\n        timeLinearity,\n        isFrozen: !shouldAutoFit\n    });\n\n    // 3. Selection State (Moved up for Tooltip dependency)\n    const {\n        selectionState,\n        handleVideoClick,\n        clearSelection,\n        dockFloatingBar\n    } = useSelectionState();\n\n    // 4. Tooltip Logic\n    const {\n        hoveredVideo,\n        isTooltipClosing,\n        handleHoverVideo,\n        handleTooltipMouseEnter,\n        handleTooltipMouseLeave,\n        forceCloseTooltip\n    } = useTimelineTooltip({\n        // If we have selected videos, we delay the tooltip show\n        delayShowCondition: selectionState.selectedIds.size > 0\n    });\n\n    const selectedVideos = React.useMemo(() => {\n        return videos.filter(v => selectionState.selectedIds.has(v.id));\n    }, [videos, selectionState.selectedIds]);\n\n    const floatingBarPosition = React.useMemo(() => {\n        if (selectionState.selectedIds.size === 0 || !selectionState.lastAnchor) return { x: 0, y: 0 };\n        return selectionState.lastAnchor;\n    }, [selectionState.lastAnchor, selectionState.selectedIds.size]);\n\n    // Track if FloatingBar has an active dropdown (for hotkey handling)\n    const [hasActiveDropdown, setHasActiveDropdown] = React.useState(false);\n\n\n    // 5. Transform & Interaction\n    const {\n        containerRef,\n        containerSizeRef,\n        transformState,\n        transformRef,\n        setTransformState,\n        clampTransform,\n        minScale,\n        dynamicWorldHeight,\n        anchorToTime,\n        calculateAutoFitTransform,\n        currentContentHash\n    } = useTimelineTransform({\n        worldWidth,\n        headerHeight: HEADER_HEIGHT,\n        paddingLeft: PADDING_LEFT,\n        paddingRight: PADDING_RIGHT,\n        paddingTop: PADDING_TOP,\n        paddingBottom: PADDING_BOTTOM,\n        videosLength: videos.length,\n        monthLayouts,\n        stats\n    });\n\n    // 6. Data Positions\n    const {\n        videoPositions,\n        getPercentileGroup\n    } = useTimelinePositions({\n        videos,\n        stats,\n        monthLayouts,\n        scalingMode,\n        verticalSpread,\n        dynamicWorldHeight,\n        percentileMap\n    });\n\n    // 7. Control Handlers (Smart Focus)\n    const {\n        handleSpreadChange,\n        handleSpreadDragStart,\n        handleSpreadDragEnd,\n        handleTimeLinearityChange,\n        handleTimeDragStart,\n        handleTimeDragEnd\n    } = useTimelineControlHandlers({\n        transformState,\n        containerSizeRef,\n        minScale,\n        videoPositions,\n        worldWidth,\n        dynamicWorldHeight,\n        stats,\n        monthLayouts,\n        setTimelineConfig,\n        setTransformState,\n        anchorToTime,\n        verticalSpread: verticalSpread ?? 1.0\n    });\n    const videoLayerRef = useRef<TimelineVideoLayerHandle>(null);\n\n    // 8. Main Interaction Hook\n    const interaction = useTimelineInteraction({\n        containerRef,\n        videoLayerRef,\n        transformRef,\n        minScale,\n        containerSizeRef,\n        setTransformState,\n        clampTransform,\n        onHoverVideo: React.useCallback((active: boolean) => {\n            if (!active) forceCloseTooltip();\n        }, [forceCloseTooltip]),\n        onInteractionStart: React.useCallback(() => {\n            // Dock the floating bar on any interaction (zoom/pan) if we have a selection\n            dockFloatingBar();\n        }, [])\n    });\n\n    const { isPanning, selectionRect, smoothToTransform } = interaction;\n    // 9. Manual Fit / Auto Fit Logic\n    const appliedStructureVersionRef = useRef(0);\n    const shouldAutoFitRef = useRef(false);\n\n    const handleSmoothFit = () => {\n        forceCloseTooltip();\n        onRequestStatsRefresh?.();\n        forceStructureUpdate(true); // Explicitly request fit\n        shouldAutoFitRef.current = true;\n    };\n\n    // Effect to trigger Auto-Fit when structure updates explicitly\n    // WHY: This uses smoothToTransform (animated) for manual reset (double-click/hotkey).\n    // Contrast: useTimelineTransform uses instant setTransformState for hash changes.\n    // We skip auto-fit if savedConfigs exists (Miro-like: restore saved position instead).\n    useEffect(() => {\n        if (structureVersion > 0 && structureVersion > appliedStructureVersionRef.current) {\n            appliedStructureVersionRef.current = structureVersion;\n\n            // Use declarative flag from hook OR manual override\n            // MIRO-LIKE FIX: If we have a saved config, ignore the hook's auto-fit request (which happens on load),\n            // unless it's a manual override (shouldAutoFitRef).\n            const hasSavedState = !!savedConfigs[currentContentHash];\n            const canFit = shouldAutoFitRef.current || (hookShouldAutoFit && !hasSavedState);\n\n            if (canFit) {\n                const fitTransform = calculateAutoFitTransform();\n                if (fitTransform) {\n                    smoothToTransform(fitTransform);\n                    const configUpdate = {\n                        zoomLevel: fitTransform.scale,\n                        offsetX: fitTransform.offsetX,\n                        offsetY: fitTransform.offsetY,\n                        contentHash: currentContentHash\n                    };\n                    setTimelineConfig(configUpdate);\n                    // Persist immediately to savedConfigs (fixes Z key not saving)\n                    saveConfigForHash(currentContentHash, configUpdate);\n                }\n            }\n            shouldAutoFitRef.current = false;\n        }\n    }, [structureVersion, hookShouldAutoFit, calculateAutoFitTransform, smoothToTransform, setTimelineConfig, currentContentHash, savedConfigs, saveConfigForHash]);\n\n    // Hotkeys (Standard)\n    useTimelineHotkeys({\n        onAutoFit: handleSmoothFit,\n        onEscape: clearSelection,\n        hasActiveDropdown\n    });\n\n    // 10. Global Hotkeys (Cmd+Shift+L to clear)\n    useEffect(() => {\n        const handleKeyDown = (e: KeyboardEvent) => {\n            const isCmdShiftL = (e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'l';\n\n            if (isCmdShiftL) {\n                e.preventDefault();\n                clearSelection();\n            }\n        };\n\n        window.addEventListener('keydown', handleKeyDown);\n        return () => window.removeEventListener('keydown', handleKeyDown);\n    }, [clearSelection]);\n\n    // Determine visibility logic\n    const showThumbnails = transformState.scale >= LOD_SHOW_THUMBNAIL;\n\n    // Determine if pan is available (not at fit-in state)\n    const canPan = transformState.scale > minScale * 1.01; // Small buffer for floating point comparison\n\n    return (\n        <div\n            ref={containerRef}\n            className=\"w-full h-[calc(100vh-56px)] flex flex-col bg-bg-primary overflow-hidden relative select-none\"\n            style={{ cursor: isPanning ? 'grabbing' : (canPan ? 'grab' : 'default') }}\n            onMouseDown={interaction.handleMouseDown}\n            onMouseMove={interaction.handleMouseMove}\n            onMouseUp={interaction.handleMouseUp}\n            onMouseLeave={interaction.handleMouseUp}\n            onDoubleClick={handleSmoothFit}\n        // onClick removed for background clearing. Selection persists until explicitly cleared (X or Cmd+L).\n        >\n            {/* Subtle Vertical Gradient Overlay */}\n            <div className=\"absolute inset-0 pointer-events-none bg-gradient-to-b from-text-primary/[0.02] to-transparent\" />\n\n            {/* 1. Background (Bottom Layer) */}\n            {!isLoading && videos.length > 0 && (\n                <TimelineBackground\n                    monthRegions={monthRegions}\n                    transform={transformState}\n                    worldWidth={worldWidth}\n                    timeLinearity={timeLinearity ?? 1.0}\n                />\n            )}\n\n            {/* 1.5. Average Baseline Layer (Optional) */}\n            {showAverageBaseline && stats && !isLoading && (\n                <TimelineAverageLine\n                    videos={videos}\n                    stats={stats}\n                    scalingMode={scalingMode}\n                    verticalSpread={verticalSpread ?? 1.0}\n                    dynamicWorldHeight={dynamicWorldHeight}\n                    transform={transformState}\n                    baselineMode={timelineConfig.baselineMode}\n                    baselineWindowSize={timelineConfig.baselineWindowSize} // Added\n                    worldWidth={worldWidth}\n                    monthLayouts={monthLayouts}\n                />\n            )}\n\n            {/* 2. Video Content (Middle Layer) */}\n\n            {/* Optimized Canvas Layer for Zoomed Out State */}\n            {!isLoading && !showThumbnails && (\n                <TimelineDotsLayer\n                    videoPositions={videoPositions}\n                    transform={transformState}\n                    worldWidth={worldWidth}\n                    worldHeight={dynamicWorldHeight}\n                    activeVideoIds={selectionState.selectedIds}\n                    getPercentileGroup={getPercentileGroup}\n                    verticalSpread={verticalSpread}\n                    onHoverVideo={handleHoverVideo}\n                    onClickVideo={(video, e) => {\n                        forceCloseTooltip();\n                        handleVideoClick(video, e.clientX, e.clientY, e.metaKey || e.ctrlKey);\n                    }}\n                    onDoubleClickVideo={(_video, worldX, worldY, e) => {\n                        // Only zoom on Cmd/Ctrl + Double-Click (Figma-style)\n                        const isModifier = e.metaKey || e.ctrlKey;\n                        if (isModifier) {\n                            forceCloseTooltip();\n                            interaction.zoomToPoint(worldX, worldY, 1.0);\n                        }\n                    }}\n                    onClickEmpty={() => {\n                        clearSelection();\n                    }}\n                />\n            )}\n\n            {/* DOM Layer for Zoomed In State (Thumbnails) */}\n            <TimelineVideoLayer\n                ref={videoLayerRef}\n                videoPositions={videoPositions}\n                transform={transformState}\n                worldWidth={worldWidth}\n                worldHeight={dynamicWorldHeight}\n                activeVideoIds={selectionState.selectedIds}\n                style={{\n                    opacity: isLoading ? 0 : 1,\n                    transition: 'opacity 0.3s ease'\n                } as React.CSSProperties}\n                getPercentileGroup={getPercentileGroup}\n                isLoading={isLoading}\n                isHidden={!showThumbnails}\n                onHoverVideo={handleHoverVideo}\n                onDoubleClickVideo={(_video, worldX, worldY, e) => {\n                    // Only zoom on Cmd/Ctrl + Double-Click (Figma-style)\n                    const isModifier = e.metaKey || e.ctrlKey;\n                    if (isModifier) {\n                        forceCloseTooltip();\n                        interaction.zoomToPoint(worldX, worldY, 1.0);\n                    }\n                }}\n                onClickVideo={(video, e) => {\n                    const PAN_COOLDOWN_MS = 200;\n                    if (Date.now() - interaction.lastPanEndTimeRef.current < PAN_COOLDOWN_MS) {\n                        return; // Ignore click if we just finished panning\n                    }\n\n                    forceCloseTooltip();\n                    handleVideoClick(video, e.clientX, e.clientY, e.metaKey || e.ctrlKey);\n                }}\n            />\n\n            {/* Empty State (visible regardless of zoom level) */}\n            {!isLoading && videos.length === 0 && (\n                <TimelineEmptyState\n                    variant={allChannelsHidden ? 'channels-hidden' : (allVideos?.length ?? 0) > 0 ? 'filtered' : 'no-data'}\n                    onAddChannels={() => setAddChannelModalOpen(true)}\n                    onClearFilters={clearTrendsFilters}\n                />\n            )}\n\n            {/* 3. Headers & UI Overlays (Top Layer) */}\n            {isLoading ? (\n                <TimelineSkeleton />\n            ) : videos.length > 0 ? (\n                <>\n                    <div className=\"absolute top-0 left-0 right-0 z-10 pointer-events-none\">\n                        <div className=\"pointer-events-auto\">\n                            <TimelineDateHeader\n                                yearMarkers={yearMarkers}\n                                monthRegions={monthRegions}\n                                transform={transformState}\n                                worldWidth={worldWidth}\n                            />\n                        </div>\n                    </div>\n\n                    <TimelineViewAxis\n                        stats={stats}\n                        scalingMode={scalingMode}\n                        verticalSpread={verticalSpread}\n                        dynamicWorldHeight={dynamicWorldHeight}\n                        transform={transformState}\n                        style={{ top: HEADER_HEIGHT }}\n                    />\n                </>\n            ) : null}\n\n            <TimelineSelectionOverlay selectionRect={selectionRect} />\n\n            <TimelineControls\n                scale={transformState.scale}\n                minScale={minScale}\n                onReset={handleSmoothFit}\n                verticalSpread={verticalSpread ?? 1.0}\n                onSpreadChange={handleSpreadChange}\n                onSpreadDragStart={handleSpreadDragStart}\n                onSpreadDragEnd={handleSpreadDragEnd}\n                timeLinearity={timeLinearity ?? 1.0}\n                onTimeLinearityChange={handleTimeLinearityChange}\n                onTimeDragStart={handleTimeDragStart}\n                onTimeDragEnd={handleTimeDragEnd}\n                isLoading={isLoading}\n            />\n\n            {/* Check hoveredVideo vs selectedVideos to avoid tooltip overlap */}\n            {hoveredVideo && !selectionState.selectedIds.has(hoveredVideo.video.id) && (\n                <TrendTooltip\n                    key={hoveredVideo.video.id}\n                    video={hoveredVideo.video}\n                    anchorPos={{\n                        x: hoveredVideo.x,\n                        y: hoveredVideo.y,\n                        width: hoveredVideo.width,\n                        height: hoveredVideo.height\n                    }}\n                    isClosing={isTooltipClosing}\n                    onMouseEnter={handleTooltipMouseEnter}\n                    onMouseLeave={handleTooltipMouseLeave}\n                    percentileGroup={getPercentileGroup(hoveredVideo.video.id)}\n                />\n            )}\n\n            {/* Floating Bar with Smart Positioning */}\n            <div className=\"transition-opacity duration-200 opacity-100\">\n                {selectedVideos.length > 0 && (\n                    <TrendsFloatingBar\n                        videos={selectedVideos}\n                        position={floatingBarPosition}\n                        onClose={clearSelection}\n                        isDocked={selectionState.hasDocked}\n                        onActiveMenuChange={setHasActiveDropdown}\n                    />\n                )}\n            </div>\n        </div>\n    );\n};\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineDateHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineEmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineSelectionOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TimelineViewAxis.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TrendTooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/TrendsFloatingBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/VerticalSpreadControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/components/ControlPill.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/components/NicheSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/components/PlaylistSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useAxisTicks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenStats.ts","messages":[{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenStats.ts:72:9\n  70 |     if (selectedChannelId !== prevChannelForReset) {\n  71 |         setPrevChannelForReset(selectedChannelId);\n> 72 |         frozenStatsRef.current = undefined;\n     |         ^^^^^^^^^^^^^^^^^^^^^^ Cannot update ref during render\n  73 |         // Skip first freeze when switching to main Trends (first render has stale data)\n  74 |         if (selectedChannelId === null) {\n  75 |             skipNextFreezeRef.current = true;","line":72,"column":9,"nodeType":null,"endLine":72,"endColumn":31},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenStats.ts:75:13\n  73 |         // Skip first freeze when switching to main Trends (first render has stale data)\n  74 |         if (selectedChannelId === null) {\n> 75 |             skipNextFreezeRef.current = true;\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot update ref during render\n  76 |         }\n  77 |     }\n  78 |","line":75,"column":13,"nodeType":null,"endLine":75,"endColumn":38},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenStats.ts:136:12\n  134 |     const shouldAutoFit = filterMode !== 'global' && !hasUnassignedFilter;\n  135 |\n> 136 |     return useMemo(() => ({\n      |            ^^^^^^^^^^^^^^^^\n> 137 |         currentStats,\n      | ^^^^^^^^^^^^^^^^^^^^^\n> 138 |         frozenStats: frozenStatsRef.current,\n      | ^^^^^^^^^^^^^^^^^^^^^\n> 139 |         shouldAutoFit,\n      | ^^^^^^^^^^^^^^^^^^^^^\n> 140 |         refreshStats,\n      | ^^^^^^^^^^^^^^^^^^^^^\n> 141 |         skipAutoFitRef\n      | ^^^^^^^^^^^^^^^^^^^^^\n> 142 |     }), [currentStats, shouldAutoFit, refreshStats, statsVersion]);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  143 | };\n  144 |","line":136,"column":12,"nodeType":null,"endLine":142,"endColumn":67},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenStats.ts:138:22\n  136 |     return useMemo(() => ({\n  137 |         currentStats,\n> 138 |         frozenStats: frozenStatsRef.current,\n      |                      ^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  139 |         shouldAutoFit,\n  140 |         refreshStats,\n  141 |         skipAutoFitRef","line":138,"column":22,"nodeType":null,"endLine":138,"endColumn":44},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'statsVersion'. Either exclude it or remove the dependency array.","line":142,"column":9,"nodeType":"ArrayExpression","endLine":142,"endColumn":66,"suggestions":[{"desc":"Update the dependencies array to be: [currentStats, shouldAutoFit, refreshStats]","fix":{"range":[5447,5504],"text":"[currentStats, shouldAutoFit, refreshStats]"}}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useMemo, useEffect, useCallback } from 'react';\nimport type { TimelineStats, TrendVideo } from '../../../../core/types/trends';\n\ninterface ChannelBasic {\n    id: string;\n}\n\ninterface UseFrozenStatsProps {\n    /** All videos for current context (Global mode stats source) */\n    allVideos: TrendVideo[];\n    /** Filtered videos (Filtered mode stats source, always used for display) */\n    filteredVideos: TrendVideo[];\n    channels: ChannelBasic[];\n    selectedChannelId: string | null;\n    filterMode: 'global' | 'filtered';\n    /** True when UNASSIGNED filter is active */\n    hasUnassignedFilter?: boolean;\n    /** Current combined filter hash (to detect all filter changes) */\n    filterHash?: string;\n}\n\n/** Computes min/max stats from a set of videos */\nconst computeStats = (videos: TrendVideo[]): TimelineStats | undefined => {\n    if (videos.length === 0) return undefined;\n    const viewCounts = videos.map(v => v.viewCount);\n    const dates = videos.map(v => v.publishedAtTimestamp);\n    const buffer = 1000 * 60 * 60 * 12; // 12h buffer\n    return {\n        minViews: Math.max(1, Math.min(...viewCounts)),\n        maxViews: Math.max(1, Math.max(...viewCounts)),\n        minDate: Math.min(...dates) - buffer,\n        maxDate: Math.max(...dates) + buffer\n    };\n};\n\n/**\n * Manages \"frozen\" timeline stats that only update on explicit triggers:\n * - Initial page load\n * - Z key / revert\n * - Channel add/remove\n * - Filter mode change\n * - Filter hash change (applying any filter)\n * \n * Also stays frozen when UNASSIGNED filter is active, so videos can be\n * assigned to niches without the timeline jumping.\n */\nexport const useFrozenStats = ({\n    allVideos,\n    filteredVideos,\n    channels,\n    selectedChannelId,\n    filterMode,\n    hasUnassignedFilter = false,\n    filterHash\n}: UseFrozenStatsProps) => {\n    const frozenStatsRef = useRef<TimelineStats | undefined>(undefined);\n    const [statsVersion, setStatsVersion] = useState(0);\n\n    const channelIdsKey = useMemo(() => channels.map(c => c.id).sort().join(','), [channels]);\n\n    const prevChannelIdsKeyRef = useRef(channelIdsKey);\n    const prevFilterModeRef = useRef(filterMode);\n    const prevFilterHashRef = useRef(filterHash);\n    const prevAllCountRef = useRef(allVideos.length);\n    const skipAutoFitRef = useRef(false);\n    const skipNextFreezeRef = useRef(false);\n\n    // Channel switch reset (derived state pattern)\n    const [prevChannelForReset, setPrevChannelForReset] = useState(selectedChannelId);\n    if (selectedChannelId !== prevChannelForReset) {\n        setPrevChannelForReset(selectedChannelId);\n        frozenStatsRef.current = undefined;\n        // Skip first freeze when switching to main Trends (first render has stale data)\n        if (selectedChannelId === null) {\n            skipNextFreezeRef.current = true;\n        }\n    }\n\n    // Stats source selection based on context\n    // Any filter (niche, dates, views) in \"Filtered\" mode should cause timeline to fit filtered set.\n    // In \"Global\" mode, we always use the full set (allVideos, which is already scoped to selected channel).\n    const statsSourceVideos = useMemo(() => {\n        return filterMode === 'global' ? allVideos : filteredVideos;\n    }, [filterMode, allVideos, filteredVideos]);\n\n    const currentStats = useMemo(() => computeStats(statsSourceVideos), [statsSourceVideos]);\n\n    // Auto-refresh logic (Frozen Stats Management)\n    useEffect(() => {\n        const channelListChanged = prevChannelIdsKeyRef.current !== channelIdsKey;\n        prevChannelIdsKeyRef.current = channelIdsKey;\n\n        const filterModeChanged = prevFilterModeRef.current !== filterMode;\n        prevFilterModeRef.current = filterMode;\n\n        const filterHashChanged = prevFilterHashRef.current !== filterHash;\n        prevFilterHashRef.current = filterHash;\n\n        prevAllCountRef.current = allVideos.length;\n\n        // Auto-refresh frozen stats if:\n        // 1. No stats yet\n        // 2. Fundamental context changed (channel list, filter mode)\n        // 3. ANY filter changed (hash changed - dates, views, niches)\n        const shouldAutoRefresh =\n            !frozenStatsRef.current ||\n            channelListChanged ||\n            filterModeChanged ||\n            filterHashChanged;\n\n        const isFilterModeToggleOnly = filterModeChanged && !channelListChanged && !filterHashChanged;\n\n        if (shouldAutoRefresh) {\n            if (skipNextFreezeRef.current) {\n                skipNextFreezeRef.current = false;\n            } else {\n                frozenStatsRef.current = currentStats;\n                setStatsVersion(v => v + 1);\n            }\n        }\n\n        skipAutoFitRef.current = isFilterModeToggleOnly;\n    }, [currentStats, channelIdsKey, filterMode, filterHash, allVideos.length]);\n\n    // Manual refresh callback (Z key)\n    const refreshStats = useCallback(() => {\n        frozenStatsRef.current = currentStats;\n        skipAutoFitRef.current = false;\n        setStatsVersion(v => v + 1);\n    }, [currentStats]);\n\n    // Explicit flag: filtered mode should auto-fit, global mode uses frozen stats\n    // Exception: UNASSIGNED filter should stay frozen (   assign,  )\n    const shouldAutoFit = filterMode !== 'global' && !hasUnassignedFilter;\n\n    return useMemo(() => ({\n        currentStats,\n        frozenStats: frozenStatsRef.current,\n        shouldAutoFit,\n        refreshStats,\n        skipAutoFitRef\n    }), [currentStats, shouldAutoFit, refreshStats, statsVersion]);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[77,80],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[77,80],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[762,765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[762,765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:36:9\n  34 |     let needsUpdate = false;\n  35 |\n> 36 |     if (!prevEntry || !prevEntry.initialized) {\n     |         ^^^^^^^^^^ Cannot access ref value during render\n  37 |         needsUpdate = true;\n  38 |     } else if (prevEntry.version !== version) {\n  39 |         needsUpdate = true;","line":36,"column":9,"nodeType":null,"endLine":36,"endColumn":19},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:36:9\n  34 |     let needsUpdate = false;\n  35 |\n> 36 |     if (!prevEntry || !prevEntry.initialized) {\n     |         ^^^^^^^^^^ Cannot access ref value during render\n  37 |         needsUpdate = true;\n  38 |     } else if (prevEntry.version !== version) {\n  39 |         needsUpdate = true;","line":36,"column":9,"nodeType":null,"endLine":36,"endColumn":19},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:36:9\n  34 |     let needsUpdate = false;\n  35 |\n> 36 |     if (!prevEntry || !prevEntry.initialized) {\n     |         ^^^^^^^^^^ Cannot access ref value during render\n  37 |         needsUpdate = true;\n  38 |     } else if (prevEntry.version !== version) {\n  39 |         needsUpdate = true;","line":36,"column":9,"nodeType":null,"endLine":36,"endColumn":19},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:36:10\n  34 |     let needsUpdate = false;\n  35 |\n> 36 |     if (!prevEntry || !prevEntry.initialized) {\n     |          ^^^^^^^^^ Cannot access ref value during render\n  37 |         needsUpdate = true;\n  38 |     } else if (prevEntry.version !== version) {\n  39 |         needsUpdate = true;\n\nTo initialize a ref only once, check that the ref is null with the pattern `if (ref.current == null) { ref.current = ... }`","line":36,"column":10,"nodeType":null,"endLine":36,"endColumn":19},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:36:24\n  34 |     let needsUpdate = false;\n  35 |\n> 36 |     if (!prevEntry || !prevEntry.initialized) {\n     |                        ^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  37 |         needsUpdate = true;\n  38 |     } else if (prevEntry.version !== version) {\n  39 |         needsUpdate = true;","line":36,"column":24,"nodeType":null,"endLine":36,"endColumn":45},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:38:16\n  36 |     if (!prevEntry || !prevEntry.initialized) {\n  37 |         needsUpdate = true;\n> 38 |     } else if (prevEntry.version !== version) {\n     |                ^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  39 |         needsUpdate = true;\n  40 |     } else if (shouldUpdate) {\n  41 |         // Custom update logic if provided","line":38,"column":16,"nodeType":null,"endLine":38,"endColumn":33},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:43:13\n  41 |         // Custom update logic if provided\n  42 |         needsUpdate = shouldUpdate(\n> 43 |             { value: prevEntry.value, version: prevEntry.version, dependencies: prevEntry.dependencies },\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Passing a ref to a function may read its value during render\n  44 |             { value, version, dependencies: currentDeps }\n  45 |         );\n  46 |     } else {","line":43,"column":13,"nodeType":null,"endLine":43,"endColumn":105},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:43:22\n  41 |         // Custom update logic if provided\n  42 |         needsUpdate = shouldUpdate(\n> 43 |             { value: prevEntry.value, version: prevEntry.version, dependencies: prevEntry.dependencies },\n     |                      ^^^^^^^^^^^^^^^ Cannot access ref value during render\n  44 |             { value, version, dependencies: currentDeps }\n  45 |         );\n  46 |     } else {","line":43,"column":22,"nodeType":null,"endLine":43,"endColumn":37},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:43:48\n  41 |         // Custom update logic if provided\n  42 |         needsUpdate = shouldUpdate(\n> 43 |             { value: prevEntry.value, version: prevEntry.version, dependencies: prevEntry.dependencies },\n     |                                                ^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  44 |             { value, version, dependencies: currentDeps }\n  45 |         );\n  46 |     } else {","line":43,"column":48,"nodeType":null,"endLine":43,"endColumn":65},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:43:81\n  41 |         // Custom update logic if provided\n  42 |         needsUpdate = shouldUpdate(\n> 43 |             { value: prevEntry.value, version: prevEntry.version, dependencies: prevEntry.dependencies },\n     |                                                                                 ^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  44 |             { value, version, dependencies: currentDeps }\n  45 |         );\n  46 |     } else {","line":43,"column":81,"nodeType":null,"endLine":43,"endColumn":103},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:49:13\n  47 |         // Default dependency check: shallow compare if array length matches\n  48 |         // (Though usually we rely on version for the heavy lifting here as per original code pattern)\n> 49 |         if (prevEntry.dependencies.length !== currentDeps.length) {\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  50 |             needsUpdate = true;\n  51 |         } else {\n  52 |             // Simple shallow equality check for deps","line":49,"column":13,"nodeType":null,"endLine":49,"endColumn":42},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:54:21\n  52 |             // Simple shallow equality check for deps\n  53 |             for (let i = 0; i < currentDeps.length; i++) {\n> 54 |                 if (prevEntry.dependencies[i] !== currentDeps[i]) {\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  55 |                     needsUpdate = true;\n  56 |                     break;\n  57 |                 }","line":54,"column":21,"nodeType":null,"endLine":54,"endColumn":46},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:72:9\n  70 |\n  71 |     if (needsUpdate) {\n> 72 |         ref.current = {\n     |         ^^^^^^^^^^^ Cannot update ref during render\n  73 |             version,\n  74 |             value,\n  75 |             dependencies: currentDeps,","line":72,"column":9,"nodeType":null,"endLine":72,"endColumn":20},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useFrozenValue.ts:80:12\n  78 |     }\n  79 |\n> 80 |     return ref.current!.value;\n     |            ^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  81 | }\n  82 |","line":80,"column":12,"nodeType":null,"endLine":80,"endColumn":30}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef } from 'react';\n\ninterface UseFrozenValueParams<T, D extends any[] = []> {\n    value: T;\n    version: number;\n    dependencies?: D;\n    shouldUpdate?: (prev: { value: T; version: number; dependencies: D }, next: { value: T; version: number; dependencies: D }) => boolean;\n}\n\n/**\n * A hook that holds onto a value and only updates it when the version changes, \n * or optionally when other dependencies change, relative to the last \"frozen\" state.\n * \n * This is useful when we calculate a heavy object (like a layout structure) and want to \n * keep returning the *same instance* even if the inputs technically change, unless \n * a specific \"version\" signal (like a force-update counter) increments.\n */\nexport function useFrozenValue<T, D extends any[] = []>({\n    value,\n    version,\n    dependencies = [] as unknown as D,\n    shouldUpdate\n}: UseFrozenValueParams<T, D>): T {\n    const ref = useRef<{\n        version: number;\n        value: T;\n        dependencies: D;\n        initialized: boolean;\n    } | null>(null);\n\n    const currentDeps = dependencies;\n    const prevEntry = ref.current;\n\n    let needsUpdate = false;\n\n    if (!prevEntry || !prevEntry.initialized) {\n        needsUpdate = true;\n    } else if (prevEntry.version !== version) {\n        needsUpdate = true;\n    } else if (shouldUpdate) {\n        // Custom update logic if provided\n        needsUpdate = shouldUpdate(\n            { value: prevEntry.value, version: prevEntry.version, dependencies: prevEntry.dependencies },\n            { value, version, dependencies: currentDeps }\n        );\n    } else {\n        // Default dependency check: shallow compare if array length matches\n        // (Though usually we rely on version for the heavy lifting here as per original code pattern)\n        if (prevEntry.dependencies.length !== currentDeps.length) {\n            needsUpdate = true;\n        } else {\n            // Simple shallow equality check for deps\n            for (let i = 0; i < currentDeps.length; i++) {\n                if (prevEntry.dependencies[i] !== currentDeps[i]) {\n                    needsUpdate = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Special case from original code: specific overrides like \"wasEmpty\" check\n    // Logic: If the previous value was generated from \"empty data\" but now we have data, update.\n    // We can handle this by letting the caller pass `dependencies` that include `data.length > 0`.\n    // Or we implicitly update if the *value* seems \"initialized\" vs \"uninitialized\".\n\n    // BUT the original code used specific refs like `frozenWorldWidthRef`.\n    // Let's stick effectively to the pattern:\n    // If version changed OR dependencies changed -> Update.\n\n    if (needsUpdate) {\n        ref.current = {\n            version,\n            value,\n            dependencies: currentDeps,\n            initialized: true\n        };\n    }\n\n    return ref.current!.value;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useSelectionState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useSmartPosition.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useSmartPosition.ts:58:9\n  56 |         }\n  57 |\n> 58 |         setCoords({ x: left, y: top });\n     |         ^^^^^^^^^ Avoid calling setState() directly within an effect\n  59 |         setIsBelow(below);\n  60 |\n  61 |     }, [targetPos.x, targetPos.y, elementRef, padding, offsetY, initialWidth]);","line":58,"column":9,"nodeType":null,"endLine":58,"endColumn":18},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useLayoutEffect has a missing dependency: 'targetPos'. Either include it or remove the dependency array.","line":61,"column":8,"nodeType":"ArrayExpression","endLine":61,"endColumn":78,"suggestions":[{"desc":"Update the dependencies array to be: [targetPos.x, targetPos.y, elementRef, padding, offsetY, initialWidth, targetPos]","fix":{"range":[1868,1938],"text":"[targetPos.x, targetPos.y, elementRef, padding, offsetY, initialWidth, targetPos]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useLayoutEffect, type RefObject } from 'react';\n\ninterface Position {\n    x: number;\n    y: number;\n}\n\ninterface SmartPositionOptions {\n    targetPos: Position;\n    elementRef: RefObject<HTMLElement | null>;\n    width: number; // Approximate width if ref not ready, or for initial guess\n    height?: number;\n    padding?: number;\n    offsetY?: number; // Distance from target y\n}\n\nexport const useSmartPosition = ({\n    targetPos,\n    elementRef,\n    width: initialWidth, // Fallback\n    padding = 16,\n    offsetY = 60\n}: SmartPositionOptions) => {\n    const [coords, setCoords] = useState<Position>(targetPos);\n    const [isBelow, setIsBelow] = useState(false); // Whether we flipped to below\n\n    useLayoutEffect(() => {\n        if (!elementRef.current) return;\n\n        const width = elementRef.current.offsetWidth || initialWidth;\n        const height = elementRef.current.offsetHeight || 40;\n        const { x, y } = targetPos;\n        const screenWidth = window.innerWidth;\n        const screenHeight = window.innerHeight;\n\n        // X Axis: Center on target, but clamp\n        let left = x - width / 2;\n        if (left < padding) left = padding;\n        else if (left + width > screenWidth - padding) left = screenWidth - padding - width;\n\n        // Y Axis: Default above\n        let top = y - offsetY;\n        let below = false;\n\n        // Check if clipped top\n        if (top < padding) {\n            // Try below\n            const belowTop = y + 40; // Approx dot height buffer\n            if (belowTop + height < screenHeight - padding) {\n                top = belowTop;\n                below = true;\n            } else {\n                // Determine which has more space or clamp to top\n                top = Math.max(padding, top);\n            }\n        }\n\n        setCoords({ x: left, y: top });\n        setIsBelow(below);\n\n    }, [targetPos.x, targetPos.y, elementRef, padding, offsetY, initialWidth]);\n\n    return { coords, isBelow };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useSmoothDrag.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineAutoUpdate.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineAutoUpdate.ts:52:13\n  50 |             const shouldFit = hasHashChanged ? true : !isSkipRequested;\n  51 |\n> 52 |             setShouldAutoFit(shouldFit);\n     |             ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  53 |             setStructureVersion(v => v + 1);\n  54 |             return;\n  55 |         }","line":52,"column":13,"nodeType":null,"endLine":52,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useEffect, useCallback } from 'react';\nimport type { TrendVideo, TimelineStats } from '../../../../core/types/trends';\n\ninterface UseTimelineAutoUpdateProps {\n    videos: TrendVideo[];\n    forcedStats?: TimelineStats;\n    skipAutoFitRef?: React.RefObject<boolean>;\n    filterHash?: string;\n}\n\nexport const useTimelineAutoUpdate = ({ videos, forcedStats, skipAutoFitRef, filterHash }: UseTimelineAutoUpdateProps) => {\n    // State to control structure updates ('Z' key forces update)\n    const [structureVersion, setStructureVersion] = useState(0);\n    // Track whether the current structure version update should trigger an auto-fit\n    const [shouldAutoFit, setShouldAutoFit] = useState(false);\n\n    // Smart Structure Updates:\n    // We want the timeline to re-calculate structure (Fit) automatically in specific cases,\n    // but stay \"Frozen\" in others (to preserve context).\n    const prevVideoCountRef = useRef(videos.length);\n    const prevForcedStatsRef = useRef(forcedStats);\n    const prevFilterHashRef = useRef(filterHash);\n\n    useEffect(() => {\n        const currentCount = videos.length;\n        const prevCount = prevVideoCountRef.current;\n        const prevStats = prevForcedStatsRef.current;\n        const prevHash = prevFilterHashRef.current;\n\n        const hasStatsChanged = prevStats !== forcedStats;\n        const hasHashChanged = filterHash !== prevHash;\n\n        // Update refs\n        prevVideoCountRef.current = currentCount;\n        prevForcedStatsRef.current = forcedStats;\n        prevFilterHashRef.current = filterHash;\n\n        // 1. Significance Check: If nothing significant changed, do nothing.\n        if (currentCount === prevCount && !hasStatsChanged && !hasHashChanged) return;\n\n        // Determine if we should fit on this update\n        const isSkipRequested = skipAutoFitRef?.current === true;\n\n        // 2. Filter/Context Switch (Global <-> Local OR Filter Hash Change)\n        // If the context defining the \"World\" changes, we MUST update.\n        // This includes Niche Filters changing (Hash Change).\n        if (hasStatsChanged || hasHashChanged) {\n            // New logic: If Hash changed (explicit filter change), ALWAYS fit (ignore skip).\n            // If only Stats changed (e.g. Mode toggle Global->Filtered), respect skip.\n            const shouldFit = hasHashChanged ? true : !isSkipRequested;\n\n            setShouldAutoFit(shouldFit);\n            setStructureVersion(v => v + 1);\n            return;\n        }\n\n        // 3. Filter Changes (Count Changed) BUT Hash Same (e.g. Visibility Toggle)\n        if (currentCount !== prevCount) {\n            // STRICT FREEZE (Business Logic):\n            // If we are in Global Mode (forcedStats provided) AND the Filter Hash hasn't changed,\n            // we assume this is a \"Visibility Toggle\" of channels (e.g. clicking eye icon).\n            // User REQ: Visibility toggles should be MANUAL updates only to avoid disorienting jumps.\n            // We DO NOT update structure here. User must press 'Z' (manual fit) to refit/update.\n            if (forcedStats) {\n                return;\n            }\n\n            // Local Mode: Always re-calculate structure and fit for any change\n            setShouldAutoFit(!isSkipRequested);\n            setStructureVersion(v => v + 1);\n        }\n    }, [videos.length, forcedStats, skipAutoFitRef, filterHash]);\n\n    const forceStructureUpdate = useCallback((fit: boolean = true) => {\n        setShouldAutoFit(fit);\n        setStructureVersion(v => v + 1);\n    }, []);\n\n    return {\n        structureVersion,\n        shouldAutoFit,\n        forceStructureUpdate\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineControlHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[639,642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[639,642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useCallback } from 'react';\nimport type { VideoPosition, TimelineStats, MonthLayout } from '../../../../core/types/trends';\nimport type { Transform } from './useTimelineTransform';\nimport { findSmartAnchorTime, getTimeAtWorldX } from '../utils/timelineMath';\n\ninterface UseTimelineControlHandlersProps {\n    transformState: Transform;\n    containerSizeRef: React.MutableRefObject<{ width: number; height: number }>;\n    minScale: number;\n    videoPositions: VideoPosition[];\n    worldWidth: number;\n    dynamicWorldHeight: number;\n    stats: TimelineStats;\n    monthLayouts: MonthLayout[];\n    setTimelineConfig: (config: any) => void;\n    setTransformState: (transform: Transform) => void;\n    anchorToTime: (anchor: number | { time: number; xNorm?: number; yNorm?: number; screenX?: number; screenY?: number }) => void;\n    verticalSpread: number;\n}\n\nexport const useTimelineControlHandlers = ({\n    transformState,\n    containerSizeRef,\n    minScale,\n    videoPositions,\n    worldWidth,\n    dynamicWorldHeight,\n    stats,\n    monthLayouts,\n    setTimelineConfig,\n    setTransformState,\n    anchorToTime,\n    verticalSpread\n}: UseTimelineControlHandlersProps) => {\n\n    const HEADER_HEIGHT = 48; // Constant from Canvas, could receive as prop if needed\n\n    // Persist anchor video during drag to prevent jumping between videos\n    const spreadDragAnchorRef = useRef<string | null>(null);\n    const timeDragAnchorRef = useRef<string | null>(null);\n\n    const handleSpreadChange = useCallback((newSpread: number) => {\n        const oldSpread = verticalSpread ?? 1.0;\n        if (Math.abs(oldSpread - newSpread) < 0.001) return;\n\n        const currentScale = transformState.scale;\n        const viewportWidth = containerSizeRef.current.width;\n        const viewportHeight = containerSizeRef.current.height;\n\n        // Check if roughly fitted (zoomed out)\n        const isRoughlyFitted = Math.abs(currentScale - minScale) < 0.0001 || (Math.abs(currentScale - minScale) / minScale) < 0.01;\n\n        if (!isRoughlyFitted && videoPositions.length > 0) {\n            // Try to use persisted anchor, or find new one\n            const hadPersisted = !!spreadDragAnchorRef.current;\n            let anchorVideoPos = spreadDragAnchorRef.current\n                ? videoPositions.find(v => v.video.id === spreadDragAnchorRef.current)\n                : null;\n\n            // If no persisted anchor, find best one and save it\n            if (!anchorVideoPos) {\n                const foundAnchor = findSmartAnchorTime({\n                    videoPositions,\n                    currentTransform: transformState,\n                    worldWidth,\n                    worldHeight: dynamicWorldHeight,\n                    viewportWidth,\n                    viewportHeight,\n                    stats\n                });\n                if (foundAnchor) {\n                    spreadDragAnchorRef.current = foundAnchor.videoId;\n                    // Find the actual VideoPosition for this video\n                    anchorVideoPos = videoPositions.find(v => v.video.id === foundAnchor.videoId) ?? null;\n                }\n            }\n\n            if (anchorVideoPos) {\n                // Get video's current screen position\n                const worldX = anchorVideoPos.xNorm * worldWidth;\n                const worldY = anchorVideoPos.yNorm * dynamicWorldHeight;\n                const screenX = worldX * currentScale + transformState.offsetX;\n                const screenY = worldY * currentScale + transformState.offsetY;\n\n                // Calculate viewport center\n                const centerScreenX = viewportWidth / 2;\n                const centerScreenY = HEADER_HEIGHT + (viewportHeight - HEADER_HEIGHT) / 2;\n\n                // Only apply pull if we had a persisted anchor (not first onChange)\n                // This prevents the initial \"jerk\" when starting drag\n                let targetScreenX = screenX;\n                let targetScreenY = screenY;\n\n                if (hadPersisted) {\n                    // 2D pull towards center: the further from center, the more pull\n                    const distFromCenterX = Math.abs(screenX - centerScreenX);\n                    const distFromCenterY = Math.abs(screenY - centerScreenY);\n                    const maxDistX = viewportWidth / 2;\n                    const maxDistY = viewportHeight / 2;\n\n                    const pullStrengthX = Math.min(0.3, (distFromCenterX / maxDistX) * 0.3);\n                    const pullStrengthY = Math.min(0.3, (distFromCenterY / maxDistY) * 0.3);\n\n                    // Target screen position: blend towards center\n                    targetScreenX = screenX + (centerScreenX - screenX) * pullStrengthX;\n                    targetScreenY = screenY + (centerScreenY - screenY) * pullStrengthY;\n                }\n\n                // De-spread the yNorm to get base position (relative to 0.5 center)\n                const distFromCenter = anchorVideoPos.yNorm - 0.5;\n                const safeOldSpread = Math.max(0.001, oldSpread);\n                let baseDist = distFromCenter / safeOldSpread;\n                // Clamp to prevent extreme values\n                baseDist = Math.max(-0.5, Math.min(0.5, baseDist));\n\n                // Re-spread with new spread\n                const newYNorm = 0.5 + baseDist * newSpread;\n                const newWorldY = newYNorm * dynamicWorldHeight;\n\n                // Calculate new offsets for 2D positioning\n                const newOffsetX = targetScreenX - (worldX * currentScale);\n                const newOffsetY = targetScreenY - (newWorldY * currentScale);\n\n                setTimelineConfig({ verticalSpread: newSpread });\n                setTransformState({\n                    ...transformState,\n                    offsetX: newOffsetX,\n                    offsetY: newOffsetY\n                });\n                return;\n            }\n        }\n\n        // Fallback: just update spread without offset change\n        setTimelineConfig({ verticalSpread: newSpread });\n    }, [\n        videoPositions, transformState, containerSizeRef, minScale,\n        worldWidth, dynamicWorldHeight, stats, verticalSpread,\n        setTimelineConfig, setTransformState\n    ]);\n\n    const handleTimeLinearityChange = useCallback((level: number) => {\n        const currentScale = transformState.scale;\n        const viewportWidth = containerSizeRef.current.width;\n        const viewportHeight = containerSizeRef.current.height;\n\n        // 1. Check if we are currently \"Fitted\" (Zoomed out to see everything)\n        const isRoughlyFitted = Math.abs(currentScale - minScale) < 0.0001 || (Math.abs(currentScale - minScale) / minScale) < 0.01;\n\n        if (!isRoughlyFitted && videoPositions.length > 0) {\n            // Try to use persisted anchor, or find new one\n            const hadPersisted = !!timeDragAnchorRef.current;\n            let anchorVideoPos = timeDragAnchorRef.current\n                ? videoPositions.find(v => v.video.id === timeDragAnchorRef.current)\n                : null;\n\n            // If no persisted anchor, find best one and save it\n            if (!anchorVideoPos) {\n                const foundAnchor = findSmartAnchorTime({\n                    videoPositions,\n                    currentTransform: transformState,\n                    worldWidth,\n                    worldHeight: dynamicWorldHeight,\n                    viewportWidth,\n                    viewportHeight,\n                    stats\n                });\n                if (foundAnchor) {\n                    timeDragAnchorRef.current = foundAnchor.videoId;\n                    anchorVideoPos = videoPositions.find(v => v.video.id === foundAnchor.videoId) ?? null;\n                }\n            }\n\n            if (anchorVideoPos) {\n                // Get video's current screen position\n                const worldX = anchorVideoPos.xNorm * worldWidth;\n                const worldY = anchorVideoPos.yNorm * dynamicWorldHeight;\n                const screenX = worldX * currentScale + transformState.offsetX;\n                const screenY = worldY * currentScale + transformState.offsetY;\n\n                // Only apply pull if we had a persisted anchor (not first onChange)\n                let targetScreenX = screenX;\n                let targetScreenY = screenY;\n\n                if (hadPersisted) {\n                    // 2D pull towards center\n                    const centerScreenX = viewportWidth / 2;\n                    const centerScreenY = HEADER_HEIGHT + (viewportHeight - HEADER_HEIGHT) / 2;\n\n                    const distFromCenterX = Math.abs(screenX - centerScreenX);\n                    const distFromCenterY = Math.abs(screenY - centerScreenY);\n                    const maxDistX = viewportWidth / 2;\n                    const maxDistY = viewportHeight / 2;\n\n                    const pullStrengthX = Math.min(0.3, (distFromCenterX / maxDistX) * 0.3);\n                    const pullStrengthY = Math.min(0.3, (distFromCenterY / maxDistY) * 0.3);\n\n                    // Target screen position: blend towards center\n                    targetScreenX = screenX + (centerScreenX - screenX) * pullStrengthX;\n                    targetScreenY = screenY + (centerScreenY - screenY) * pullStrengthY;\n                }\n\n                anchorToTime({\n                    time: anchorVideoPos.video.publishedAtTimestamp,\n                    xNorm: anchorVideoPos.xNorm,\n                    yNorm: anchorVideoPos.yNorm,\n                    screenX: targetScreenX,\n                    screenY: targetScreenY\n                });\n            } else {\n                // 3. Fallback: Center Time\n                const centerX = viewportWidth / 2;\n                const worldX = (centerX - transformState.offsetX) / currentScale;\n                const normX = worldX / worldWidth;\n                const centerTime = getTimeAtWorldX(normX, monthLayouts, stats);\n                anchorToTime(centerTime);\n            }\n        }\n\n        setTimelineConfig({ timeLinearity: level });\n    }, [\n        videoPositions, transformState, containerSizeRef, minScale,\n        worldWidth, dynamicWorldHeight, stats, monthLayouts,\n        anchorToTime, setTimelineConfig\n    ]);\n\n    return {\n        handleSpreadChange,\n        handleSpreadDragStart: useCallback(() => { spreadDragAnchorRef.current = null; }, []),\n        handleSpreadDragEnd: useCallback(() => { spreadDragAnchorRef.current = null; }, []),\n        handleTimeLinearityChange,\n        handleTimeDragStart: useCallback(() => { timeDragAnchorRef.current = null; }, []),\n        handleTimeDragEnd: useCallback(() => { timeDragAnchorRef.current = null; }, []),\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineHotkeys.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineInteraction.ts","messages":[{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: Cannot access variable before it is declared\n\n`updateAnimation` is accessed before it is declared, which prevents the earlier access from updating when this value changes over time.\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineInteraction.ts:102:52\n  100 |             };\n  101 |             syncToDom();\n> 102 |             rafRef.current = requestAnimationFrame(updateAnimation);\n      |                                                    ^^^^^^^^^^^^^^^ `updateAnimation` accessed before it is declared\n  103 |         }\n  104 |     }, [transformRef, syncToDom]);\n  105 |\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineInteraction.ts:73:5\n   71 |     };\n   72 |\n>  73 |     const updateAnimation = useCallback(() => {\n      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  74 |         const current = transformRef.current;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  75 |         const target = targetTransformRef.current;\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 103 |         }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 104 |     }, [transformRef, syncToDom]);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `updateAnimation` is declared here\n  105 |\n  106 |     const startAnimation = useCallback(() => {\n  107 |         if (!rafRef.current) {","line":102,"column":52,"nodeType":null,"endLine":102,"endColumn":67}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useRef, useState } from 'react';\nimport type { TimelineVideoLayerHandle } from '../layers/TimelineVideoLayer';\n\nimport { calculateSelectionZoomTransform } from '../utils/timelineMath';\n\ninterface Transform {\n    scale: number;\n    offsetX: number;\n    offsetY: number;\n}\n\ninterface UseTimelineInteractionProps {\n    containerRef: React.RefObject<HTMLDivElement | null>;\n    videoLayerRef: React.RefObject<TimelineVideoLayerHandle | null>;\n    transformRef: React.MutableRefObject<Transform>;\n    minScale: number;\n    containerSizeRef: React.MutableRefObject<{ width: number; height: number }>;\n    setTransformState: (t: Transform) => void;\n    clampTransform: (t: Transform, w: number, h: number) => Transform;\n    onHoverVideo?: (hovered: boolean) => void;\n    onInteractionStart?: () => void; // Called when zoom/pan/selection starts\n}\n\n\n\n\nexport const useTimelineInteraction = ({\n    containerRef,\n    videoLayerRef,\n    transformRef,\n    minScale,\n    containerSizeRef,\n    setTransformState,\n    clampTransform,\n    onHoverVideo,\n    onInteractionStart\n}: UseTimelineInteractionProps) => {\n\n    const [isPanning, setIsPanning] = useState(false);\n    const isPanningRef = useRef(false);\n    const panStartRef = useRef({ x: 0, y: 0 });\n    const mouseDownPosRef = useRef({ x: 0, y: 0 });\n    const hasSeenMouseDownRef = useRef(false);\n\n    // Selection State\n    const [selectionRect, setSelectionRect] = useState<{ x: number; y: number; width: number; height: number } | null>(null);\n    const isSelectingRef = useRef(false);\n    const selectionStartRef = useRef({ x: 0, y: 0 });\n\n    // Interpolation State\n    const targetTransformRef = useRef({ ...transformRef.current });\n    const rafRef = useRef<number | null>(null);\n\n    // Sync target to current on mount or external reset (optional but good safety)\n    useEffect(() => {\n        targetTransformRef.current = { ...transformRef.current };\n    }, [transformRef]); // Run once, we trust internal updates mainly. \n\n    const syncToDom = useCallback(() => {\n        // Imperative DOM update for video layer (bypasses React reconciliation)\n        if (videoLayerRef.current) {\n            videoLayerRef.current.updateTransform(transformRef.current);\n        }\n        // React state update (might be throttled by parent if needed, but here direct)\n        setTransformState({ ...transformRef.current });\n    }, [videoLayerRef, transformRef, setTransformState]);\n\n    // Lerp helper\n    const lerp = (start: number, end: number, t: number) => {\n        return start * (1 - t) + end * t;\n    };\n\n    const updateAnimation = useCallback(() => {\n        const current = transformRef.current;\n        const target = targetTransformRef.current;\n\n        // Smooth factor (adjustable)\n        const smoothness = 0.15;\n\n        // Calculate new values\n        const newScale = lerp(current.scale, target.scale, smoothness);\n        const newOffsetX = lerp(current.offsetX, target.offsetX, smoothness);\n        const newOffsetY = lerp(current.offsetY, target.offsetY, smoothness);\n\n        // Check for completion (epsilon)\n        const isFinished =\n            Math.abs(newScale - target.scale) < 0.0001 &&\n            Math.abs(newOffsetX - target.offsetX) < 0.1 &&\n            Math.abs(newOffsetY - target.offsetY) < 0.1;\n\n        if (isFinished) {\n            transformRef.current = { ...target };\n            syncToDom();\n            rafRef.current = null; // Stop loop\n        } else {\n            transformRef.current = {\n                scale: newScale,\n                offsetX: newOffsetX,\n                offsetY: newOffsetY\n            };\n            syncToDom();\n            rafRef.current = requestAnimationFrame(updateAnimation);\n        }\n    }, [transformRef, syncToDom]);\n\n    const startAnimation = useCallback(() => {\n        if (!rafRef.current) {\n            rafRef.current = requestAnimationFrame(updateAnimation);\n        }\n    }, [updateAnimation]);\n\n    const stopAnimation = useCallback(() => {\n        if (rafRef.current) {\n            cancelAnimationFrame(rafRef.current);\n            rafRef.current = null;\n        }\n    }, []);\n\n    const areTransformsDifferent = (a: Transform, b: Transform) => {\n        return Math.abs(a.scale - b.scale) > 0.0001 ||\n            Math.abs(a.offsetX - b.offsetX) > 0.1 ||\n            Math.abs(a.offsetY - b.offsetY) > 0.1;\n    };\n\n    // Wheel Handler\n    const handleWheel = useCallback((e: WheelEvent) => {\n        e.preventDefault();\n\n        const { width: viewportWidth, height: viewportHeight } = containerSizeRef.current;\n        if (viewportWidth === 0) return;\n\n        // Ensure target is synced if we were idle (handles 'Z' reset case implicitly)\n        if (!rafRef.current) {\n            targetTransformRef.current = { ...transformRef.current };\n        }\n\n        if (e.ctrlKey || e.metaKey) {\n            // Zooming\n            if (onHoverVideo) onHoverVideo(false);\n\n            const container = containerRef.current;\n            if (!container) return;\n            const rect = container.getBoundingClientRect();\n            const mouseX = e.clientX - rect.left;\n            const mouseY = e.clientY - rect.top;\n\n            const ZOOM_SENSITIVITY = 0.03; // 3x sensitivity\n            const delta = Math.max(-100, Math.min(100, e.deltaY));\n\n            const currentTargetScale = targetTransformRef.current.scale; // Use TARGET for accumulation\n            const scaleFactor = Math.exp(-delta * ZOOM_SENSITIVITY);\n\n            const newScale = Math.max(minScale, Math.min(10, currentTargetScale * scaleFactor));\n            const scaleRatio = newScale / currentTargetScale;\n\n            // Calculate standard relative zoom offsets (Mouse-Centered)\n            const targetOffsetX = mouseX - (mouseX - targetTransformRef.current.offsetX) * scaleRatio;\n            const targetOffsetY = mouseY - (mouseY - targetTransformRef.current.offsetY) * scaleRatio;\n\n            const clamped = clampTransform({\n                scale: newScale,\n                offsetX: targetOffsetX,\n                offsetY: targetOffsetY\n            }, viewportWidth, viewportHeight);\n\n            // Update Target & Animate\n            if (areTransformsDifferent(clamped, targetTransformRef.current)) {\n                if (onInteractionStart) onInteractionStart();\n                targetTransformRef.current = clamped;\n                startAnimation();\n            }\n        } else {\n            // Panning\n            const clamped = clampTransform({\n                ...targetTransformRef.current,\n                offsetX: targetTransformRef.current.offsetX - e.deltaX,\n                offsetY: targetTransformRef.current.offsetY - e.deltaY\n            }, viewportWidth, viewportHeight);\n\n            // Update Target & Animate (Consolidated smooth feeling)\n            if (areTransformsDifferent(clamped, targetTransformRef.current)) {\n                if (onInteractionStart) onInteractionStart();\n                targetTransformRef.current = clamped;\n                startAnimation();\n            }\n        }\n    }, [containerSizeRef, containerRef, transformRef, minScale, clampTransform, onHoverVideo, startAnimation, onInteractionStart]);\n\n    const handleMouseDown = useCallback((e: React.MouseEvent) => {\n        // Stop any inertial movement instantly on grab\n        stopAnimation();\n        // Sync target to where we actually are\n        targetTransformRef.current = { ...transformRef.current };\n\n        // Prevent default to stop text selection or native drag\n        if (e.button === 0) {\n            const container = containerRef.current;\n            if (!container) return;\n            const rect = container.getBoundingClientRect();\n            const localX = e.clientX - rect.left;\n            const localY = e.clientY - rect.top;\n\n            if (e.shiftKey) {\n                // START SELECTION\n                isSelectingRef.current = true;\n                selectionStartRef.current = { x: localX, y: localY };\n                if (onHoverVideo) onHoverVideo(false);\n                if (onInteractionStart) onInteractionStart();\n            } else {\n                // PREPARE PANNING (Don't set isPanning state yet)\n                isPanningRef.current = false; // Reset\n                setIsPanning(false);\n                mouseDownPosRef.current = { x: e.clientX, y: e.clientY };\n\n                // Track start offset for when panning eventually starts\n                panStartRef.current = {\n                    x: e.clientX - transformRef.current.offsetX,\n                    y: e.clientY - transformRef.current.offsetY\n                };\n                hasSeenMouseDownRef.current = true;\n            }\n        }\n    }, [transformRef, stopAnimation, containerRef, onHoverVideo, onInteractionStart]);\n\n    const handleMouseMove = useCallback((e: React.MouseEvent) => {\n        // If selecting, handle selection rect\n        if (isSelectingRef.current) {\n            const container = containerRef.current;\n            if (!container) return;\n            const rect = container.getBoundingClientRect();\n            const localX = e.clientX - rect.left;\n            const localY = e.clientY - rect.top;\n\n            const startX = selectionStartRef.current.x;\n            const startY = selectionStartRef.current.y;\n\n            // Calculate positive width/height rect\n            const x = Math.min(startX, localX);\n            const y = Math.min(startY, localY);\n            const width = Math.abs(localX - startX);\n            const height = Math.abs(localY - startY);\n\n            setSelectionRect({ x, y, width, height });\n            return;\n        }\n\n        // If not panning yet, check threshold\n        if (!isPanningRef.current && e.buttons === 1 && !e.shiftKey && hasSeenMouseDownRef.current) {\n            const dx = Math.abs(e.clientX - mouseDownPosRef.current.x);\n            const dy = Math.abs(e.clientY - mouseDownPosRef.current.y);\n\n            // Threshold of 5px\n            if (dx > 5 || dy > 5) {\n                isPanningRef.current = true;\n                setIsPanning(true);\n                if (onHoverVideo) onHoverVideo(false);\n            }\n        }\n\n        // If panning (either just started or continuing)\n        if (isPanningRef.current) {\n            const { width: viewportWidth, height: viewportHeight } = containerSizeRef.current;\n            if (viewportWidth === 0) return;\n\n            /**\n             * Pan Logic:\n             * 'panStartRef' captures the relationship between mouse position and timeline offset.\n             * Even though we wait for a threshold (deadzone), applying this formula\n             * results in a seamless transition once panning starts, effectively \n             * \"picking up\" the timeline exactly where it was grabbed.\n             */\n\n            const clamped = clampTransform({\n                ...transformRef.current,\n                offsetX: e.clientX - panStartRef.current.x,\n                offsetY: e.clientY - panStartRef.current.y\n            }, viewportWidth, viewportHeight);\n\n            // Only trigger interaction start if we actually moved significantly\n            if (areTransformsDifferent(clamped, targetTransformRef.current)) {\n                if (onInteractionStart) onInteractionStart();\n                transformRef.current = clamped;\n                targetTransformRef.current = clamped;\n                syncToDom();\n            }\n        }\n    }, [containerSizeRef, transformRef, clampTransform, syncToDom, onHoverVideo, containerRef, onInteractionStart]);\n\n    const lastPanEndTimeRef = useRef(0);\n\n    const handleMouseUp = useCallback((e?: React.MouseEvent) => {\n        // PAN END\n        if (isPanningRef.current) {\n            setIsPanning(false);\n            isPanningRef.current = false;\n            lastPanEndTimeRef.current = Date.now();\n            // Ensure final state is synced to React to prevent re-render jumps\n            syncToDom();\n        }\n        hasSeenMouseDownRef.current = false;\n\n        // SELECTION END -> ZOOM\n        if (isSelectingRef.current) {\n            isSelectingRef.current = false;\n            setSelectionRect(null); // Hide rect\n\n            const { width: viewportWidth, height: viewportHeight } = containerSizeRef.current;\n            if (viewportWidth === 0) return;\n\n            const container = containerRef.current;\n            if (!container) return;\n\n            // We need to calculate based on the FINAL MOUSE POSITION.\n            // If e is provided, use it. If not (global listener), we might need to rely on the last rect state?\n            // Actually, handleMouseUp IS usually attached to the container in this case, receiving the event.\n            // Assuming this is used as onMouseUp={handleMouseUp}\n\n            if (e) {\n                const rect = container.getBoundingClientRect();\n                const localX = e.clientX - rect.left;\n                const localY = e.clientY - rect.top;\n\n                const startX = selectionStartRef.current.x;\n                const startY = selectionStartRef.current.y;\n\n                const width = Math.abs(localX - startX);\n                const height = Math.abs(localY - startY);\n\n                // Calculate positive width/height rect for logic\n                const x = Math.min(startX, localX);\n                const y = Math.min(startY, localY);\n\n                const newTransform = calculateSelectionZoomTransform(\n                    { x, y, width, height },\n                    { width: viewportWidth, height: viewportHeight },\n                    transformRef.current,\n                    minScale\n                );\n\n                // Animate to it\n                targetTransformRef.current = newTransform;\n                startAnimation();\n            }\n        }\n    }, [containerSizeRef, containerRef, transformRef, minScale, startAnimation, syncToDom]);\n\n    // Events attachment\n    useEffect(() => {\n        const container = containerRef.current;\n        if (!container) return;\n\n        const gestureHandler = (e: Event) => e.preventDefault();\n        container.addEventListener('wheel', handleWheel, { passive: false });\n\n        // Disable native gestures to prevent page zoom\n        document.addEventListener('gesturestart', gestureHandler);\n        document.addEventListener('gesturechange', gestureHandler);\n        document.addEventListener('gestureend', gestureHandler);\n\n        return () => {\n            container.removeEventListener('wheel', handleWheel);\n            document.removeEventListener('gesturestart', gestureHandler);\n            document.removeEventListener('gesturechange', gestureHandler);\n            document.removeEventListener('gestureend', gestureHandler);\n        };\n    }, [handleWheel, containerRef]);\n\n    const zoomToPoint = useCallback((worldX: number, worldY: number, targetZoomScale: number) => {\n        const { width: viewportWidth, height: viewportHeight } = containerSizeRef.current;\n        if (viewportWidth === 0) return;\n\n        // Calculate New Offset to center the world point\n        // ViewportCenter = WorldPoint * Scale + Offset\n        // Offset = ViewportCenter - WorldPoint * Scale\n        const newOffsetX = (viewportWidth / 2) - (worldX * targetZoomScale);\n        const newOffsetY = (viewportHeight / 2) - (worldY * targetZoomScale);\n\n        const clamped = clampTransform({\n            scale: targetZoomScale,\n            offsetX: newOffsetX,\n            offsetY: newOffsetY\n        }, viewportWidth, viewportHeight);\n\n        targetTransformRef.current = clamped;\n        startAnimation();\n    }, [containerSizeRef, clampTransform, startAnimation]);\n\n    const smoothToTransform = useCallback((target: Transform) => {\n        targetTransformRef.current = { ...target };\n        startAnimation();\n    }, [startAnimation]);\n\n    return {\n        isPanning,\n        selectionRect,\n        handleMouseDown,\n        handleMouseMove,\n        handleMouseUp,\n        syncToDom,\n        zoomToPoint,\n        smoothToTransform,\n        lastPanEndTimeRef\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelinePositions.ts","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output.\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelinePositions.ts:67:32\n  65 |\n  66 |     // Percentile Helper\n> 67 |     const getPercentileGroup = useMemo(() => {\n     |                                ^^^^^^^^^^^^^^^\n> 68 |         // If percentileMap is provided, use it directly (O(1))\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 69 |         if (percentileMap) {\n     \n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 90 |         };\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 91 |     }, [videos, percentileMap]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Could not preserve existing memoization\n  92 |\n  93 |     return {\n  94 |         videoPositions,","line":67,"column":32,"nodeType":null,"endLine":91,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react';\nimport type { TrendVideo, TimelineStats, VideoPosition, MonthLayout } from '../../../../core/types/trends';\nimport { getTrendYPosition, getTrendXPosition } from '../utils/trendLayoutUtils';\n\nexport interface UseTimelinePositionsProps {\n    videos: TrendVideo[];\n    stats: TimelineStats;\n    monthLayouts: MonthLayout[];\n    scalingMode: 'linear' | 'log' | 'sqrt' | 'percentile';\n    verticalSpread?: number;\n    dynamicWorldHeight: number;\n    percentileMap?: Map<string, string>;\n}\n\nexport const useTimelinePositions = ({\n    videos,\n    stats,\n    monthLayouts,\n    scalingMode,\n    verticalSpread,\n    dynamicWorldHeight,\n    percentileMap\n}: UseTimelinePositionsProps) => {\n    // Calculate video positions\n    const videoPositions = useMemo<VideoPosition[]>(() => {\n        if (!videos.length || !stats) return [];\n\n        // Effective Spread\n        const spread = verticalSpread !== undefined ? verticalSpread : 1.0;\n\n        // Pre-calculate percentile thresholds if needed\n        const sortedByViews = [...videos].sort((a, b) => a.viewCount - b.viewCount);\n        const rankMap = new Map<string, number>();\n        sortedByViews.forEach((v, i) => rankMap.set(v.id, i / (videos.length - 1 || 1)));\n\n        const positions = videos.map(video => {\n            // X-AXIS: Use shared utility (Handles non-linear time distribution)\n            const xNorm = getTrendXPosition(video.publishedAtTimestamp, stats, monthLayouts);\n\n            // Y-AXIS: Use shared utility\n            const { y: expandedY, baseSize } = getTrendYPosition(\n                video.viewCount,\n                stats,\n                scalingMode,\n                spread,\n                dynamicWorldHeight,\n                // Only needed for percentile mode\n                rankMap.get(video.id) ?? 0.5\n            );\n\n            // Return normalized Y relative to dynamicWorldHeight\n            return { video, xNorm, yNorm: expandedY / dynamicWorldHeight, baseSize };\n        });\n\n        /**\n         * Z-ORDER SORTING:\n         * Sort by baseSize ASCENDING so that:\n         * 1. Smaller dots are rendered first (background)\n         * 2. Larger dots are rendered last (foreground / on top)\n         * 3. Hit detection picks largest overlapping dot (matching visual z-order)\n         */\n        positions.sort((a, b) => a.baseSize - b.baseSize);\n        return positions;\n    }, [videos, stats, scalingMode, monthLayouts, verticalSpread, dynamicWorldHeight]);\n\n    // Percentile Helper\n    const getPercentileGroup = useMemo(() => {\n        // If percentileMap is provided, use it directly (O(1))\n        if (percentileMap) {\n            return (videoId: string): string | undefined => {\n                return percentileMap.get(videoId);\n            };\n        }\n\n        if (videos.length === 0) return () => undefined;\n        const sortedByViews = [...videos].sort((a, b) => b.viewCount - a.viewCount);\n        const rankMap = new Map<string, number>();\n        sortedByViews.forEach((v, i) => {\n            const percentile = (i / videos.length) * 100;\n            rankMap.set(v.id, percentile);\n        });\n        return (videoId: string): string | undefined => {\n            const percentile = rankMap.get(videoId);\n            if (percentile === undefined) return undefined;\n            if (percentile <= 1) return 'Top 1%';\n            if (percentile <= 5) return 'Top 5%';\n            if (percentile <= 20) return 'Top 20%';\n            if (percentile <= 80) return 'Middle 60%';\n            return 'Bottom 20%';\n        };\n    }, [videos, percentileMap]);\n\n    return {\n        videoPositions,\n        getPercentileGroup\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineStructure.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1304,1307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1304,1307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1315,1318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1315,1318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Date.now` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineStructure.ts:57:78\n  55 |     // 1. Calculate Stats (Memoized)\n  56 |     const currentStats = useMemo((): TimelineStats => {\n> 57 |         if (videos.length === 0) return { minViews: 0, maxViews: 1, minDate: Date.now(), maxDate: Date.now() };\n     |                                                                              ^^^^^^^^^^ Cannot call impure function\n  58 |         const views = videos.map(v => v.viewCount);\n  59 |         const dates = videos.map(v => v.publishedAtTimestamp);\n  60 |         const buffer = 1000 * 60 * 60 * 12;","line":57,"column":78,"nodeType":null,"endLine":57,"endColumn":88},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Date.now` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineStructure.ts:57:99\n  55 |     // 1. Calculate Stats (Memoized)\n  56 |     const currentStats = useMemo((): TimelineStats => {\n> 57 |         if (videos.length === 0) return { minViews: 0, maxViews: 1, minDate: Date.now(), maxDate: Date.now() };\n     |                                                                                                   ^^^^^^^^^^ Cannot call impure function\n  58 |         const views = videos.map(v => v.viewCount);\n  59 |         const dates = videos.map(v => v.publishedAtTimestamp);\n  60 |         const buffer = 1000 * 60 * 60 * 12;","line":57,"column":99,"nodeType":null,"endLine":57,"endColumn":109},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'effectiveStats'. Either exclude it or remove the dependency array.","line":93,"column":8,"nodeType":"ArrayExpression","endLine":93,"endColumn":45,"suggestions":[{"desc":"Update the dependencies array to be: [densitySourceVideos]","fix":{"range":[3841,3878],"text":"[densitySourceVideos]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6314,6317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6314,6317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo, useRef, useCallback } from 'react';\nimport type { TrendVideo, MonthRegion, YearMarker, TimelineStats, MonthLayout } from '../../../../core/types/trends';\nimport { useFrozenValue } from './useFrozenValue';\n\n// Helper: Days in month\nconst getDaysInMonth = (year: number, month: number) => new Date(year, month + 1, 0).getDate();\n\ninterface UseTimelineStructureProps {\n    videos: TrendVideo[];\n    /** Full set of videos for the current context (used for consistent density) */\n    allVideos?: TrendVideo[];\n    timeLinearity?: number;\n    structureVersion?: number;\n    stats?: TimelineStats;\n    isFrozen?: boolean;\n}\n\nexport const useTimelineStructure = ({\n    videos,\n    allVideos = [],\n    timeLinearity = 1.0, // Default to Density (1.0)\n    structureVersion = 0, // Version to force structure recalculation\n    stats: forcedStatsOverride, // Optional forced stats\n    isFrozen = false // Strict freeze flag\n}: UseTimelineStructureProps) => {\n\n    const densitySourceVideos = allVideos.length > 0 ? allVideos : videos;\n\n    // Trace initialization\n    const hasInitializedRef = useRef(false);\n    if (densitySourceVideos.length > 0) {\n        hasInitializedRef.current = true;\n    }\n\n    // Custom update logic for strict freezing\n    const shouldStrictUpdate = useCallback((prev: any, next: any) => {\n        // 1. Version Change triggers update (Always)\n        if (prev.version !== next.version) return true;\n\n        // 2. Check dependencies FIRST - certain changes like timeLinearity should always update\n        const prevDeps = prev.dependencies;\n        const nextDeps = next.dependencies;\n        if (prevDeps.length !== nextDeps.length) return true;\n        for (let i = 0; i < prevDeps.length; i++) {\n            if (prevDeps[i] !== nextDeps[i]) return true;\n        }\n\n        // 3. If strictly frozen and already initialized, reject non-dependency updates\n        // (This check comes AFTER dependency check to ensure slider controls work)\n        if (isFrozen && hasInitializedRef.current) return false;\n\n        return false;\n    }, [isFrozen]);\n\n    // 1. Calculate Stats (Memoized)\n    const currentStats = useMemo((): TimelineStats => {\n        if (videos.length === 0) return { minViews: 0, maxViews: 1, minDate: Date.now(), maxDate: Date.now() };\n        const views = videos.map(v => v.viewCount);\n        const dates = videos.map(v => v.publishedAtTimestamp);\n        const buffer = 1000 * 60 * 60 * 12;\n        return {\n            minViews: Math.max(1, Math.min(...views)),\n            maxViews: Math.max(1, Math.max(...views)),\n            minDate: Math.min(...dates) - buffer,\n            maxDate: Math.max(...dates) + buffer\n        };\n    }, [videos]);\n\n    // Use forced stats if provided, otherwise local stats\n    const calculatedEffectiveStats = forcedStatsOverride || currentStats;\n\n    // Freeze Stats\n    // NOTE: We depend on `videos.length > 0` (Video Presence) rather than `videos` (Video Content).\n    // This allows `structureVersion` (controlled by useTimelineAutoUpdate) to be the sole\n    // arbiter of WHEN to update the structure, supporting the \"Manual Update\" workflow.\n    const effectiveStats = useFrozenValue({\n        value: calculatedEffectiveStats,\n        version: structureVersion,\n        dependencies: [videos.length > 0],\n        shouldUpdate: shouldStrictUpdate\n    });\n\n    // 2. Density Analysis (Independent of time linearity)\n    const densityStats = useMemo(() => {\n        const dynamicLinearPixelsPerDay = 120;\n        const counts = new Map<string, number>();\n        densitySourceVideos.forEach(v => {\n            const d = new Date(v.publishedAtTimestamp);\n            const key = `${d.getFullYear()}-${d.getMonth()}`;\n            counts.set(key, (counts.get(key) || 0) + 1);\n        });\n        return { counts, dynamicLinearPixelsPerDay };\n    }, [densitySourceVideos, effectiveStats]);\n\n    // ============================================================\n    // SINGLE SOURCE OF TRUTH: Timeline Date Range\n    // Both worldWidth and monthLayouts use this shared calculation\n    // ============================================================\n    const timelineRange = useMemo(() => {\n        // Use the actual min date (with buffer removed) to determine the starting month\n        // The buffer is 12 hours, so we add it back to get the real video date\n        const BUFFER_MS = 1000 * 60 * 60 * 12;\n        const actualMinDate = new Date(effectiveStats.minDate + BUFFER_MS);\n\n        // Start from the 1st of the month containing the first video\n        const startDate = new Date(actualMinDate.getFullYear(), actualMinDate.getMonth(), 1);\n\n        // End exactly at the day of the last video (not rounded up to month end)\n        // Also account for the buffer on maxDate\n        const actualMaxDate = new Date(effectiveStats.maxDate - BUFFER_MS);\n        const lastVideoDay = actualMaxDate.getDate();\n        const lastVideoDaysInMonth = getDaysInMonth(actualMaxDate.getFullYear(), actualMaxDate.getMonth());\n\n        // Calculate clip factor for the last month (how much of the month to show)\n        // e.g., if last video is on day 5 of 31, clipFactor = 5/31  0.16\n        const lastMonthClipFactor = (lastVideoDay + 0.5) / lastVideoDaysInMonth; // +0.5 to include the full day\n\n        // For the loop condition, we still need to include the last month\n        const safeEndDate = new Date(actualMaxDate.getFullYear(), actualMaxDate.getMonth() + 1, 1);\n\n        return {\n            startDate,\n            endDate: safeEndDate,\n            lastMonthKey: `${actualMaxDate.getFullYear()}-${actualMaxDate.getMonth()}`,\n            lastMonthClipFactor\n        };\n    }, [effectiveStats]);\n\n    // ============================================================\n    // PHASE 1: Base Grid Calculation (Static - No timeLinearity dependency)\n    // ============================================================\n    // This part does all the heavy lifting: Date operations, counting, etc.\n    // It only re-runs if videos or strict dependencies change, NOT when slider moves.\n    const baseTimelineGrid = useMemo(() => {\n        if (videos.length === 0 && !forcedStatsOverride) return [];\n\n        const { counts, dynamicLinearPixelsPerDay } = densityStats;\n        const VIDEO_DENSITY_MULTIPLIER = 80;\n\n        const grid: any[] = [];\n        const current = new Date(timelineRange.startDate);\n        let loops = 0;\n\n        while (current < timelineRange.endDate && loops < 1000) {\n            const year = current.getFullYear();\n            const month = current.getMonth();\n            const key = `${year}-${month}`;\n            const count = counts.get(key) || 0;\n\n            const daysInMonth = getDaysInMonth(year, month);\n            const linearWidth = daysInMonth * dynamicLinearPixelsPerDay;\n            const densityWidth = Math.max(200, count * VIDEO_DENSITY_MULTIPLIER);\n\n            const isLastMonth = key === timelineRange.lastMonthKey;\n\n            // Calculate timestamps locally to avoid Date usage later\n            const nextMonth = new Date(current);\n            nextMonth.setMonth(current.getMonth() + 1);\n\n            grid.push({\n                year,\n                month,\n                monthKey: key,\n                label: current.toLocaleDateString('en-US', { month: 'short' }).toUpperCase(),\n                count,\n                linearWidth,\n                densityWidth,\n                startTs: current.getTime(),\n                endTs: isLastMonth ? new Date(effectiveStats.maxDate).getTime() : nextMonth.getTime(),\n                daysInMonth: isLastMonth\n                    ? Math.ceil(daysInMonth * timelineRange.lastMonthClipFactor)\n                    : daysInMonth,\n                isLastMonth,\n                clipFactor: isLastMonth ? timelineRange.lastMonthClipFactor : 1.0\n            });\n\n            current.setMonth(current.getMonth() + 1);\n            loops++;\n        }\n\n        return grid;\n    }, [videos, effectiveStats, densityStats, timelineRange, forcedStatsOverride]);\n\n    // ============================================================\n    // PHASE 2: Dynamic Interpolation (Light - Depends on timeLinearity)\n    // ============================================================\n    // This part runs every frame during animation. It MUST be fast.\n    // No Date objects, no heavy loops, just basic math.\n    const { currentWorldWidth, currentMonthLayouts } = useMemo(() => {\n        if (baseTimelineGrid.length === 0) {\n            return { currentWorldWidth: 2000, currentMonthLayouts: [] };\n        }\n\n        const layouts: MonthLayout[] = [];\n        let totalAbsWidth = 0;\n\n        // Fast loop over pre-calculated grid\n        for (let i = 0; i < baseTimelineGrid.length; i++) {\n            const node = baseTimelineGrid[i];\n\n            // MATH ONLY: Linear Interpolation\n            // width = linear + (density - linear) * t\n\n            // CORRECT: Apply clip factor ONLY to linear (time) component.\n            // Density component (content) handles its own \"size\" by count of items.\n            // If we clip density, we squeeze videos into tiny space.\n            const effectiveLinearWidth = node.linearWidth * node.clipFactor;\n\n            // For Density: Use FULL width. Do NOT clip. \n            // The content is the content. It needs X pixels. It shouldn't be cut off.\n            const effectiveDensityWidth = node.densityWidth;\n\n            // Interpolate\n            const absWidth = effectiveLinearWidth + (effectiveDensityWidth - effectiveLinearWidth) * timeLinearity;\n\n            layouts.push({\n                year: node.year,\n                month: node.month,\n                monthKey: node.monthKey,\n                label: node.label,\n                count: node.count,\n                startTs: node.startTs,\n                endTs: node.endTs,\n                daysInMonth: node.daysInMonth,\n                // Temporary absolute positions\n                startX: totalAbsWidth,\n                endX: totalAbsWidth + absWidth,\n                width: absWidth\n            });\n\n            totalAbsWidth += absWidth;\n        }\n\n        const finalWorldWidth = Math.max(2000, totalAbsWidth);\n\n        // Normalize positions (0-1)\n        const normalizedLayouts = layouts.map(l => ({\n            ...l,\n            startX: l.startX / Math.max(1, totalAbsWidth),\n            endX: l.endX / Math.max(1, totalAbsWidth),\n            width: l.width / Math.max(1, totalAbsWidth)\n        }));\n\n        return {\n            currentWorldWidth: finalWorldWidth,\n            currentMonthLayouts: normalizedLayouts\n        };\n\n    }, [baseTimelineGrid, timeLinearity]);\n\n    // Freeze World Width\n    const worldWidth = useFrozenValue({\n        value: currentWorldWidth,\n        version: structureVersion,\n        dependencies: [timeLinearity, videos.length > 0],\n        shouldUpdate: shouldStrictUpdate\n    });\n\n    // Freeze Layouts\n    const monthLayouts = useFrozenValue({\n        value: currentMonthLayouts,\n        version: structureVersion,\n        dependencies: [timeLinearity, videos.length > 0],\n        shouldUpdate: shouldStrictUpdate\n    });\n\n    // Derived regions\n    const monthRegions: MonthRegion[] = useMemo(() => {\n        if (monthLayouts.length === 0) return [];\n        let prevYear: number | null = null;\n        return monthLayouts.map(layout => {\n            const isFirst = layout.year !== prevYear;\n            prevYear = layout.year;\n            return {\n                month: layout.label,\n                year: layout.year,\n                startX: layout.startX,\n                endX: layout.endX,\n                center: (layout.startX + layout.endX) / 2,\n                daysInMonth: getDaysInMonth(layout.year, layout.month),\n                isFirstOfYear: isFirst\n            };\n        });\n    }, [monthLayouts]);\n\n    const yearMarkers: YearMarker[] = useMemo(() => {\n        const years: YearMarker[] = [];\n        let currentYear: number | null = null;\n        let yearStart = 0;\n        let yearEnd = 0;\n\n        monthRegions.forEach((region, i) => {\n            if (region.year !== currentYear) {\n                if (currentYear !== null) {\n                    years.push({ year: currentYear, startX: yearStart, endX: yearEnd });\n                }\n                currentYear = region.year;\n                yearStart = region.startX;\n            }\n            yearEnd = region.endX;\n            if (i === monthRegions.length - 1 && currentYear !== null) {\n                years.push({ year: currentYear, startX: yearStart, endX: yearEnd });\n            }\n        });\n        return years;\n    }, [monthRegions]);\n\n    return {\n        worldWidth,\n        stats: effectiveStats,\n        monthLayouts,\n        monthRegions,\n        yearMarkers\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTooltip.ts","messages":[{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTooltip.ts:24:5\n  22 |     // Track delay condition in ref to access fresh value in callbacks if needed\n  23 |     const delayShowConditionRef = useRef(delayShowCondition);\n> 24 |     delayShowConditionRef.current = delayShowCondition;\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot update ref during render\n  25 |\n  26 |     const closeTooltipSmoothly = useCallback(() => {\n  27 |         setIsTooltipClosing(true);","line":24,"column":5,"nodeType":null,"endLine":24,"endColumn":34}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useCallback } from 'react';\nimport type { TrendVideo } from '../../../../core/types/trends';\n\nexport interface TooltipData {\n    video: TrendVideo;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\nexport const useTimelineTooltip = ({ delayShowCondition = false }: { delayShowCondition?: boolean } = {}) => {\n    const [hoveredVideo, setHoveredVideo] = useState<TooltipData | null>(null);\n    const [isTooltipClosing, setIsTooltipClosing] = useState(false);\n\n    const isTooltipHoveredRef = useRef(false);\n    const hideTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const closeTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n    // New ref for show delay\n    const showTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    // Track delay condition in ref to access fresh value in callbacks if needed\n    const delayShowConditionRef = useRef(delayShowCondition);\n    delayShowConditionRef.current = delayShowCondition;\n\n    const closeTooltipSmoothly = useCallback(() => {\n        setIsTooltipClosing(true);\n        if (closeTimeoutRef.current) clearTimeout(closeTimeoutRef.current);\n        if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);\n\n        closeTimeoutRef.current = setTimeout(() => {\n            setHoveredVideo(null);\n            setIsTooltipClosing(false);\n        }, 200); // Wait for fade out\n    }, []);\n\n    const handleHoverVideo = useCallback((data: TooltipData | null) => {\n        if (data) {\n            // Clear any pending hide/close/show timers\n            if (hideTimeoutRef.current) clearTimeout(hideTimeoutRef.current);\n            if (closeTimeoutRef.current) clearTimeout(closeTimeoutRef.current);\n            if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);\n\n            setIsTooltipClosing(false);\n\n            if (delayShowConditionRef.current) {\n                // If we need to delay showing, set a timeout\n                // Only if not already showing a tooltip (optional refinement, but per spec \"hover on video\")\n                // If we are already showing a tooltip for *another* video, typically we switch instantly or also delay. \n                // Let's assume simple delay for now: any new hover target -> wait 1000ms.\n\n                // However, if we wanted \"instant switch if tooltip is already open\", we'd check `hoveredVideo`.\n                // But the request says \"time needed to show tooltip... increased to 1000ms\".\n                // So we'll force the delay.\n\n                showTimeoutRef.current = setTimeout(() => {\n                    setHoveredVideo(data);\n                }, 1000);\n            } else {\n                // Immediate show\n                setHoveredVideo(data);\n            }\n        } else {\n            // Mouse left a video\n            if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);\n\n            hideTimeoutRef.current = setTimeout(() => {\n                if (!isTooltipHoveredRef.current) {\n                    closeTooltipSmoothly();\n                }\n            }, 150); // Delay before starting fade out\n        }\n    }, [closeTooltipSmoothly]);\n\n    const handleTooltipMouseEnter = useCallback(() => {\n        isTooltipHoveredRef.current = true;\n        setIsTooltipClosing(false); // Cancel closing if we re-enter\n        if (closeTimeoutRef.current) clearTimeout(closeTimeoutRef.current);\n        if (hideTimeoutRef.current) clearTimeout(hideTimeoutRef.current);\n    }, []);\n\n    const handleTooltipMouseLeave = useCallback(() => {\n        isTooltipHoveredRef.current = false;\n        // Trigger generic close logic via state update or just null?\n        // In original code: setHoveredVideo(null) immediately.\n        setHoveredVideo(null);\n    }, []);\n\n    return {\n        hoveredVideo,\n        isTooltipClosing,\n        handleHoverVideo,\n        handleTooltipMouseEnter,\n        handleTooltipMouseLeave,\n        forceCloseTooltip: closeTooltipSmoothly\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts","messages":[{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:104:77\n  102 |     });\n  103 |\n> 104 |     const [transformState, setTransformStateInternal] = useState<Transform>(transformRef.current);\n      |                                                                             ^^^^^^^^^^^^^^^^^^^^ Passing a ref to a function may read its value during render\n  105 |\n  106 |     // Only update state if significantly changed to avoid thrashing\n  107 |     const setTransformState = useCallback((newTransform: Transform) => {","line":104,"column":77,"nodeType":null,"endLine":104,"endColumn":97},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:144:20\n  142 |     const dynamicWorldHeight = useMemo(() => {\n  143 |         if (viewportSize.height <= 0 || fitScale <= 0) {\n> 144 |             return lastValidWorldHeightRef.current; // Use last valid instead of fallback\n      |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  145 |         }\n  146 |         // Subtract vertical padding from available height\n  147 |         const availableHeight = viewportSize.height - headerHeight - totalVerticalPadding;","line":144,"column":20,"nodeType":null,"endLine":144,"endColumn":51},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:144:20\n  142 |     const dynamicWorldHeight = useMemo(() => {\n  143 |         if (viewportSize.height <= 0 || fitScale <= 0) {\n> 144 |             return lastValidWorldHeightRef.current; // Use last valid instead of fallback\n      |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  145 |         }\n  146 |         // Subtract vertical padding from available height\n  147 |         const availableHeight = viewportSize.height - headerHeight - totalVerticalPadding;","line":144,"column":20,"nodeType":null,"endLine":144,"endColumn":51},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:144:20\n  142 |     const dynamicWorldHeight = useMemo(() => {\n  143 |         if (viewportSize.height <= 0 || fitScale <= 0) {\n> 144 |             return lastValidWorldHeightRef.current; // Use last valid instead of fallback\n      |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  145 |         }\n  146 |         // Subtract vertical padding from available height\n  147 |         const availableHeight = viewportSize.height - headerHeight - totalVerticalPadding;","line":144,"column":20,"nodeType":null,"endLine":144,"endColumn":51},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:144:20\n  142 |     const dynamicWorldHeight = useMemo(() => {\n  143 |         if (viewportSize.height <= 0 || fitScale <= 0) {\n> 144 |             return lastValidWorldHeightRef.current; // Use last valid instead of fallback\n      |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  145 |         }\n  146 |         // Subtract vertical padding from available height\n  147 |         const availableHeight = viewportSize.height - headerHeight - totalVerticalPadding;","line":144,"column":20,"nodeType":null,"endLine":144,"endColumn":51},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:144:20\n  142 |     const dynamicWorldHeight = useMemo(() => {\n  143 |         if (viewportSize.height <= 0 || fitScale <= 0) {\n> 144 |             return lastValidWorldHeightRef.current; // Use last valid instead of fallback\n      |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  145 |         }\n  146 |         // Subtract vertical padding from available height\n  147 |         const availableHeight = viewportSize.height - headerHeight - totalVerticalPadding;","line":144,"column":20,"nodeType":null,"endLine":144,"endColumn":51},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:149:9\n  147 |         const availableHeight = viewportSize.height - headerHeight - totalVerticalPadding;\n  148 |         const calculated = availableHeight / fitScale;\n> 149 |         lastValidWorldHeightRef.current = calculated; // Update ref\n      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot update ref during render\n  150 |         return calculated;\n  151 |     }, [viewportSize.height, headerHeight, fitScale, totalVerticalPadding]);\n  152 |","line":149,"column":9,"nodeType":null,"endLine":149,"endColumn":40},{"ruleId":"prefer-const","severity":2,"message":"'constrainedOffsetX' is never reassigned. Use 'const' instead.","line":198,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":198,"endColumn":27},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:317:23\n  315 |     // the anchored transform synchronously if a layout change is detected.\n  316 |\n> 317 |     const prevWidth = prevWorldWidthRef.current;\n      |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  318 |     const prevHeight = prevWorldHeightRef.current;\n  319 |     const currentWidth = worldWidth;\n  320 |     const currentHeight = dynamicWorldHeight;","line":317,"column":23,"nodeType":null,"endLine":317,"endColumn":48},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:317:23\n  315 |     // the anchored transform synchronously if a layout change is detected.\n  316 |\n> 317 |     const prevWidth = prevWorldWidthRef.current;\n      |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  318 |     const prevHeight = prevWorldHeightRef.current;\n  319 |     const currentWidth = worldWidth;\n  320 |     const currentHeight = dynamicWorldHeight;","line":317,"column":23,"nodeType":null,"endLine":317,"endColumn":48},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:318:24\n  316 |\n  317 |     const prevWidth = prevWorldWidthRef.current;\n> 318 |     const prevHeight = prevWorldHeightRef.current;\n      |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  319 |     const currentWidth = worldWidth;\n  320 |     const currentHeight = dynamicWorldHeight;\n  321 |     const widthChanged = Math.abs(currentWidth - prevWidth) >= 1;","line":318,"column":24,"nodeType":null,"endLine":318,"endColumn":50},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:318:24\n  316 |\n  317 |     const prevWidth = prevWorldWidthRef.current;\n> 318 |     const prevHeight = prevWorldHeightRef.current;\n      |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  319 |     const currentWidth = worldWidth;\n  320 |     const currentHeight = dynamicWorldHeight;\n  321 |     const widthChanged = Math.abs(currentWidth - prevWidth) >= 1;","line":318,"column":24,"nodeType":null,"endLine":318,"endColumn":50},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:327:9\n  325 |\n  326 |     // Only apply correction if we have a pending anchor request\n> 327 |     if (pendingAnchorRef.current !== null && (widthChanged || heightChanged)) {\n      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  328 |         activeTransform = calculatePreservedTransform({\n  329 |             currentTransform: transformState,\n  330 |             viewportSize,","line":327,"column":9,"nodeType":null,"endLine":327,"endColumn":42},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:327:9\n  325 |\n  326 |     // Only apply correction if we have a pending anchor request\n> 327 |     if (pendingAnchorRef.current !== null && (widthChanged || heightChanged)) {\n      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  328 |         activeTransform = calculatePreservedTransform({\n  329 |             currentTransform: transformState,\n  330 |             viewportSize,","line":327,"column":9,"nodeType":null,"endLine":327,"endColumn":42},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:327:9\n  325 |\n  326 |     // Only apply correction if we have a pending anchor request\n> 327 |     if (pendingAnchorRef.current !== null && (widthChanged || heightChanged)) {\n      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  328 |         activeTransform = calculatePreservedTransform({\n  329 |             currentTransform: transformState,\n  330 |             viewportSize,","line":327,"column":9,"nodeType":null,"endLine":327,"endColumn":42},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:328:55\n  326 |     // Only apply correction if we have a pending anchor request\n  327 |     if (pendingAnchorRef.current !== null && (widthChanged || heightChanged)) {\n> 328 |         activeTransform = calculatePreservedTransform({\n      |                                                       ^\n> 329 |             currentTransform: transformState,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 330 |             viewportSize,\n      \n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 346 |             }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 347 |         });\n      | ^^^^^^^^^^ Passing a ref to a function may read its value during render\n  348 |     }\n  349 |\n  350 |     // Auto-fit OR Anchor (Commit Phase)","line":328,"column":55,"nodeType":null,"endLine":347,"endColumn":10},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:332:30\n  330 |             viewportSize,\n  331 |             headerHeight,\n> 332 |             worldDimensions: {\n      |                              ^\n> 333 |                 prevWidth,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 334 |                 currWidth: currentWidth,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 335 |                 prevHeight,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 336 |                 currHeight: currentHeight\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 337 |             },\n      | ^^^^^^^^^^^^^^ Cannot access ref value during render\n  338 |             anchor: {\n  339 |                 time: pendingAnchorRef.current.time,\n  340 |                 xNorm: pendingAnchorRef.current.xNorm,","line":332,"column":30,"nodeType":null,"endLine":337,"endColumn":14},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:338:21\n  336 |                 currHeight: currentHeight\n  337 |             },\n> 338 |             anchor: {\n      |                     ^\n> 339 |                 time: pendingAnchorRef.current.time,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 340 |                 xNorm: pendingAnchorRef.current.xNorm,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 341 |                 yNorm: pendingAnchorRef.current.yNorm,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 342 |                 screenX: pendingAnchorRef.current.screenX,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 343 |                 screenY: pendingAnchorRef.current.screenY,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 344 |                 monthLayouts,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 345 |                 stats\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 346 |             }\n      | ^^^^^^^^^^^^^^ Cannot access ref value during render\n  347 |         });\n  348 |     }\n  349 |","line":338,"column":21,"nodeType":null,"endLine":346,"endColumn":14},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:339:23\n  337 |             },\n  338 |             anchor: {\n> 339 |                 time: pendingAnchorRef.current.time,\n      |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  340 |                 xNorm: pendingAnchorRef.current.xNorm,\n  341 |                 yNorm: pendingAnchorRef.current.yNorm,\n  342 |                 screenX: pendingAnchorRef.current.screenX,","line":339,"column":23,"nodeType":null,"endLine":339,"endColumn":52},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:340:24\n  338 |             anchor: {\n  339 |                 time: pendingAnchorRef.current.time,\n> 340 |                 xNorm: pendingAnchorRef.current.xNorm,\n      |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  341 |                 yNorm: pendingAnchorRef.current.yNorm,\n  342 |                 screenX: pendingAnchorRef.current.screenX,\n  343 |                 screenY: pendingAnchorRef.current.screenY,","line":340,"column":24,"nodeType":null,"endLine":340,"endColumn":54},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:341:24\n  339 |                 time: pendingAnchorRef.current.time,\n  340 |                 xNorm: pendingAnchorRef.current.xNorm,\n> 341 |                 yNorm: pendingAnchorRef.current.yNorm,\n      |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  342 |                 screenX: pendingAnchorRef.current.screenX,\n  343 |                 screenY: pendingAnchorRef.current.screenY,\n  344 |                 monthLayouts,","line":341,"column":24,"nodeType":null,"endLine":341,"endColumn":54},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:342:26\n  340 |                 xNorm: pendingAnchorRef.current.xNorm,\n  341 |                 yNorm: pendingAnchorRef.current.yNorm,\n> 342 |                 screenX: pendingAnchorRef.current.screenX,\n      |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  343 |                 screenY: pendingAnchorRef.current.screenY,\n  344 |                 monthLayouts,\n  345 |                 stats","line":342,"column":26,"nodeType":null,"endLine":342,"endColumn":58},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:343:26\n  341 |                 yNorm: pendingAnchorRef.current.yNorm,\n  342 |                 screenX: pendingAnchorRef.current.screenX,\n> 343 |                 screenY: pendingAnchorRef.current.screenY,\n      |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  344 |                 monthLayouts,\n  345 |                 stats\n  346 |             }","line":343,"column":26,"nodeType":null,"endLine":343,"endColumn":58},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:451:8\n  449 |         setTransformState(newTransform);\n  450 |\n> 451 |     }, [worldWidth, dynamicWorldHeight, videosLength, viewportSize, headerHeight, handleAutoFit, transformState, setTransformState, monthLayouts, stats, totalPadding]); // Dependencies\n      |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  452 |\n  453 |     // Track latest store config in ref to avoid effect dependency loops\n  454 |     const latestConfigRef = useRef({ zoomLevel, offsetX, offsetY });","line":451,"column":8,"nodeType":null,"endLine":451,"endColumn":167},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineTransform.ts:519:12\n  517 |     }, [viewportSize, transformState, worldWidth, monthLayouts, stats]);\n  518 |\n> 519 |     return {\n      |            ^\n> 520 |         containerRef,\n      | ^^^^^^^^^^^^^^^^^^^^^\n> 521 |         containerSizeRef,\n      \n> 533 |         currentContentHash, // Expose hash for manual updates\n      | ^^^^^^^^^^^^^^^^^^^^^\n> 534 |         getCenterTime\n      | ^^^^^^^^^^^^^^^^^^^^^\n> 535 |     };\n      | ^^^^^^ Cannot access ref value during render\n  536 | };\n  537 |","line":519,"column":12,"nodeType":null,"endLine":535,"endColumn":6}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useCallback, useEffect, useLayoutEffect, useMemo } from 'react';\nimport { useDebounce } from '../../../../core/hooks/useDebounce';\nimport { useTrendStore } from '../../../../core/stores/trendStore';\nimport { useChannelStore } from '../../../../core/stores/channelStore';\nimport { calculatePreservedTransform } from '../utils/timelineMath';\nimport type { MonthLayout, TimelineStats } from '../../../../core/types/trends';\n\n/**\n * useTimelineTransform  Viewport State Management (Miro-like)\n * \n * ARCHITECTURE OVERVIEW:\n * ----------------------\n * This hook manages zoom/pan state with automatic save/restore per content hash.\n * It follows the \"Miro-like\" pattern: always save on change, always restore on return.\n * \n * KEY COMPONENTS:\n * 1. Transform State       Current {scale, offsetX, offsetY}\n * 2. Content Hash          Unique ID per channel+niche combination\n * 3. savedConfigs          Map<hash, config> persisted in Zustand store\n * \n * EFFECT COORDINATION:\n * --------------------\n * Two effects manage viewport changes and can conflict:\n * \n *   useEffect (Restore)          useLayoutEffect (Ratio Preservation)\n *            \n *   Trigger: hash change         Trigger: worldWidth/Height change\n *   Action: setTransform(saved)  Action: setTransform(calculated)\n * \n * RACE CONDITION PROBLEM:\n * -----------------------\n * On page load: Restore sets saved values  Data loads  worldWidth changes \n * Ratio Preservation recalculates offset  Wrong values get saved  DRIFT\n * \n * SOLUTION (skipNextRatioPreservationRef):\n * ----------------------------------------\n * After restore, we set skipNextRatioPreservationRef = true.\n * When useLayoutEffect sees worldWidth change, it checks this flag:\n *   - If true: skip ratio preservation, reset flag, return early\n *   - If false: proceed with normal ratio preservation\n * \n * This ensures restored values are not immediately overwritten.\n */\n\nexport interface Transform {\n    scale: number;\n    offsetX: number;\n    offsetY: number;\n}\n\ninterface UseTimelineTransformProps {\n    worldWidth: number;\n    headerHeight: number;\n    paddingLeft: number;\n    paddingRight: number;\n    paddingTop: number;\n    paddingBottom: number;\n    videosLength: number;\n    // New props for timestamp anchoring\n    monthLayouts: MonthLayout[];\n    stats: TimelineStats;\n}\n\nexport const useTimelineTransform = ({\n    worldWidth,\n    headerHeight,\n    paddingLeft,\n    paddingRight,\n    paddingTop,\n    paddingBottom,\n    videosLength,\n    monthLayouts,\n    stats\n}: UseTimelineTransformProps) => {\n    // Total padding for calculations that need both\n    const totalPadding = paddingLeft + paddingRight;\n    const totalVerticalPadding = paddingTop + paddingBottom;\n    const { timelineConfig, setTimelineConfig, selectedChannelId, trendsFilters, savedConfigs } = useTrendStore();\n    const { currentChannel } = useChannelStore();\n    const { zoomLevel, offsetX, offsetY, contentHash: savedContentHash } = timelineConfig;\n\n    // Calculate current content hash based on context (Channel ID + Filters)\n    const currentContentHash = useMemo(() => {\n        // NOTE: We deliberately EXCLUDE visibleIds (channel visibility) from this hash.\n        // Changing channel visibility (eye icon) should NOT trigger a view reset.\n        // Only switching channels or changing filters/niches should reset the view.\n\n        // Include Niche ID in hash to trigger auto-fit when switching niches\n        const nicheFilter = trendsFilters.find(f => f.type === 'niche');\n        const nicheKey = nicheFilter ? (nicheFilter.value as string[]).sort().join(',') : 'all';\n\n        // Include selectedChannelId to distinguish Global view from Specific Channel view\n        // CRITICAL: Include currentChannel.id (User Channel) to prevent config collisions between users!\n        return `${currentChannel?.id || 'anon'}:${selectedChannelId || 'global'}:${nicheKey}`;\n    }, [currentChannel?.id, selectedChannelId, trendsFilters]);\n\n    // Transform state\n    const transformRef = useRef<Transform>({\n        scale: zoomLevel || 0.01,\n        offsetX: offsetX || 0,\n        offsetY: offsetY || 0\n    });\n\n    const [transformState, setTransformStateInternal] = useState<Transform>(transformRef.current);\n\n    // Only update state if significantly changed to avoid thrashing\n    const setTransformState = useCallback((newTransform: Transform) => {\n        transformRef.current = newTransform;\n        setTransformStateInternal({ ...newTransform });\n    }, []);\n\n    // Container size tracking\n    const containerRef = useRef<HTMLDivElement>(null);\n    const containerSizeRef = useRef({ width: 0, height: 0 });\n    const [viewportSize, setViewportSize] = useState({ width: 0, height: 0 });\n\n    useEffect(() => {\n        if (!containerRef.current) return;\n        const observer = new ResizeObserver((entries) => {\n            for (const entry of entries) {\n                const newSize = {\n                    width: entry.contentRect.width,\n                    height: entry.contentRect.height\n                };\n                containerSizeRef.current = newSize;\n                setViewportSize(newSize);\n            }\n        });\n        observer.observe(containerRef.current);\n        return () => observer.disconnect();\n    }, []);\n\n    // 1. Calculate 'Fit Scale' based on Width\n    const fitScale = useMemo(() => {\n        if (viewportSize.width <= 0) return 0.001;\n        return (viewportSize.width - totalPadding) / Math.max(1, worldWidth);\n    }, [viewportSize.width, totalPadding, worldWidth]);\n\n    // 2. Derive Dynamic World Height (with stability)\n    // Account for vertical padding to create safe zones at top and bottom\n    const lastValidWorldHeightRef = useRef(1000);\n    const dynamicWorldHeight = useMemo(() => {\n        if (viewportSize.height <= 0 || fitScale <= 0) {\n            return lastValidWorldHeightRef.current; // Use last valid instead of fallback\n        }\n        // Subtract vertical padding from available height\n        const availableHeight = viewportSize.height - headerHeight - totalVerticalPadding;\n        const calculated = availableHeight / fitScale;\n        lastValidWorldHeightRef.current = calculated; // Update ref\n        return calculated;\n    }, [viewportSize.height, headerHeight, fitScale, totalVerticalPadding]);\n\n    // 3. Min Scale\n    const minScale = fitScale;\n\n    // Clamp Transform to Viewport Bounds\n    // WHY: Prevents user from panning content completely off-screen.\n    // X-axis uses dynamic overscroll (grows with zoom) to allow centering edge items.\n    // Y-axis snaps to top when content fits, clamps when content is larger.\n    const clampTransform = useCallback((\n        t: Transform,\n        viewportWidth: number,\n        viewportHeight: number\n    ): Transform => {\n        const scaledHeight = dynamicWorldHeight * t.scale;\n\n        // X-Axis clamping\n        let constrainedOffsetX: number;\n\n        // Dynamic Overscroll:\n        // When at minScale (Fit), we want rigid boundaries (overscroll = 0).\n        // Dynamic Overscroll:\n        // Ultra-tight growth: (zoomFactor - 1) * 0.1 * viewportWidth.\n        // Cap at 12% of viewport. This is enough to center small/medium items at edges, \n        // but prevents large voids.\n        const zoomFactor = t.scale / Math.max(minScale, 0.000001);\n        const dynamicOverscroll = Math.max(0, (zoomFactor - 1) * 0.1 * viewportWidth);\n\n        // Cap overscroll at 12% of viewport\n        const overscrollX = Math.min(viewportWidth * 0.12, dynamicOverscroll);\n\n        // Calculate the safe bounds (with padding + overscroll)\n        // Upper bound (Leftmost position): Left Padding + Overscroll\n        const maxOffsetX = paddingLeft + overscrollX;\n\n        const maxScale = Math.max(t.scale, minScale); // Ensure we don't clamp below minScale logic\n        const effectiveWorldWidth = worldWidth * maxScale;\n\n        // Lower bound (Rightmost position): Viewport - World - Padding - Overscroll\n        const minOffsetX = viewportWidth - (effectiveWorldWidth + paddingRight) - overscrollX;\n\n        // Bounds:\n        // We simply clamp between min and max.\n        // Note: minOffsetX will be very negative for large worlds.\n        const lowerBound = Math.min(maxOffsetX, minOffsetX);\n        const upperBound = Math.max(maxOffsetX, minOffsetX);\n\n        constrainedOffsetX = Math.max(lowerBound, Math.min(upperBound, t.offsetX));\n\n        // Y-Axis clamping\n        let constrainedOffsetY: number;\n        const availableHeight = viewportHeight - headerHeight - totalVerticalPadding;\n\n        if (scaledHeight <= availableHeight) {\n            // Content fits: align to top padding (similar to left padding for X)\n            constrainedOffsetY = headerHeight + paddingTop;\n        } else {\n            // Content is larger: Clamp with padding bounds\n            const maxOffsetY = headerHeight + paddingTop;\n            const minOffsetY = viewportHeight - paddingBottom - scaledHeight;\n            constrainedOffsetY = Math.max(minOffsetY, Math.min(maxOffsetY, t.offsetY));\n        }\n\n        return {\n            scale: t.scale,\n            offsetX: constrainedOffsetX,\n            offsetY: constrainedOffsetY\n        };\n    }, [worldWidth, dynamicWorldHeight, headerHeight, paddingLeft, paddingRight, paddingTop, paddingBottom, totalVerticalPadding, minScale]);\n\n    // Calculate Auto Fit Transform (Pure Calculation)\n    const calculateAutoFitTransform = useCallback(() => {\n        if (videosLength === 0 || viewportSize.width <= 0) return null;\n\n        const currentFitScale = (viewportSize.width - totalPadding) / Math.max(1, worldWidth);\n\n        // Position content with padding offsets\n        const newOffsetX = paddingLeft;\n        const newOffsetY = headerHeight + paddingTop;\n\n        return { scale: currentFitScale, offsetX: newOffsetX, offsetY: newOffsetY };\n    }, [videosLength, viewportSize, totalPadding, paddingLeft, paddingTop, worldWidth, headerHeight]);\n\n    // Handle Auto Fit (Instant)\n    // WHY: Fits all content in viewport. Called on first load, hash change (no saved state), or manual reset.\n    const handleAutoFit = useCallback(() => {\n        const newState = calculateAutoFitTransform();\n        if (!newState) return;\n        setTransformState(newState);\n\n        setTimelineConfig({\n            zoomLevel: newState.scale,\n            offsetX: newState.offsetX,\n            offsetY: newState.offsetY,\n            contentHash: currentContentHash\n        });\n    }, [calculateAutoFitTransform, setTransformState, setTimelineConfig, currentContentHash]);\n\n    // Track initialization\n    const hasInitializedRef = useRef(false);\n    const prevViewportSizeRef = useRef({ width: 0, height: 0 });\n    // Skip ratio preservation after restore to prevent drift\n    const skipNextRatioPreservationRef = useRef(false);\n\n    // Restore or Auto-Fit on Mount/Hash Change (Miro-like)\n    // WHY: Single effect handles both initial load and navigation between channels/niches.\n    // Logic: If savedConfigs[hash] exists  restore it, otherwise  auto-fit.\n    useEffect(() => {\n        // Wait for data to be ready\n        if (videosLength === 0 || viewportSize.width === 0) return;\n\n        // Skip if already showing the correct hash (no change needed)\n        if (hasInitializedRef.current && savedContentHash === currentContentHash) return;\n\n        // Mark first run and capture viewport size\n        if (!hasInitializedRef.current) {\n            hasInitializedRef.current = true;\n            prevViewportSizeRef.current = viewportSize;\n        }\n\n        const savedConfig = savedConfigs[currentContentHash];\n        if (savedConfig) {\n            setTransformState({\n                scale: savedConfig.zoomLevel,\n                offsetX: savedConfig.offsetX,\n                offsetY: savedConfig.offsetY\n            });\n            setTimelineConfig({\n                ...savedConfig,\n                contentHash: currentContentHash\n            });\n            // Skip next ratio preservation to prevent drift\n            skipNextRatioPreservationRef.current = true;\n        } else {\n            handleAutoFit();\n        }\n    }, [videosLength, viewportSize, savedContentHash, currentContentHash, savedConfigs, setTransformState, setTimelineConfig, handleAutoFit]);\n\n    // Resize handling (Miro-like)\n    // WHY: On resize, just update ref. Ratio preservation is handled by useLayoutEffect.\n    // Auto-fit only happens on first load or hash change, NOT on resize.\n    useEffect(() => {\n        if (!hasInitializedRef.current) return;\n        prevViewportSizeRef.current = viewportSize;\n    }, [viewportSize]);\n\n\n    // --- Interaction & Update Logic using useLayoutEffect (Same as before) ---\n    // (This block keeps the relative positioning on data/viewport changes)\n    const prevWorldWidthRef = useRef(worldWidth);\n    const prevWorldHeightRef = useRef(dynamicWorldHeight);\n    const pendingAnchorRef = useRef<{ time: number; xNorm?: number; yNorm?: number; screenX?: number; screenY?: number } | null>(null);\n\n    // Provide a way to queue a time-anchor (e.g. from hotkeys or external actions)\n    const anchorToTime = useCallback((timeOrObj: number | { time: number; xNorm?: number; yNorm?: number; screenX?: number; screenY?: number }) => {\n        if (typeof timeOrObj === 'number') {\n            pendingAnchorRef.current = { time: timeOrObj };\n        } else {\n            pendingAnchorRef.current = timeOrObj;\n        }\n    }, []);\n\n    // 4. Render-Phase Anchoring (Synchronous)\n    // To prevent flicker (Render 1: Bad Layout, Render 2: Corrected), we calculate \n    // the anchored transform synchronously if a layout change is detected.\n\n    const prevWidth = prevWorldWidthRef.current;\n    const prevHeight = prevWorldHeightRef.current;\n    const currentWidth = worldWidth;\n    const currentHeight = dynamicWorldHeight;\n    const widthChanged = Math.abs(currentWidth - prevWidth) >= 1;\n    const heightChanged = Math.abs(currentHeight - prevHeight) >= 1;\n\n    let activeTransform = transformState;\n\n    // Only apply correction if we have a pending anchor request\n    if (pendingAnchorRef.current !== null && (widthChanged || heightChanged)) {\n        activeTransform = calculatePreservedTransform({\n            currentTransform: transformState,\n            viewportSize,\n            headerHeight,\n            worldDimensions: {\n                prevWidth,\n                currWidth: currentWidth,\n                prevHeight,\n                currHeight: currentHeight\n            },\n            anchor: {\n                time: pendingAnchorRef.current.time,\n                xNorm: pendingAnchorRef.current.xNorm,\n                yNorm: pendingAnchorRef.current.yNorm,\n                screenX: pendingAnchorRef.current.screenX,\n                screenY: pendingAnchorRef.current.screenY,\n                monthLayouts,\n                stats\n            }\n        });\n    }\n\n    // Auto-fit OR Anchor (Commit Phase)\n    useLayoutEffect(() => {\n        // We already have the boolean flags (widthChanged, heightChanged) \n        // calculated in the render scope, but effect scope is different.\n        // We need to re-check refs vs props here to be safe.\n        const pWidth = prevWorldWidthRef.current;\n        const pHeight = prevWorldHeightRef.current;\n        const cWidth = worldWidth;\n        const cHeight = dynamicWorldHeight;\n\n        const wChanged = Math.abs(cWidth - pWidth) >= 1;\n        const hChanged = Math.abs(cHeight - pHeight) >= 1;\n\n        // Update refs immediately if changed\n        if (wChanged) prevWorldWidthRef.current = cWidth;\n        if (hChanged) prevWorldHeightRef.current = cHeight;\n\n        /**\n         * PRIORITY 1: Pending Anchor (User Action / Internal Request)\n         * Highest priority: explicit request to anchor to a specific time/position.\n         */\n        if (pendingAnchorRef.current !== null) {\n            const newTransform = calculatePreservedTransform({\n                currentTransform: transformState,\n                viewportSize,\n                headerHeight,\n                worldDimensions: {\n                    prevWidth: pWidth,\n                    currWidth: cWidth,\n                    prevHeight: pHeight,\n                    currHeight: cHeight\n                },\n                anchor: {\n                    time: pendingAnchorRef.current.time,\n                    xNorm: pendingAnchorRef.current.xNorm,\n                    yNorm: pendingAnchorRef.current.yNorm,\n                    screenX: pendingAnchorRef.current.screenX,\n                    screenY: pendingAnchorRef.current.screenY,\n                    monthLayouts,\n                    stats\n                }\n            });\n\n            setTransformState(newTransform);\n            pendingAnchorRef.current = null;\n            return;\n        }\n\n        // Only proceed if dimensions actually changed\n        if (!wChanged && !hChanged) return;\n\n        // Skip ratio preservation if we just restored (prevents drift)\n        if (skipNextRatioPreservationRef.current) {\n            skipNextRatioPreservationRef.current = false;\n            return;\n        }\n\n        /**\n         * PRIORITY 2: Auto-Fit Maintenance\n         * If the view was roughly fitted before the resize (within 5% tolerance),\n         * maintain the \"fitted\" state by re-running auto-fit on the new dimensions.\n         */\n        const prevFitScale = (viewportSize.width - totalPadding) / Math.max(1, pWidth);\n        const scaleDiff = Math.abs(transformState.scale - prevFitScale);\n        const isRoughlyFitted = scaleDiff < 0.001 || (scaleDiff / prevFitScale) < 0.05;\n\n        if (isRoughlyFitted && wChanged) {\n            handleAutoFit();\n            return;\n        }\n\n        /**\n         * PRIORITY 3: Initialization / Placeholder Transition\n         * If transitioning from a placeholder state (small width), do not attempt\n         * ratio preservation as it leads to incorrect jumps. Just accept the new size.\n         */\n        const isTransitionFromPlaceholder = pWidth <= 2500 && Math.abs(transformState.offsetX) > 1;\n        if (isTransitionFromPlaceholder) {\n            return;\n        }\n\n        /**\n         * PRIORITY 4: Standard Ratio Preservation\n         * Default behavior: Adjust transform to keep the same relative time range\n         * visible on screen despite the world content growing/shrinking.\n         */\n        const newTransform = calculatePreservedTransform({\n            currentTransform: transformState,\n            viewportSize,\n            headerHeight,\n            worldDimensions: {\n                prevWidth: pWidth,\n                currWidth: cWidth,\n                prevHeight: pHeight,\n                currHeight: cHeight\n            }\n            // No anchor implies standard center-ratio preservation\n        });\n\n        setTransformState(newTransform);\n\n    }, [worldWidth, dynamicWorldHeight, videosLength, viewportSize, headerHeight, handleAutoFit, transformState, setTransformState, monthLayouts, stats, totalPadding]); // Dependencies\n\n    // Track latest store config in ref to avoid effect dependency loops\n    const latestConfigRef = useRef({ zoomLevel, offsetX, offsetY });\n    useEffect(() => {\n        latestConfigRef.current = { zoomLevel, offsetX, offsetY };\n    }, [zoomLevel, offsetX, offsetY]);\n\n    // Persist to store (Debounced)\n    const debouncedTransform = useDebounce(transformState, 500);\n    const { setVisualScale } = useTrendStore();\n\n    // Sync current scale to store for external consumers (like DnD ghost)\n    useEffect(() => {\n        setVisualScale(transformState.scale);\n    }, [transformState.scale, setVisualScale]);\n\n    // Persist viewport to per-contentHash storage (Miro-like: always save)\n    // WHY: Debounced save ensures we don't thrash the store on every frame.\n    // Threshold check prevents saving when values haven't meaningfully changed.\n    const { saveConfigForHash } = useTrendStore();\n\n    useEffect(() => {\n        const { zoomLevel: sZoom, offsetX: sX, offsetY: sY } = latestConfigRef.current;\n        if (\n            Math.abs(debouncedTransform.scale - sZoom) > 0.001 ||\n            Math.abs(debouncedTransform.offsetX - sX) > 1 ||\n            Math.abs(debouncedTransform.offsetY - sY) > 1\n        ) {\n            const configUpdate = {\n                zoomLevel: debouncedTransform.scale,\n                offsetX: debouncedTransform.offsetX,\n                offsetY: debouncedTransform.offsetY,\n                contentHash: currentContentHash\n            };\n\n            // Update current session config\n            setTimelineConfig(configUpdate);\n\n            // Also persist to per-hash storage for restoration on next visit\n            saveConfigForHash(currentContentHash, configUpdate);\n        }\n    }, [debouncedTransform, setTimelineConfig, currentContentHash, saveConfigForHash]);\n\n    // Helper to get time at center of viewport\n    const getCenterTime = useCallback(() => {\n        const { width } = viewportSize;\n        if (width <= 0) return Date.now();\n\n        const { scale, offsetX } = transformState;\n        const centerX = width / 2;\n        const worldX = (centerX - offsetX) / scale;\n        const xNorm = worldX / Math.max(1, worldWidth);\n\n        // Inverse mapping: xNorm -> Time\n        // Check month layouts first\n        for (const layout of monthLayouts) {\n            if (xNorm >= layout.startX && xNorm <= layout.endX) {\n                const localProgress = (xNorm - layout.startX) / layout.width;\n                return layout.startTs + localProgress * (layout.endTs - layout.startTs);\n            }\n        }\n\n        // Fallback to global linear interpolation\n        const range = stats.maxDate - stats.minDate;\n        return stats.minDate + xNorm * range;\n    }, [viewportSize, transformState, worldWidth, monthLayouts, stats]);\n\n    return {\n        containerRef,\n        containerSizeRef,\n        viewportSize,\n        transformState: activeTransform,\n        transformRef,\n        setTransformState,\n        clampTransform,\n        handleAutoFit,\n        minScale,\n        dynamicWorldHeight,\n        fitScale,\n        anchorToTime,\n        calculateAutoFitTransform,\n        currentContentHash, // Expose hash for manual updates\n        getCenterTime\n    };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTimelineVirtualization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/hooks/useTrendBaseline.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/layers/TimelineAverageLine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/layers/TimelineDotsLayer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/layers/TimelineDotsLayer.tsx:75:9\n  73 |     // Initialize DPR\n  74 |     useEffect(() => {\n> 75 |         setDpr(window.devicePixelRatio || 1);\n     |         ^^^^^^ Avoid calling setState() directly within an effect\n  76 |     }, []);\n  77 |\n  78 |     // Easing function for smooth animation","line":75,"column":9,"nodeType":null,"endLine":75,"endColumn":15},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/layers/TimelineDotsLayer.tsx:86:13\n  84 |         if (internalFocusedId) {\n  85 |             // Animate IN\n> 86 |             setLastFocusedId(internalFocusedId);\n     |             ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  87 |             animTargetRef.current = 1;\n  88 |             animStartRef.current = animProgress;\n  89 |             animStartTimeRef.current = performance.now();","line":86,"column":13,"nodeType":null,"endLine":86,"endColumn":29},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'animRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'animRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":128,"column":51,"nodeType":"Identifier","endLine":128,"endColumn":58},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'animProgress' and 'lastFocusedId'. Either include them or remove the dependency array.","line":129,"column":8,"nodeType":"ArrayExpression","endLine":129,"endColumn":27,"suggestions":[{"desc":"Update the dependencies array to be: [animProgress, internalFocusedId, lastFocusedId]","fix":{"range":[5346,5365],"text":"[animProgress, internalFocusedId, lastFocusedId]"}}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/layers/TimelineDotsLayer.tsx:153:9\n  151 |\n  152 |         // Initialize animation state for new transitions\n> 153 |         setSelectionAnimProgress(prev => {\n      |         ^^^^^^^^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  154 |             const next = new Map(prev);\n  155 |             newlySelected.forEach(id => {\n  156 |                 // Inherit hover animation progress if this dot was being hovered","line":153,"column":9,"nodeType":null,"endLine":153,"endColumn":33},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'selectionAnimRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'selectionAnimRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":211,"column":60,"nodeType":"Identifier","endLine":211,"endColumn":67},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'animProgress', 'internalFocusedId', 'lastFocusedId', and 'selectionAnimProgress'. Either include them or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setSelectionAnimProgress' needs the current value of 'internalFocusedId'.","line":212,"column":8,"nodeType":"ArrayExpression","endLine":212,"endColumn":24,"suggestions":[{"desc":"Update the dependencies array to be: [activeVideoIds, animProgress, internalFocusedId, lastFocusedId, selectionAnimProgress]","fix":{"range":[8809,8825],"text":"[activeVideoIds, animProgress, internalFocusedId, lastFocusedId, selectionAnimProgress]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useLayoutEffect has missing dependencies: 'getPercentileGroup' and 'getVisibleWorldBounds'. Either include them or remove the dependency array. If 'getPercentileGroup' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":391,"column":8,"nodeType":"ArrayExpression","endLine":391,"endColumn":152,"suggestions":[{"desc":"Update the dependencies array to be: [videoPositions, transform, worldWidth, worldHeight, activeVideoIds, internalFocusedId, lastFocusedId, dpr, animProgress, selectionAnimProgress, getVisibleWorldBounds, getPercentileGroup]","fix":{"range":[17282,17426],"text":"[videoPositions, transform, worldWidth, worldHeight, activeVideoIds, internalFocusedId, lastFocusedId, dpr, animProgress, selectionAnimProgress, getVisibleWorldBounds, getPercentileGroup]"}}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useLayoutEffect, useEffect, useState } from 'react';\nimport type { TrendVideo, VideoPosition } from '../../../../core/types/trends';\nimport { getDotStyle } from '../../../../core/utils/trendStyles';\nimport {\n    ANIMATION_DURATION_MS,\n    DOT_HIT_BUFFER_PX,\n    HOVER_DEBOUNCE_MS,\n    MIN_INTERACTION_SIZE_PX,\n    TOOLTIP_SHOW_DELAY_MS\n} from '../utils/timelineConstants';\n\ninterface TimelineDotsLayerProps {\n    videoPositions: VideoPosition[];\n    transform: { scale: number; offsetX: number; offsetY: number };\n    worldWidth: number;\n    worldHeight: number;\n    activeVideoIds: Set<string>;\n    getPercentileGroup: (videoId: string) => string | undefined;\n    onHoverVideo: (data: { video: TrendVideo; x: number; y: number; width: number; height: number } | null) => void;\n    onClickVideo: (video: TrendVideo, e: React.MouseEvent) => void;\n    onDoubleClickVideo: (video: TrendVideo, worldX: number, worldY: number, e: React.MouseEvent) => void;\n    onClickEmpty?: () => void;\n    /** Used to reduce hit buffer when dots are densely packed (0 = no spread, 1 = full spread) */\n    verticalSpread?: number;\n}\n\nexport const TimelineDotsLayer: React.FC<TimelineDotsLayerProps> = ({\n    videoPositions,\n    transform,\n    worldWidth,\n    worldHeight,\n    activeVideoIds,\n    getPercentileGroup,\n    onHoverVideo,\n    onClickVideo,\n    onDoubleClickVideo,\n    onClickEmpty,\n    verticalSpread = 1.0\n}) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const containerRef = useRef<HTMLDivElement>(null);\n    const [dpr, setDpr] = useState(1);\n\n    // Internal Interactions\n    const [internalFocusedId, setInternalFocusedId] = useState<string | null>(null);\n    const [lastFocusedId, setLastFocusedId] = useState<string | null>(null);  // For fade-out animation\n\n    // Selection Animation State - track which dots are animating their selection state\n    const prevActiveIdsRef = useRef<Set<string>>(new Set());\n    const [selectionAnimProgress, setSelectionAnimProgress] = useState<Map<string, number>>(new Map());\n    const selectionAnimRef = useRef<{ id: number }>({ id: 0 });\n\n    // Animation State - target is 1 when focused, 0 when not\n    const animRef = useRef<{ id: number }>({ id: 0 });\n    const [animProgress, setAnimProgress] = useState(0); // 0 to 1\n    const animTargetRef = useRef(0);  // Target value we're animating towards\n    const animStartRef = useRef(0);   // Starting value when animation begins\n    const animStartTimeRef = useRef(0);\n\n    // Timeouts\n    const hoverTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const showTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const lastFoundIdRef = useRef<string | null>(null);\n\n    // Cleanup timeouts on unmount\n    useEffect(() => {\n        return () => {\n            if (hoverTimeoutRef.current) clearTimeout(hoverTimeoutRef.current);\n            if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);\n        };\n    }, []);\n\n    // Initialize DPR\n    useEffect(() => {\n        setDpr(window.devicePixelRatio || 1);\n    }, []);\n\n    // Easing function for smooth animation\n    const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3);\n\n    // ANIMATION LOOP - Premium bidirectional animation\n    useEffect(() => {\n\n        if (internalFocusedId) {\n            // Animate IN\n            setLastFocusedId(internalFocusedId);\n            animTargetRef.current = 1;\n            animStartRef.current = animProgress;\n            animStartTimeRef.current = performance.now();\n\n            const animateIn = (time: number) => {\n                const elapsed = time - animStartTimeRef.current;\n                const rawProgress = Math.min(elapsed / ANIMATION_DURATION_MS, 1);\n                const easedProgress = easeOutCubic(rawProgress);\n                const newValue = animStartRef.current + (1 - animStartRef.current) * easedProgress;\n                setAnimProgress(newValue);\n\n                if (rawProgress < 1) {\n                    animRef.current.id = requestAnimationFrame(animateIn);\n                }\n            };\n            cancelAnimationFrame(animRef.current.id);\n            animRef.current.id = requestAnimationFrame(animateIn);\n        } else if (lastFocusedId) {\n            // Animate OUT (keep lastFocusedId so we know which dot to fade)\n            animTargetRef.current = 0;\n            animStartRef.current = animProgress;\n            animStartTimeRef.current = performance.now();\n\n            const animateOut = (time: number) => {\n                const elapsed = time - animStartTimeRef.current;\n                const rawProgress = Math.min(elapsed / ANIMATION_DURATION_MS, 1);\n                const easedProgress = easeOutCubic(rawProgress);\n                const newValue = animStartRef.current * (1 - easedProgress);\n                setAnimProgress(newValue);\n\n                if (rawProgress < 1) {\n                    animRef.current.id = requestAnimationFrame(animateOut);\n                } else {\n                    // Animation complete, clear the last focused id\n                    setLastFocusedId(null);\n                }\n            };\n            cancelAnimationFrame(animRef.current.id);\n            animRef.current.id = requestAnimationFrame(animateOut);\n        }\n\n        return () => cancelAnimationFrame(animRef.current.id);\n    }, [internalFocusedId]);\n\n    // Selection Animation - animate dots when they become selected/deselected\n    useEffect(() => {\n        const prevIds = prevActiveIdsRef.current;\n        const currentIds = activeVideoIds;\n\n        // Find newly selected and newly deselected\n        const newlySelected: string[] = [];\n        const newlyDeselected: string[] = [];\n\n        currentIds.forEach(id => {\n            if (!prevIds.has(id)) newlySelected.push(id);\n        });\n        prevIds.forEach(id => {\n            if (!currentIds.has(id)) newlyDeselected.push(id);\n        });\n\n        if (newlySelected.length === 0 && newlyDeselected.length === 0) {\n            prevActiveIdsRef.current = new Set(currentIds);\n            return;\n        }\n\n        // Initialize animation state for new transitions\n        setSelectionAnimProgress(prev => {\n            const next = new Map(prev);\n            newlySelected.forEach(id => {\n                // Inherit hover animation progress if this dot was being hovered\n                const wasHovered = (internalFocusedId === id || lastFocusedId === id);\n                next.set(id, prev.get(id) ?? (wasHovered ? animProgress : 0));\n            });\n            newlyDeselected.forEach(id => next.set(id, prev.get(id) ?? 1));\n            return next;\n        });\n\n        const startTime = performance.now();\n        const startValues = new Map<string, number>();\n        selectionAnimProgress.forEach((v, k) => startValues.set(k, v));\n        // For newly selected dots: inherit hover animation progress if this dot was being hovered\n        newlySelected.forEach(id => {\n            if (!startValues.has(id)) {\n                // If this dot was being hovered, start from hover progress instead of 0\n                const wasHovered = (internalFocusedId === id || lastFocusedId === id);\n                startValues.set(id, wasHovered ? animProgress : 0);\n            }\n        });\n        newlyDeselected.forEach(id => { if (!startValues.has(id)) startValues.set(id, 1); });\n\n        const animate = (time: number) => {\n            const elapsed = time - startTime;\n            const rawProgress = Math.min(elapsed / ANIMATION_DURATION_MS, 1);\n            const easedProgress = easeOutCubic(rawProgress);\n\n            setSelectionAnimProgress(prev => {\n                const next = new Map(prev);\n                newlySelected.forEach(id => {\n                    const start = startValues.get(id) ?? 0;\n                    next.set(id, start + (1 - start) * easedProgress);\n                });\n                newlyDeselected.forEach(id => {\n                    const start = startValues.get(id) ?? 1;\n                    next.set(id, start * (1 - easedProgress));\n                });\n                return next;\n            });\n\n            if (rawProgress < 1) {\n                selectionAnimRef.current.id = requestAnimationFrame(animate);\n            } else {\n                // Clean up completed animations\n                setSelectionAnimProgress(prev => {\n                    const next = new Map(prev);\n                    newlyDeselected.forEach(id => next.delete(id));\n                    return next;\n                });\n            }\n        };\n\n        cancelAnimationFrame(selectionAnimRef.current.id);\n        selectionAnimRef.current.id = requestAnimationFrame(animate);\n        prevActiveIdsRef.current = new Set(currentIds);\n\n        return () => cancelAnimationFrame(selectionAnimRef.current.id);\n    }, [activeVideoIds]);\n\n\n    const getVisibleWorldBounds = () => {\n        if (!containerRef.current) return { start: 0, end: 0 };\n        const { width } = containerRef.current.getBoundingClientRect();\n        const start = (-transform.offsetX - 500) / transform.scale;\n        const end = (width - transform.offsetX + 500) / transform.scale;\n        return { start, end };\n    };\n\n    useLayoutEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas || !containerRef.current) return;\n\n        const ctx = canvas.getContext('2d', { alpha: true });\n        if (!ctx) {\n            console.warn('[TimelineDotsLayer] Failed to get 2D canvas context');\n            return;\n        }\n\n        const { width, height } = containerRef.current.getBoundingClientRect();\n\n        const displayWidth = Math.floor(width * dpr);\n        const displayHeight = Math.floor(height * dpr);\n\n        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n            canvas.width = displayWidth;\n            canvas.height = displayHeight;\n        }\n\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.scale(dpr, dpr);\n        ctx.clearRect(0, 0, width, height);\n\n        const { start, end } = getVisibleWorldBounds();\n\n        const currentScale = transform.scale || 0.001;\n        const dotScaleFactor = Math.max(1, 0.20 / currentScale);\n        const MIN_INTERACTION_SIZE = 12;\n\n        const getVisualRadius = (baseSize: number) => {\n            const effectiveSize = Math.max(baseSize, MIN_INTERACTION_SIZE);\n            return (effectiveSize / 2) * dotScaleFactor * currentScale;\n        };\n\n        let activeHoverItem: { pos: VideoPosition, x: number, y: number, r: number } | null = null;\n        /**\n         * RENDERING STRATEGY: Two-pass approach for correct z-ordering\n         *\n         * Pass 1: Draw all non-hovered dots as background layer\n         * Pass 2: Draw hovered dot on top with glow effect\n         *\n         * This ensures the hovered element always renders above others\n         * without managing z-index in canvas context.\n         */\n        // Pass 1: Draw Non-Hovered\n        for (const pos of videoPositions) {\n            const worldX = pos.xNorm * worldWidth;\n            if (worldX < start || worldX > end) continue;\n\n            const worldY = pos.yNorm * worldHeight;\n            const screenX = worldX * transform.scale + transform.offsetX;\n            const screenY = worldY * transform.scale + transform.offsetY;\n\n            const percentileGroup = getPercentileGroup(pos.video.id);\n            const style = getDotStyle(percentileGroup);\n            const visualRadius = getVisualRadius(style.size);\n\n            // Capture item for HOVER animation (non-selected dots only)\n            // Selected dots should NOT be affected by hover - skip them\n            const isActive = activeVideoIds.has(pos.video.id);\n            const animatingId = internalFocusedId || lastFocusedId;\n            if (!isActive && pos.video.id === animatingId && animProgress > 0) {\n                activeHoverItem = { pos, x: screenX, y: screenY, r: visualRadius };\n                continue;\n            }\n\n            // Active dots get the full hover treatment (glow + scale + ring) - with animation\n            if (isActive || selectionAnimProgress.has(pos.video.id)) {\n                // Get animation progress (1 = fully selected, 0 = not selected)\n                const selectProgress = selectionAnimProgress.get(pos.video.id) ?? (isActive ? 1 : 0);\n                if (selectProgress <= 0) continue; // Skip if fully deselected\n\n                // Animate Scale: 1.0 -> 1.25 based on selection progress\n                const activeScale = 1.0 + (0.25 * selectProgress);\n                const activeRadius = visualRadius * activeScale;\n\n                // Soft Outer Glow (same as hover glow)\n                const computedStyle = getComputedStyle(document.documentElement);\n                const glowRgb = computedStyle.getPropertyValue('--dot-glow-rgb').trim() || '255, 255, 255';\n                const glowRadius = activeRadius * 3.5;\n                const gradient = ctx.createRadialGradient(\n                    screenX, screenY, activeRadius * 0.5,\n                    screenX, screenY, glowRadius\n                );\n                const glowAlpha = 0.3 * selectProgress;\n                gradient.addColorStop(0, `rgba(${glowRgb}, ${glowAlpha})`);\n                gradient.addColorStop(0.15, `rgba(${glowRgb}, ${glowAlpha * 0.7})`);\n                gradient.addColorStop(0.3, `rgba(${glowRgb}, ${glowAlpha * 0.45})`);\n                gradient.addColorStop(0.5, `rgba(${glowRgb}, ${glowAlpha * 0.2})`);\n                gradient.addColorStop(0.7, `rgba(${glowRgb}, ${glowAlpha * 0.08})`);\n                gradient.addColorStop(0.85, `rgba(${glowRgb}, ${glowAlpha * 0.02})`);\n                gradient.addColorStop(1, `rgba(${glowRgb}, 0)`);\n                ctx.beginPath();\n                ctx.arc(screenX, screenY, glowRadius, 0, 2 * Math.PI);\n                ctx.fillStyle = gradient;\n                ctx.fill();\n\n                // Active Ring (Selection) - on top of glow, with animated opacity\n                ctx.beginPath();\n                ctx.arc(screenX, screenY, activeRadius * 1.1, 0, 2 * Math.PI);\n                ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * selectProgress})`;\n                ctx.lineWidth = 2;\n                ctx.stroke();\n\n                // Main Dot (scaled + brightened)\n                ctx.beginPath();\n                ctx.arc(screenX, screenY, activeRadius, 0, 2 * Math.PI);\n                ctx.fillStyle = style.colorHex;\n                const brightness = 1 + (0.2 * selectProgress);\n                ctx.filter = `brightness(${brightness})`;\n                ctx.fill();\n                ctx.filter = 'none';\n                continue; // Skip normal rendering\n            }\n\n            // Main Dot (non-active)\n            ctx.beginPath();\n            ctx.arc(screenX, screenY, visualRadius, 0, 2 * Math.PI);\n            ctx.fillStyle = style.colorHex;\n            ctx.fill();\n        }\n\n        // Pass 2: Draw Hovered (Animated) - Match VideoNode hover style (no ring, soft glow)\n        if (activeHoverItem) {\n            const { pos, x: screenX, y: screenY, r: visualRadius } = activeHoverItem;\n            const percentileGroup = getPercentileGroup(pos.video.id);\n            const style = getDotStyle(percentileGroup);\n\n            // Animate Scale: 1.0 -> 1.25 based on animProgress (matching VideoNode's scale(1.25))\n            const scale = 1.0 + (0.25 * animProgress);\n            const animatedRadius = visualRadius * scale;\n\n            // Soft Outer Glow using radial gradient (matching VideoNode's drop-shadow)\n            if (animProgress > 0) {\n                // Get glow color from CSS variable (supports theme switching)\n                const computedStyle = getComputedStyle(document.documentElement);\n                const glowRgb = computedStyle.getPropertyValue('--dot-glow-rgb').trim() || '255, 255, 255';\n\n                const glowRadius = animatedRadius * 3.5;\n                const gradient = ctx.createRadialGradient(\n                    screenX, screenY, animatedRadius * 0.5,  // Inner circle (start fade from center of dot)\n                    screenX, screenY, glowRadius              // Outer circle (fade out completely)\n                );\n\n                const glowAlpha = 0.3 * animProgress;\n                // More color stops for ultra-smooth gradient transition\n                gradient.addColorStop(0, `rgba(${glowRgb}, ${glowAlpha})`);\n                gradient.addColorStop(0.15, `rgba(${glowRgb}, ${glowAlpha * 0.7})`);\n                gradient.addColorStop(0.3, `rgba(${glowRgb}, ${glowAlpha * 0.45})`);\n                gradient.addColorStop(0.5, `rgba(${glowRgb}, ${glowAlpha * 0.2})`);\n                gradient.addColorStop(0.7, `rgba(${glowRgb}, ${glowAlpha * 0.08})`);\n                gradient.addColorStop(0.85, `rgba(${glowRgb}, ${glowAlpha * 0.02})`);\n                gradient.addColorStop(1, `rgba(${glowRgb}, 0)`);\n\n                ctx.beginPath();\n                ctx.arc(screenX, screenY, glowRadius, 0, 2 * Math.PI);\n                ctx.fillStyle = gradient;\n                ctx.fill();\n            }\n\n            // Main Dot (Color)\n            ctx.beginPath();\n            ctx.arc(screenX, screenY, animatedRadius, 0, 2 * Math.PI);\n            ctx.fillStyle = style.colorHex;\n            ctx.fill();\n        }\n\n    }, [videoPositions, transform, worldWidth, worldHeight, activeVideoIds, internalFocusedId, lastFocusedId, dpr, animProgress, selectionAnimProgress]);\n\n\n    const handleInteraction = (e: React.MouseEvent, type: 'hover' | 'click' | 'dblclick') => {\n        const rect = containerRef.current?.getBoundingClientRect();\n        if (!rect) return;\n\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n\n        let found: VideoPosition | null = null;\n        const { start, end } = getVisibleWorldBounds();\n        const currentScale = transform.scale || 0.001;\n        const dotScaleFactor = Math.max(1, 0.20 / currentScale);\n\n\n        const getVisualRadius = (baseSize: number) => {\n            const effectiveSize = Math.max(baseSize, MIN_INTERACTION_SIZE_PX);\n            return (effectiveSize / 2) * dotScaleFactor * currentScale;\n        };\n\n\n        /**\n         * HIT DETECTION STRATEGY:\n         * When verticalSpread is low, dots overlap. We collect ALL dots under cursor\n         * and pick the one with the LARGEST baseSize (highest z-order / most views).\n         * This matches rendering order where larger dots are drawn last (on top).\n         * \n         * BUFFER SCALING: Reduce hit buffer when dots are compressed to allow\n         * precise hovering on small dots between large ones.\n         */\n        const scaledHitBuffer = DOT_HIT_BUFFER_PX * Math.max(0.1, verticalSpread);\n        const candidates: Array<{ pos: VideoPosition; dist: number }> = [];\n\n        for (let i = 0; i < videoPositions.length; i++) {\n            const pos = videoPositions[i];\n            const worldX = pos.xNorm * worldWidth;\n            if (worldX < start || worldX > end) continue;\n\n            const worldY = pos.yNorm * worldHeight;\n            const screenX = worldX * transform.scale + transform.offsetX;\n            const screenY = worldY * transform.scale + transform.offsetY;\n\n            const percentileGroup = getPercentileGroup(pos.video.id);\n            const style = getDotStyle(percentileGroup);\n            const visualRadius = getVisualRadius(style.size);\n\n            const dx = x - screenX;\n            const dy = y - screenY;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n\n            if (dist <= visualRadius + scaledHitBuffer) {\n                candidates.push({ pos, dist });\n            }\n        }\n\n        // Pick the candidate with largest baseSize (z-order priority)\n        // If tied on size, pick the closest to cursor\n        if (candidates.length > 0) {\n            candidates.sort((a, b) => {\n                const sizeDiff = b.pos.baseSize - a.pos.baseSize;\n                if (sizeDiff !== 0) return sizeDiff; // Larger first\n                return a.dist - b.dist; // Closer first if same size\n            });\n            found = candidates[0].pos;\n        }\n\n        if (type === 'hover') {\n            const foundId = found?.video.id || null;\n\n            if (foundId !== lastFoundIdRef.current) {\n                lastFoundIdRef.current = foundId;\n\n                if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);\n                if (hoverTimeoutRef.current) clearTimeout(hoverTimeoutRef.current);\n\n                if (found) {\n                    // Don't trigger hover animation for selected dots\n                    const isFoundActive = activeVideoIds.has(found.video.id);\n                    if (!isFoundActive) {\n                        setInternalFocusedId(foundId);\n                    }\n                    if (containerRef.current) containerRef.current.style.cursor = 'pointer';\n\n                    showTimeoutRef.current = setTimeout(() => {\n                        const screenX = found.xNorm * worldWidth * transform.scale + transform.offsetX + rect.left;\n                        const dotCenterY = found.yNorm * worldHeight * transform.scale + transform.offsetY + rect.top;\n\n                        const percentileGroup = getPercentileGroup(found.video.id);\n                        const style = getDotStyle(percentileGroup);\n                        const visualRadius = getVisualRadius(style.size);\n\n                        // Dot diameter for positioning (with hover scale 1.25 applied)\n                        const hoverScale = 1.25;\n                        const dotDiameter = visualRadius * 2 * hoverScale;\n\n                        // Position tooltip BELOW the dot (y = top of dot, height = dot diameter)\n                        // TrendTooltip will use smart positioning logic to decide final placement\n                        onHoverVideo({\n                            video: found.video,\n                            x: screenX,\n                            y: dotCenterY - (dotDiameter / 2),  // Top of the dot\n                            width: dotDiameter,\n                            height: dotDiameter\n                        });\n                    }, TOOLTIP_SHOW_DELAY_MS);\n\n                } else {\n                    setInternalFocusedId(null);\n                    if (containerRef.current) containerRef.current.style.cursor = ''; // Reset to inherit from parent\n\n                    hoverTimeoutRef.current = setTimeout(() => {\n                        onHoverVideo(null);\n                    }, HOVER_DEBOUNCE_MS);\n                }\n            }\n        } else if (type === 'click') {\n            e.stopPropagation(); // ALWAYS stop propagation to prevent pan logic\n\n            if (found) {\n                // Instant selection (Figma-style) - no delay\n                onClickVideo(found.video, e);\n            } else {\n                // Click on empty space - clear selection immediately\n                onClickEmpty?.();\n            }\n        } else if (type === 'dblclick') {\n            // Only zoom on Cmd/Ctrl + Double-Click (Figma-style)\n            const isModifier = e.metaKey || e.ctrlKey;\n\n            if (found && isModifier) {\n                e.stopPropagation(); // Only stop propagation if we hit a dot with modifier\n                const worldX = found.xNorm * worldWidth;\n                const worldY = found.yNorm * worldHeight;\n                onDoubleClickVideo(found.video, worldX, worldY, e);\n            }\n            // If no modifier or no dot found, let the event propagate to container for \"fit in\" behavior\n        }\n    };\n\n    return (\n        <div\n            ref={containerRef}\n            className=\"absolute inset-0 w-full h-full z-10\"\n            onMouseMove={(e) => handleInteraction(e, 'hover')}\n            onClick={(e) => handleInteraction(e, 'click')}\n            onDoubleClick={(e) => handleInteraction(e, 'dblclick')}\n            onMouseLeave={() => {\n                lastFoundIdRef.current = null;\n                setInternalFocusedId(null);\n                if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);\n                setTimeout(() => onHoverVideo(null), 200);\n            }}\n        >\n            <canvas\n                ref={canvasRef}\n                style={{ width: '100%', height: '100%' }}\n            />\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/layers/TimelineVideoLayer.tsx","messages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":54,"column":22,"nodeType":"Identifier","endLine":54,"endColumn":28},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useImperativeHandle\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":57,"column":5,"nodeType":"Identifier","endLine":57,"endColumn":24},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":66,"column":49,"nodeType":"Identifier","endLine":66,"endColumn":57},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":67,"column":51,"nodeType":"Identifier","endLine":67,"endColumn":59},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":70,"column":33,"nodeType":"Identifier","endLine":70,"endColumn":39},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":71,"column":29,"nodeType":"Identifier","endLine":71,"endColumn":35},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":72,"column":28,"nodeType":"Identifier","endLine":72,"endColumn":34},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useTimelineVirtualization\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":75,"column":31,"nodeType":"Identifier","endLine":75,"endColumn":56},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":86,"column":47,"nodeType":"Identifier","endLine":86,"endColumn":55},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useDndMonitor\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":87,"column":5,"nodeType":"Identifier","endLine":87,"endColumn":18}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, forwardRef, useImperativeHandle } from 'react';\nimport { useDndMonitor } from '@dnd-kit/core';\nimport type { TrendVideo, VideoPosition } from '../../../../core/types/trends';\nimport { useTimelineVirtualization } from '../hooks/useTimelineVirtualization';\nimport { VideoDot } from '../nodes/VideoDot';\nimport { DraggableVideoNode } from '../nodes/DraggableVideoNode';\nimport {\n    LOD_SHOW_LABEL,\n    LOD_SHOW_THUMBNAIL,\n    TOOLTIP_SHOW_DELAY_MS,\n    ELEVATION_TIMEOUT_MS,\n    HOVER_DEBOUNCE_MS\n} from '../utils/timelineConstants';\n\ninterface TimelineVideoLayerProps {\n    videoPositions: VideoPosition[];\n    transform: { scale: number; offsetX: number; offsetY: number };\n    worldWidth: number;\n    worldHeight: number;\n    activeVideoIds: Set<string>;\n    onHoverVideo: (data: { video: TrendVideo; x: number; y: number; width: number; height: number } | null) => void;\n    onDoubleClickVideo: (video: TrendVideo, worldX: number, worldY: number, e: React.MouseEvent) => void;\n    onClickVideo: (video: TrendVideo, e: React.MouseEvent) => void;\n    getPercentileGroup: (videoId: string) => string | undefined;\n    style?: React.CSSProperties;\n    isLoading?: boolean;\n    isHidden?: boolean;\n}\n\nexport interface TimelineVideoLayerHandle {\n    updateTransform: (transform: { scale: number; offsetX: number; offsetY: number }) => void;\n}\n\n\n\nexport const TimelineVideoLayer = forwardRef<TimelineVideoLayerHandle, TimelineVideoLayerProps>(({\n    videoPositions,\n    transform,\n    worldWidth,\n    worldHeight,\n    activeVideoIds,\n    style,\n    getPercentileGroup,\n    onHoverVideo,\n    onDoubleClickVideo,\n    onClickVideo,\n    isLoading = false,\n    isHidden = false\n}, ref) => {\n    // Immediate optimization: If hidden, render null to unmount heavy DOM\n    if (isHidden) return null;\n\n    // Local state for smooth interactions (hover, pan) -- decoupled from React render if needed\n    const layerRef = useRef<HTMLDivElement>(null);\n\n    // Expose imperative handle for direct DOM updates\n    useImperativeHandle(ref, () => ({\n        updateTransform: (t) => {\n            if (layerRef.current) {\n                layerRef.current.style.transform = `translate(${t.offsetX}px, ${t.offsetY}px) scale(${t.scale})`;\n            }\n        }\n    }), []);\n\n    // Internal state for hover effects\n    const [focusedVideoId, setFocusedVideoId] = useState<string | null>(null);\n    const [elevatedVideoId, setElevatedVideoId] = useState<string | null>(null);\n\n    // Timeouts\n    const elevationTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const hoverTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const showTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n    // Use Virtualization Hook\n    const { visibleVideos } = useTimelineVirtualization({\n        videoPositions,\n        transform,\n        worldWidth\n    });\n\n    // LOD state based on zoom level\n    const showThumbnails = transform.scale >= LOD_SHOW_THUMBNAIL;\n    const showLabels = transform.scale >= LOD_SHOW_LABEL;\n\n    // Track global drag state to suppress tooltips during drag\n    const [isAnyDragging, setIsAnyDragging] = useState(false);\n    useDndMonitor({\n        onDragStart: () => {\n            setIsAnyDragging(true);\n            onHoverVideo(null); // Instantly hide tooltip when drag starts\n        },\n        onDragEnd: () => setIsAnyDragging(false),\n        onDragCancel: () => setIsAnyDragging(false),\n    });\n\n    const handleMouseEnter = (e: React.MouseEvent, video: TrendVideo) => {\n        // Don't show tooltip during drag\n        if (isAnyDragging) return;\n\n        if (elevationTimeoutRef.current) clearTimeout(elevationTimeoutRef.current);\n\n        setFocusedVideoId(video.id);\n        setElevatedVideoId(video.id);\n\n        if (hoverTimeoutRef.current) clearTimeout(hoverTimeoutRef.current);\n\n        // Don't show tooltip if video is already selected\n        if (activeVideoIds.has(video.id)) return;\n\n        const rect = e.currentTarget.getBoundingClientRect();\n\n        showTimeoutRef.current = setTimeout(() => {\n            onHoverVideo({\n                video,\n                x: rect.left + rect.width / 2,\n                y: rect.top,\n                width: rect.width,\n                height: rect.height\n            });\n        }, TOOLTIP_SHOW_DELAY_MS);\n    };\n\n    const handleMouseLeave = () => {\n        setFocusedVideoId(null);\n\n        elevationTimeoutRef.current = setTimeout(() => {\n            setElevatedVideoId(null);\n        }, ELEVATION_TIMEOUT_MS);\n\n        if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);\n\n        hoverTimeoutRef.current = setTimeout(() => {\n            onHoverVideo(null);\n        }, HOVER_DEBOUNCE_MS);\n    };\n\n    return (\n        <div className=\"flex-1 relative overflow-hidden\">\n            <div\n                ref={layerRef}\n                style={{\n                    ...style,\n                    // Initialize transform style\n                    transform: `translate(${transform.offsetX}px, ${transform.offsetY}px) scale(${transform.scale})`,\n                    transformOrigin: '0 0',\n                    width: worldWidth,\n                    height: worldHeight,\n                    position: 'absolute',\n                    willChange: 'transform',\n                    '--timeline-scale': transform.scale,\n                } as React.CSSProperties}\n            >\n                {!isLoading && (showThumbnails ? (\n                    visibleVideos.map((position) => (\n                        <DraggableVideoNode\n                            key={position.video.id}\n                            position={position}\n                            worldWidth={worldWidth}\n                            worldHeight={worldHeight}\n                            isFocused={focusedVideoId === position.video.id}\n                            isElevated={elevatedVideoId === position.video.id}\n                            isActive={activeVideoIds.has(position.video.id)}\n                            showLabel={showLabels}\n                            onMouseEnter={handleMouseEnter}\n                            onMouseLeave={handleMouseLeave}\n                            onDoubleClick={onDoubleClickVideo}\n                            onClick={(e) => {\n                                e.stopPropagation();\n                                onClickVideo(position.video, e);\n                            }}\n                        />\n                    ))\n                ) : (\n                    visibleVideos.map((position) => (\n                        <VideoDot\n                            key={position.video.id}\n                            position={position}\n                            worldWidth={worldWidth}\n                            worldHeight={worldHeight}\n                            percentileGroup={getPercentileGroup(position.video.id)}\n                            isFocused={focusedVideoId === position.video.id}\n                            isElevated={elevatedVideoId === position.video.id}\n                            isActive={activeVideoIds.has(position.video.id)}\n                            onMouseEnter={handleMouseEnter}\n                            onMouseLeave={handleMouseLeave}\n                            onDoubleClick={onDoubleClickVideo}\n                            onClick={(e) => {\n                                e.stopPropagation();\n                                onClickVideo(position.video, e);\n                            }}\n                        />\n                    ))\n                ))}\n            </div>\n        </div>\n    );\n});\n\nTimelineVideoLayer.displayName = 'TimelineVideoLayer';\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/nodes/DraggableVideoNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/nodes/VideoDot.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/nodes/VideoNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/utils/timelineConstants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/utils/timelineMath.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/Timeline/utils/trendLayoutUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/TrendsDndProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/TrendsPage.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/muramets/Documents/youtube-interface/src/pages/Trends/TrendsPage.tsx:27:13\n  25 |             prevChannelForReset.current = selectedChannelId;\n  26 |             setVideos([]);\n> 27 |             setIsLoading(true);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  28 |         }\n  29 |     }, [selectedChannelId, setVideos]);\n  30 |","line":27,"column":13,"nodeType":null,"endLine":27,"endColumn":25},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'setVideos' and 'videos.length'. Either include them or remove the dependency array.","line":93,"column":8,"nodeType":"ArrayExpression","endLine":93,"endColumn":83,"suggestions":[{"desc":"Update the dependencies array to be: [visibleChannels, selectedChannelId, user.uid, currentChannel.id, apiKey, videos.length, setVideos]","fix":{"range":[4151,4226],"text":"[visibleChannels, selectedChannelId, user.uid, currentChannel.id, apiKey, videos.length, setVideos]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo, useRef } from 'react';\nimport { useTrendStore } from '../../core/stores/trendStore';\nimport { TimelineCanvas } from './Timeline/TimelineCanvas';\nimport { TrendService } from '../../core/services/trendService';\nimport { TrendsHeader } from './Header/TrendsHeader';\nimport type { TrendVideo } from '../../core/types/trends';\nimport { useFilteredVideos } from './hooks/useFilteredVideos';\nimport { useFrozenStats } from './Timeline/hooks/useFrozenStats';\n\nimport { useAuth } from '../../core/hooks/useAuth';\nimport { useChannelStore } from '../../core/stores/channelStore';\nimport { useApiKey } from '../../core/hooks/useApiKey';\n\nexport const TrendsPage: React.FC = () => {\n    const { user } = useAuth();\n    const { currentChannel } = useChannelStore();\n    const { apiKey } = useApiKey();\n    const { channels, selectedChannelId, timelineConfig, setTimelineConfig, trendsFilters, filterMode, setVideos, videos, hiddenVideos, isLoadingChannels } = useTrendStore();\n    const [isLoading, setIsLoading] = useState(true);\n\n    // Reset state when channel switches\n    const prevChannelForReset = useRef(selectedChannelId);\n    useEffect(() => {\n        if (selectedChannelId !== prevChannelForReset.current) {\n            prevChannelForReset.current = selectedChannelId;\n            setVideos([]);\n            setIsLoading(true);\n        }\n    }, [selectedChannelId, setVideos]);\n\n    // Computed visible channels\n    const visibleChannels = useMemo(() => {\n        if (selectedChannelId) {\n            return channels.filter(c => c.id === selectedChannelId);\n        }\n        return channels.filter(c => c.isVisible);\n    }, [channels, selectedChannelId]);\n\n    // Detect when on main page but all channels are hidden\n    const allChannelsHidden = !selectedChannelId && channels.length > 0 && visibleChannels.length === 0;\n\n    // Load videos for visible channels\n    const hasLoadedOnceRef = useRef(false);\n    const prevSelectedChannelRef = useRef(selectedChannelId);\n\n    useEffect(() => {\n        const loadVideos = async () => {\n            if (!user?.uid || !currentChannel?.id) return;\n\n            const isChannelSwitch = prevSelectedChannelRef.current !== selectedChannelId;\n            const isInitialLoad = !hasLoadedOnceRef.current;\n\n            if (isInitialLoad || isChannelSwitch || videos.length === 0) {\n                setIsLoading(true);\n            }\n\n            prevSelectedChannelRef.current = selectedChannelId;\n\n            const allVideos: TrendVideo[] = [];\n\n            for (const channel of visibleChannels) {\n                // 1. Try local cache\n                let channelVideos = await TrendService.getChannelVideosFromCache(channel.id);\n\n                // 2. If empty, try Firestore (sync layer)\n                if (channelVideos.length === 0) {\n                    console.log(`[TrendsPage] Local cache empty for ${channel.title}, loading from Firestore...`);\n                    channelVideos = await TrendService.getChannelVideosFromFirestore(user.uid, currentChannel.id, channel.id);\n                }\n\n                allVideos.push(...channelVideos.map(v => ({\n                    ...v,\n                    channelTitle: channel.title\n                })));\n\n                // 3. Check for staleness/completeness and background sync if needed\n                const isStale = Date.now() - (channel.lastUpdated || 0) > 12 * 60 * 60 * 1000; // 12 hours\n                const needsInitialSync = channel.lastUpdated === 0 || channelVideos.length === 0;\n\n                if ((isStale || needsInitialSync) && apiKey) {\n                    console.log(`[TrendsPage] Triggering background sync for ${channel.title}...`);\n                    // We don't await this as it's background\n                    TrendService.syncChannelVideos(user.uid, currentChannel.id, channel, apiKey).catch(console.error);\n                }\n            }\n            allVideos.sort((a, b) => a.publishedAtTimestamp - b.publishedAtTimestamp);\n\n            setVideos(allVideos);\n            setIsLoading(false);\n            hasLoadedOnceRef.current = true;\n        };\n        loadVideos();\n    }, [visibleChannels, selectedChannelId, user?.uid, currentChannel?.id, apiKey]);\n\n\n    // Calculate Global Percentile Map\n    const globalPercentileMap = useMemo(() => {\n        if (videos.length === 0) return new Map<string, string>();\n        const sortedByViews = [...videos].sort((a, b) => b.viewCount - a.viewCount);\n        const map = new Map<string, string>();\n        sortedByViews.forEach((v, i) => {\n            const percentile = (i / videos.length) * 100;\n            let group: string;\n            if (percentile <= 1) group = 'Top 1%';\n            else if (percentile <= 5) group = 'Top 5%';\n            else if (percentile <= 20) group = 'Top 20%';\n            else if (percentile <= 80) group = 'Middle 60%';\n            else group = 'Bottom 20%';\n            map.set(v.id, group);\n        });\n        return map;\n    }, [videos]);\n\n    // Apply Filters using extracted hook\n    const filteredVideos = useFilteredVideos({\n        videos,\n        trendsFilters,\n        hiddenVideos,\n        selectedChannelId,\n        globalPercentileMap\n    });\n\n    // All videos without hidden (global context for the current channel/view)\n    const allVideos = useMemo(() => {\n        const hiddenIds = new Set(hiddenVideos.map(hv => hv.id));\n        return videos.filter(v => {\n            if (hiddenIds.has(v.id)) return false;\n            // Crucial: Limit context to the currently selected channel!\n            if (selectedChannelId && v.channelId !== selectedChannelId) return false;\n            return true;\n        });\n    }, [videos, hiddenVideos, selectedChannelId]);\n\n    // List of active niche IDs (excluding TRASH and UNASSIGNED)\n    const { activeNicheIds, hasUnassignedFilter } = useMemo(() => {\n        const nicheFilter = trendsFilters.find(f => f.type === 'niche');\n        if (!nicheFilter) return { activeNicheIds: [], hasUnassignedFilter: false };\n        const nicheIds = (nicheFilter.value as string[]) || [];\n        // TRASH and UNASSIGNED are special modes, not real niche filters\n        return {\n            activeNicheIds: nicheIds.filter(id => id !== 'TRASH' && id !== 'UNASSIGNED'),\n            hasUnassignedFilter: nicheIds.includes('UNASSIGNED')\n        };\n    }, [trendsFilters]);\n\n    // Generate Filter Hash for Smart Auto-Updates\n    // This allows us to distinguish between \"Filter/Niche Switch\" (Auto-Update) \n    // and \"Global Visibility Toggle\" (Manual Update)\n    // Generate Filter Hash for Smart Auto-Updates\n    // This allows us to distinguish between \"Filter/Niche Switch\" (Auto-Update) \n    // and \"Global Visibility Toggle\" (Manual Update)\n    const filterHash = useMemo(() => {\n        const nicheKey = activeNicheIds.sort().join(',');\n        const otherFiltersKey = trendsFilters\n            .filter(f => f.type !== 'niche')\n            .map(f => `${f.type}:${f.operator}:${f.value}`)\n            .sort()\n            .join('|');\n\n        // Include selectedChannelId so switching channels triggers auto-fit\n        // AND include hasUnassignedFilter so toggling it triggers a hash change (and thus auto-fit)\n        return `${selectedChannelId || 'global'}:${nicheKey}:${hasUnassignedFilter ? 'unassigned' : ''}:${otherFiltersKey}`;\n    }, [activeNicheIds, trendsFilters, selectedChannelId, hasUnassignedFilter]);\n\n    // Managed Stats Logic\n    const { currentStats, frozenStats, shouldAutoFit, refreshStats, skipAutoFitRef } = useFrozenStats({\n        allVideos,\n        filteredVideos,\n        channels,\n        selectedChannelId,\n        filterMode,\n        hasUnassignedFilter,\n        filterHash\n    });\n\n    return (\n        <div className=\"flex flex-col h-full bg-bg-primary\">\n            <TrendsHeader\n                title={selectedChannelId ? channels.find(c => c.id === selectedChannelId)?.title || 'Unknown Channel' : 'All Channels'}\n                videoCount={filteredVideos.length}\n                channelCount={selectedChannelId ? 1 : channels.length}\n                showChannelCount={!selectedChannelId}\n                timelineConfig={timelineConfig}\n                setTimelineConfig={setTimelineConfig}\n                isLoading={isLoading || isLoadingChannels}\n                availableMinDate={currentStats?.minDate}\n                availableMaxDate={currentStats?.maxDate}\n            />\n\n            <TimelineCanvas\n                key={selectedChannelId || 'all'}\n                videos={filteredVideos}\n                allVideos={allVideos}\n                isLoading={isLoading || isLoadingChannels}\n                percentileMap={globalPercentileMap}\n                frozenStats={frozenStats}\n                currentStats={currentStats}\n                shouldAutoFit={shouldAutoFit}\n                onRequestStatsRefresh={refreshStats}\n                skipAutoFitRef={skipAutoFitRef}\n                filterHash={filterHash}\n                allChannelsHidden={allChannelsHidden}\n            />\n        </div>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/hooks/useFilteredVideos.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/hooks/useNicheAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/hooks/useTrendSubscription.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/pages/Trends/hooks/useTrendsDragDrop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/src/test/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/muramets/Documents/youtube-interface/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
